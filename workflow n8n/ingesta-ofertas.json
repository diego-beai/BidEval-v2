{
  "nodes": [
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Generate Stable ID + Detectar Modo (NOMBRES CORRECTOS)\n// =============================================\n\nfunction simpleHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(16, '0').substring(0, 16);\n}\n\nconst body = $json.body;\n\n// CAMPOS EXISTENTES\nconst originalFileId = body.file_id || \"unknown\";\nconst fileTitle = body.file_title || \"unknown.pdf\";\nconst fileBinary = body.file_binary || \"\";\nconst fileUrl = body.file_url || \"unknown\";\n\n// ‚úÖ EXTRAER METADATA DEL USUARIO (NOMBRES CORRECTOS)\nconst metadata = body.metadata || {};\nconst rfqProjectId = metadata.proyect_name || null;        // ‚Üê proyect_name\nconst userProveedor = metadata.proveedor || null;          // ‚Üê proveedor\nconst userTipoEval = metadata.evaluation || null;          // ‚Üê evaluation (Array)\n\n// ‚úÖ DETERMINAR MODO DE OPERACI√ìN\nlet modoOperacion = \"CLASIFICADOR\"; // Por defecto\nlet datosCompletos = false;\n\n// Verificar si tiene datos suficientes para VALIDACI√ìN\nif (userProveedor && userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0) {\n    modoOperacion = \"VALIDADOR\";\n    datosCompletos = true;\n} else if (userProveedor || (userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0)) {\n    modoOperacion = \"HIBRIDO\"; // Tiene algunos datos pero no todos\n}\n\n// Generar ID estable del archivo\nconst normalizedTitle = fileTitle.toLowerCase().trim();\nconst stableId = simpleHash(normalizedTitle);\n\n// LOGGING\nconsole.log(\"=== AN√ÅLISIS DE METADATA ===\");\nconsole.log(`Modo Operaci√≥n: ${modoOperacion}`);\nconsole.log(`RFQ Project Name: ${rfqProjectId || 'No especificado'}`);\nconsole.log(`Proveedor (Usuario): ${userProveedor || 'No especificado'}`);\nconsole.log(`Evaluation (Usuario): ${JSON.stringify(userTipoEval) || 'No especificado'}`);\nconsole.log(`Datos Completos: ${datosCompletos}`);\nconsole.log(`Original ID: ${originalFileId}`);\nconsole.log(`Nombre archivo: ${fileTitle}`);\nconsole.log(`ID ESTABLE generado: ${stableId}`);\n\n// RETORNO\nreturn {\n  json: {\n    // Datos directos en ra√≠z\n    file_id: stableId,\n    file_id_original: originalFileId,\n    file_title: fileTitle,\n    file_binary: fileBinary,\n    file_url: fileUrl,\n    \n    rfq_project_id: rfqProjectId || \"proyecto_sin_especificar\",\n    user_proveedor: userProveedor,\n    user_tipo_evaluacion: userTipoEval,\n    modo_operacion: modoOperacion,\n    datos_usuario_completos: datosCompletos,\n    \n    // Mantener body completo\n    body: {\n      ...body,\n      file_id: stableId,\n      file_id_original: originalFileId,\n      rfq_project_id: rfqProjectId || \"proyecto_sin_especificar\",\n      user_proveedor: userProveedor,\n      user_tipo_evaluacion: userTipoEval,\n      modo_operacion: modoOperacion,\n      datos_usuario_completos: datosCompletos\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        -848
      ],
      "id": "7bd6d639-22c5-43c6-8384-1d4761e5ed53",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Convertir Base64 a Binary Data (CORREGIDO v3)\n// =============================================\n\n// LEER DIRECTAMENTE DEL NODO \"Set File ID\"\nlet inputData;\ntry {\n    inputData = $('Set File ID').first().json;\n} catch (e) {\n    throw new Error(\"‚ùå No se puede acceder al nodo 'Set File ID'\");\n}\n\nconst base64Data = inputData.file_binary;\n\n// --- VALIDACI√ìN CR√çTICA ---\nif (!base64Data || base64Data === \"\") {\n    console.error(\"‚ùå ERROR: file_binary est√° vac√≠o\");\n    console.error(\"Datos en 'Set File ID':\", Object.keys(inputData));\n    console.error(\"file_id:\", inputData.file_id);\n    console.error(\"file_title:\", inputData.file_title);\n    \n    throw new Error(\n        \"‚ùå CR√çTICO: 'file_binary' no existe en 'Set File ID'. \" +\n        \"Verifica la configuraci√≥n del nodo.\"\n    );\n}\n\n// Validar que sea string\nif (typeof base64Data !== 'string') {\n    throw new Error(`‚ùå ERROR: 'file_binary' debe ser string, es ${typeof base64Data}`);\n}\n\n// Logging\nconsole.log(\"‚úÖ file_binary recibido de 'Set File ID'\");\nconsole.log(`   ‚îú‚îÄ Longitud: ${base64Data.length} caracteres`);\nconsole.log(`   ‚îú‚îÄ Archivo: ${inputData.file_title}`);\n\n// Convertir base64 a binary\nlet binaryData;\ntry {\n    binaryData = Buffer.from(base64Data, 'base64');\n} catch (e) {\n    throw new Error(`‚ùå ERROR decodificando base64: ${e.message}`);\n}\n\n// Validar tama√±o\nif (binaryData.length === 0) {\n    throw new Error(\"‚ùå ERROR: Archivo decodificado vac√≠o (0 bytes)\");\n}\n\nconsole.log(`‚úÖ Binary generado: ${binaryData.length} bytes`);\n\n// Retornar formato n8n\nreturn {\n    json: {\n        file_id: inputData.file_id,\n        file_title: inputData.file_title,\n        file_url: inputData.file_url || \"unknown\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'document.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        -960
      ],
      "id": "cc629036-f814-42f0-ac1a-f6d3bde23eb0",
      "name": "Base64 a Binary1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Convertir Base64 a Binary Data (CORREGIDO v3)\n// =============================================\n\n// LEER DIRECTAMENTE DEL NODO \"Set File ID\"\nlet inputData;\ntry {\n    inputData = $('Set File ID').first().json;\n} catch (e) {\n    throw new Error(\"‚ùå No se puede acceder al nodo 'Set File ID'\");\n}\n\nconst base64Data = inputData.file_binary;\n\n// --- VALIDACI√ìN CR√çTICA ---\nif (!base64Data || base64Data === \"\") {\n    console.error(\"‚ùå ERROR: file_binary est√° vac√≠o\");\n    console.error(\"Datos en 'Set File ID':\", Object.keys(inputData));\n    console.error(\"file_id:\", inputData.file_id);\n    console.error(\"file_title:\", inputData.file_title);\n    \n    throw new Error(\n        \"‚ùå CR√çTICO: 'file_binary' no existe en 'Set File ID'. \" +\n        \"Verifica la configuraci√≥n del nodo.\"\n    );\n}\n\n// Validar que sea string\nif (typeof base64Data !== 'string') {\n    throw new Error(`‚ùå ERROR: 'file_binary' debe ser string, es ${typeof base64Data}`);\n}\n\n// Logging\nconsole.log(\"‚úÖ file_binary recibido de 'Set File ID'\");\nconsole.log(`   ‚îú‚îÄ Longitud: ${base64Data.length} caracteres`);\nconsole.log(`   ‚îú‚îÄ Archivo: ${inputData.file_title}`);\n\n// Convertir base64 a binary\nlet binaryData;\ntry {\n    binaryData = Buffer.from(base64Data, 'base64');\n} catch (e) {\n    throw new Error(`‚ùå ERROR decodificando base64: ${e.message}`);\n}\n\n// Validar tama√±o\nif (binaryData.length === 0) {\n    throw new Error(\"‚ùå ERROR: Archivo decodificado vac√≠o (0 bytes)\");\n}\n\nconsole.log(`‚úÖ Binary generado: ${binaryData.length} bytes`);\n\n// Retornar formato n8n\nreturn {\n    json: {\n        file_id: inputData.file_id,\n        file_title: inputData.file_title,\n        file_url: inputData.file_url || \"unknown\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'document.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        128,
        -848
      ],
      "id": "d7f1d26b-a4ac-4921-865b-83dae26654fa",
      "name": "Base64 a Binary"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ofertas-proveedores",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -880,
        -848
      ],
      "id": "de528297-c9b2-4081-9485-56f889ea3cbd",
      "name": "Webhook",
      "webhookId": "54339356-4e6d-4e22-9820-6e1e98e167a8"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        -48,
        -1904
      ],
      "id": "f95a20d6-4327-4e99-9f5b-102de2d3dff0",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Agrupar Requisitos por Phase (CON BATCHING)\n// =============================================\n\nconst items = $input.all();\nconst BATCH_SIZE = 5; // OPTIMIZADO: Batches m√°s peque√±os = respuestas m√°s r√°pidas y precisas\n\n// Agrupar requisitos por phase\nconst grupos = {};\nitems.forEach(item => {\n    const phase = item.json.phase || \"Sin Phase\";\n    if (!grupos[phase]) {\n        grupos[phase] = [];\n    }\n    grupos[phase].push(item.json);\n});\n\n// Obtener texto de oferta\nlet textoOfertaCompleto = \"\";\ntry {\n    const loopData = $('Loop Over Items1').first().json;\n    textoOfertaCompleto = loopData.texto_oferta_completo || \"\";\n} catch(e) {\n    console.warn('‚ö†Ô∏è No se pudo obtener texto de oferta:', e.message);\n}\n\n// Crear batches por cada phase\nconst batches = [];\n\nObject.entries(grupos).forEach(([phase, requisitos]) => {\n    const evaluationType = requisitos[0]?.evaluation_type || \"Technical Evaluation\";\n    \n    // Dividir en batches de BATCH_SIZE\n    for (let i = 0; i < requisitos.length; i += BATCH_SIZE) {\n        const batch = requisitos.slice(i, i + BATCH_SIZE);\n        batches.push({\n            json: {\n                phase: phase,\n                requisitos: batch,\n                total_requisitos: batch.length,\n                batch_index: Math.floor(i / BATCH_SIZE) + 1,\n                total_batches: Math.ceil(requisitos.length / BATCH_SIZE),\n                texto_oferta_completo: textoOfertaCompleto,\n                es_oferta_larga: true,\n                evaluation_type: evaluationType\n            }\n        });\n    }\n});\n\nconsole.log(`üìä Generados ${batches.length} batches de m√°ximo ${BATCH_SIZE} requisitos`);\n\nreturn batches;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        192,
        -1680
      ],
      "id": "755d4661-dd5a-450f-9979-4b42ab0968a3",
      "name": "Agrupar por Phase"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => ({\n    json: {\n        ...item.json, // Mantiene todos los datos originales (incluido tipo_evaluacion)\n        \n        // Aqu√≠ est√° la correcci√≥n: Usamos dos puntos, no el igual.\n        reiniciar_bucle: true \n    }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        -1680
      ],
      "id": "d41ab7b9-aa9c-42b4-969e-841ed2795a43",
      "name": "Reset Items"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1808,
        -848
      ],
      "id": "e47d0bd7-0c65-47bd-aa82-00d2069382e6",
      "name": "Merge1"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"proveedor_detectado\": {\n      \"type\": \"string\",\n      \"description\": \"Nombre de la empresa proveedora (Ej: SACYR, IDOM, etc.)\"\n    },\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"Technical Evaluation\",\n          \"Economical Evaluation\",\n          \"Pre-FEED Deliverables\",\n          \"FEED Deliverables\"\n        ]\n      },\n      \"description\": \"Lista de tipos de oferta detectados en el documento.\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\",\n      \"description\": \"Breve explicaci√≥n de por qu√© se eligieron esos tipos.\"\n    }\n  },\n  \"required\": [\n    \"proveedor_detectado\",\n    \"tipos_detectados\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2656,
        -432
      ],
      "id": "b690454c-c2f0-45e8-bd2c-377123d8b026",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://unlaconic-ardelle-pretenceful.ngrok-free.dev/v1/convert/file",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "files",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {
          "timeout": 300000
        }
      },
      "id": "a3be00b9-9fd5-47c3-bde9-dc46343437a8",
      "name": "Docling OCR",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1344,
        -1056
      ],
      "retryOnFail": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -496,
        -1632
      ],
      "id": "d7d5dff4-ddcb-4ccc-9a08-00454a3ae58a",
      "name": "Loop Over Items1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Expandir por Tipo de Evaluaci√≥n (v3 - DIRECTO DEL USUARIO)\n// SIN clasificador ni validador LLM - usa datos del usuario directamente\n// =============================================\n\n// 1. RECUPERAR TEXTO Y CONTENIDO BASE\nlet fullText = \"\";\nlet totalPages = 1;\ntry {\n    const mergeData = $('Merge1').first().json;\n    fullText = (mergeData.pages && mergeData.pages[0]) \n        ? mergeData.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\") \n        : (mergeData.text || \"\");\n    totalPages = mergeData.totalPages || 1;\n} catch (e) {\n    console.error(\"‚ùå Error leyendo Merge1\");\n}\n\n// 2. USAR DIRECTAMENTE DATOS DEL USUARIO (Set File ID)\nlet fileId = \"unknown\";\nlet proveedor = \"OTROS\";\nlet tipoEval = [\"Technical Evaluation\"];\nlet projectName = \"proyecto_sin_especificar\";\n\ntry {\n    const fileData = $('Set File ID').first().json;\n    fileId = fileData.file_id || \"unknown\";\n    proveedor = fileData.proveedor || \"OTROS\";\n    projectName = fileData.proyect_name || \"proyecto_sin_especificar\";\n    \n    // Tipos de evaluaci√≥n del usuario\n    if (fileData.evaluation && Array.isArray(fileData.evaluation) && fileData.evaluation.length > 0) {\n        tipoEval = fileData.evaluation;\n    } else if (fileData.evaluation && typeof fileData.evaluation === 'string') {\n        tipoEval = [fileData.evaluation];\n    }\n    \n    console.log(`‚úÖ Usando datos del usuario directamente:`);\n    console.log(`   Proveedor: ${proveedor}`);\n    console.log(`   Proyecto: ${projectName}`);\n    console.log(`   Tipos: ${JSON.stringify(tipoEval)}`);\n} catch (e) {\n    console.error(\"‚ùå Error leyendo Set File ID:\", e.message);\n}\n\n// 3. NORMALIZAR TIPOS\nif (!Array.isArray(tipoEval)) tipoEval = [tipoEval];\ntipoEval = tipoEval.filter(t => t && t.trim() !== \"\");\nif (tipoEval.length === 0) tipoEval = [\"Technical Evaluation\"];\n\n// 4. GENERAR FILAS\nreturn tipoEval.map((tipo, idx) => ({\n    json: {\n        tipo_evaluacion_actual: tipo,\n        proveedor_detectado: proveedor,\n        proyecto_nombre: projectName,\n        texto_oferta_completo: fullText,\n        indice_actual: idx + 1,\n        total_tipos: tipoEval.length,\n        file_id: fileId\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        -1552
      ],
      "id": "48d21e73-9ee3-44a7-9577-7a2947893e96",
      "name": "Expandir por Tipo de Evaluaci√≥n"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Format for Vectorstore (v3 - DIRECTO DEL USUARIO)\n// SIN clasificador ni validador LLM\n// =============================================\n\n// 1. RECUPERAR CONTENIDO\nlet fullText = \"\";\nlet totalPages = 1;\n\ntry {\n    const mergeData = $('Merge1').first().json;\n    if (mergeData.pages && mergeData.pages[0]) {\n        fullText = mergeData.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\");\n    } else {\n        fullText = mergeData.text || \"\";\n    }\n    totalPages = mergeData.totalPages || 1;\n} catch (e) {\n    console.log(\"‚ùå Error leyendo de Merge1\");\n}\n\n// 2. USAR DIRECTAMENTE DATOS DEL USUARIO (Set File ID)\nlet fileId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet proveedor = \"OTROS\";\nlet tipoEval = [\"Technical Evaluation\"];\nlet proyecto = \"\";\n\ntry {\n    const fileNode = $('Set File ID').first().json;\n    fileId = fileNode.file_id || \"unknown\";\n    fileTitle = fileNode.file_title || \"unknown\";\n    proveedor = fileNode.proveedor || \"OTROS\";\n    proyecto = fileNode.proyect_name || \"\";\n    \n    if (fileNode.evaluation && Array.isArray(fileNode.evaluation) && fileNode.evaluation.length > 0) {\n        tipoEval = fileNode.evaluation;\n    } else if (fileNode.evaluation && typeof fileNode.evaluation === 'string') {\n        tipoEval = [fileNode.evaluation];\n    }\n} catch(e) {\n    console.log(\"‚ùå Error leyendo Set File ID\");\n}\n\n// 3. GENERAR SALIDA\nreturn {\n    json: {\n        text: fullText,\n        metadata: {\n            file_id: fileId,\n            file_title: fileTitle,\n            proveedor: proveedor,\n            tipo_evaluacion: tipoEval,\n            project_name: proyecto,\n            processed_at: new Date().toISOString(),\n            total_pages: totalPages\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2864,
        -864
      ],
      "id": "c5be520a-15a9-4c66-829f-e933855edc10",
      "name": "Format for Vectorstore"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Texto de Muestra (STRICT LIMIT)\n// =============================================\n\nconst items = $input.all();\n\nreturn items.map(item => {\n    let texto_muestra = \"SIN TEXTO\";\n\n    try {\n        if (item.json.pages && Array.isArray(item.json.pages) && item.json.pages.length > 0) {\n            // Unimos las 2 primeras p√°ginas pero limitamos el total a 3000 caracteres\n            let rawJoin = item.json.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\");\n            texto_muestra = rawJoin.substring(0, 3000);\n        } else {\n            // Fallback extremadamente corto para texto plano\n            texto_muestra = (item.json.text || \"\").substring(0, 500);\n        }\n    } catch (e) {\n        console.error(\"Error al procesar p√°ginas:\", e);\n    }\n\n    return {\n        json: {\n            ...item.json,\n            texto_muestra: texto_muestra\n        }\n    };\n});"
      },
      "id": "94c437f9-d05e-418d-8716-567058256b6a",
      "name": "Preparar Texto de Muestra",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        -848
      ]
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Aggregate OCR Pages (CORREGIDO)\n// =============================================\n\nconst items = $input.all();\nlet fullText = \"\";\nlet pagesArray = [];\n\n// OPCI√ìN A: Si Tesseract devuelve m√∫ltiples items (1 por p√°gina)\nif (items.length > 1) {\n  items.forEach((item, idx) => {\n    const pageText = item.json.text || \"\";\n    fullText += pageText + \"\\n\\n\";\n    \n    // Construimos array compatible con vectorstore\n    pagesArray.push({\n      text: pageText,\n      pageNumber: idx + 1\n    });\n  });\n}\n// OPCI√ìN B: Si Tesseract devuelve un solo item con todo el texto\nelse if (items.length === 1) {\n  fullText = items[0].json.text || \"\";\n  pagesArray = [{\n    text: fullText,\n    pageNumber: 1\n  }];\n}\n\n// RECUPERAR METADATOS ORIGINALES (CR√çTICO)\nlet fileId, fileName, proveedor;\ntry {\n  fileId = $('Set File ID').first().json.file_id;\n  fileName = $('Set File ID').first().json.file_title;\n  proveedor = $('Set File ID').first().json.proveedor || \"OTROS\";\n} catch (e) {\n  console.error(\"‚ö†Ô∏è No se pudieron recuperar metadatos:\", e.message);\n  fileId = \"unknown\";\n  fileName = \"unknown\";\n  proveedor = \"OTROS\";\n}\n\nconsole.log(`üîÑ OCR Agregado: ${items.length} p√°ginas ‚Üí ${fullText.length} caracteres`);\n\n// ESTRUCTURA COMPATIBLE CON VECTORSTORE\nreturn {\n  json: {\n    pages: pagesArray, // ‚Üê Array de p√°ginas (requerido por Default Data Loader)\n    text: fullText, // ‚Üê Texto completo (backup)\n    \n    // Metadatos cr√≠ticos\n    file_id: fileId,\n    file_title: fileName,\n    proveedor: proveedor,\n    \n    // Marca de origen\n    origen_datos: \"OCR_TESSERACT\",\n    ocr_pages_processed: items.length,\n    ocr_total_chars: fullText.length\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1552,
        -960
      ],
      "id": "a9dc75d3-432f-46a6-8020-d436375cec7d",
      "name": "Aggregate OCR Pages"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "57b9c551-9997-4ed5-8ddd-f80c108a177c",
              "leftValue": "={{ $json.needsOCR }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        912,
        -848
      ],
      "id": "dd0bfaaa-1095-4604-b952-8bfd56a5724d",
      "name": "¬øNecesita OCR?"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        352,
        -848
      ],
      "id": "305eecab-654d-47c7-88b9-faa17d613f97",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Validar Contenido PDF (FIX PAGINACI√ìN)\n// =============================================\n\nconst input = $input.first().json;\n\n// Variables de inicializaci√≥n\nlet pages = [];\nlet totalChars = 0;\nlet hasTablesDetected = false;\n\n// --- 1. PROCESAMIENTO DEL TEXTO ---\n\n// CASO A: Viene desglosado por p√°ginas (Array)\nif (input.pages && Array.isArray(input.pages) && input.pages.length > 0) {\n  pages = input.pages;\n  pages.forEach(page => {\n    const text = page.text || page.pageContent || \"\";\n    totalChars += text.length;\n    // Detecci√≥n simple de tablas\n    if ((text.match(/\\s{4,}/g) || []).length > 5) hasTablesDetected = true;\n  });\n\n// CASO B: Viene todo el texto junto (String) - ESTE ES TU CASO ACTUAL\n} else if (input.text && typeof input.text === 'string') {\n  const text = input.text;\n  totalChars = text.length;\n  // Creamos una \"p√°gina √∫nica\" contenedora para no romper el flujo\n  pages = [{ text: text, pageNumber: 1 }];\n  \n  // Detectar tablas en el texto completo\n  if ((text.match(/\\s{4,}/g) || []).length > 20) hasTablesDetected = true;\n  \n} else {\n  // CASO C: Vac√≠o\n  pages = [];\n}\n\n// --- 2. C√ÅLCULO DE P√ÅGINAS REALES (FIX CR√çTICO) ---\n\n// Intentamos leer el metadato 'numpages' que se ve en tu captura\nlet realPageCount = input.numpages || input.numPages || input.numberOfPages || 0;\n\n// Si no existe el metadato, usamos la longitud del array (fallback)\nif (!realPageCount || realPageCount === 0) {\n    realPageCount = pages.length;\n}\n\n// Si sigue siendo 1 pero el texto es enorme (>10k chars), estimamos\nif (realPageCount <= 1 && totalChars > 10000) {\n    // Estimaci√≥n conservadora: 3000 caracteres por p√°gina t√©cnica\n    realPageCount = Math.ceil(totalChars / 3000);\n}\n\n// Evitar divisi√≥n por cero\nrealPageCount = Math.max(1, realPageCount);\n\n\n// --- 3. M√âTRICAS FINALES ---\n\nconst avgCharsPerPage = totalChars / realPageCount;\n\n// CRITERIO: ¬øNecesita OCR?\n// Si hay texto (< 100 chars/pag) es probable que sea escaneado.\nconst needsOCR = avgCharsPerPage < 100; \n\n// Metadatos\nlet fileId = \"unknown\";\nlet fileTitle = \"unknown\";\ntry {\n  const metaNode = $('Set File ID').first().json;\n  fileId = metaNode.file_id;\n  fileTitle = metaNode.file_title;\n} catch (e) {}\n\n// --- LOGGING ---\nconsole.log(`üìÑ An√°lisis: ${fileTitle}`);\nconsole.log(`   ‚îú‚îÄ P√°ginas (Metadato): ${input.numpages}`); \nconsole.log(`   ‚îú‚îÄ P√°ginas (Usadas): ${realPageCount}`);\nconsole.log(`   ‚îú‚îÄ Caracteres Totales: ${totalChars}`);\nconsole.log(`   ‚îú‚îÄ Promedio/P√°g: ${Math.round(avgCharsPerPage)}`);\n\nreturn {\n  json: {\n    // M√©tricas corregidas\n    totalPages: realPageCount, // Ahora dir√° 235\n    totalChars: totalChars,\n    avgCharsPerPage: Math.round(avgCharsPerPage), // Ahora ser√° un n√∫mero razonable (~2800)\n    hasTables: hasTablesDetected,\n    needsOCR: needsOCR,\n    \n    // Contenido\n    pages: pages, \n    \n    // Metadatos\n    fileId: fileId,\n    fileName: fileTitle\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        -848
      ],
      "id": "e0372e49-2459-456b-b6b7-dbf60bcd4540",
      "name": "Validar Contenido PDF"
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "proposals",
          "mode": "list",
          "cachedResultName": "proposals"
        },
        "options": {
          "queryName": "match_proposals"
        }
      },
      "id": "83b52473-af3c-4de1-b2be-c52f07becf29",
      "name": "Insert into Supabase Vectorstore",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1,
      "position": [
        3040,
        -864
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "chunkSize": 1200,
        "chunkOverlap": 200,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        3072,
        -400
      ],
      "id": "4a693dc3-3044-45f4-a6ad-607646d4d662",
      "name": "Recursive Character Text Splitter"
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $json.text }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $json.metadata.file_id }}"
              },
              {
                "name": "file_title",
                "value": "={{ $json.metadata.file_title }}"
              },
              {
                "name": "tipo_evaluacion",
                "value": "={{ $json.metadata.tipo_evaluacion }}"
              },
              {
                "name": "proveedor",
                "value": "={{ $json.metadata.proveedor }}"
              },
              {
                "name": "project_name",
                "value": "={{ $json.metadata.project_name }}"
              }
            ]
          }
        }
      },
      "id": "25eea6cc-6f4d-42a7-8a87-5f50712c4503",
      "name": "Default Data Loader",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        3168,
        -576
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "10646eae-ae46-4327-a4dc-9987c2d76173",
              "name": "file_id",
              "value": "={{ $json.body.file_id }}",
              "type": "string"
            },
            {
              "id": "77d782de-169d-4a46-8a8e-a3831c04d90f",
              "name": "file_title",
              "value": "={{ $json.body.file_title }}",
              "type": "string"
            },
            {
              "id": "9bde4d7f-e4f3-4ebd-9338-dce1350f9eab",
              "name": "file_url",
              "value": "={{ $json.body.file_url }}",
              "type": "string"
            },
            {
              "id": "b1dbe9b9-248a-4593-a769-a085b34e0810",
              "name": "file_binary",
              "value": "={{ $json.body.file_binary }}",
              "type": "string"
            },
            {
              "id": "74d93dce-cddc-4947-ae19-88bc5cacd146",
              "name": "file_metadata",
              "value": "={{ $json.body.metadata }}",
              "type": "string"
            },
            {
              "id": "5e43f8d4-b48e-4188-89c8-3723f184dbeb",
              "name": "proyect_name",
              "value": "={{ $json.body.metadata.proyecto }}",
              "type": "string"
            },
            {
              "id": "1093ebc6-8dd8-4c5d-b146-b6f01b069be6",
              "name": "proveedor",
              "value": "={{ $json.body.user_proveedor }}",
              "type": "string"
            },
            {
              "id": "6e0e6e2a-9b88-403e-aa0a-da0eecccd3f9",
              "name": "evaluation",
              "value": "={{ $json.body.metadata.tipoEvaluacion }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "id": "d4134a82-39ae-440f-8f87-08403065ec2a",
      "name": "Set File ID",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -448,
        -848
      ]
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "proposals",
        "filterType": "string",
        "filterString": "=metadata->>file_id=like.*{{ $json.file_id }}*"
      },
      "id": "9b3bdcd4-d9f9-4df0-bc90-41491332f8a5",
      "name": "Delete Old Doc Rows",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -256,
        -848
      ],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_metadata",
          "mode": "list",
          "cachedResultName": "document_metadata"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $('Set File ID').item.json.file_id }}",
            "title": "={{ $('Set File ID').item.json.file_title }}",
            "project_name": "={{ $('Set File ID').item.json.proyect_name }}\n",
            "evaluation_types": "={{ $('Set File ID').item.json.evaluation }}",
            "document_type": "PROPOSAL",
            "provider": "={{ $('Set File ID').item.json.proveedor }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": true,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "title",
              "displayName": "title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "project_name",
              "displayName": "project_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "document_type",
              "displayName": "document_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "provider",
              "displayName": "provider",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "evaluation_types",
              "displayName": "evaluation_types",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -48,
        -848
      ],
      "id": "4479ff0a-5dd3-4741-af6e-95e7918235db",
      "name": "Insert Document Metadata",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "V0REAPph5JBLqze3",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### EVALUATION GROUP\n- Type: {{ $json.evaluation_type }}\n- Phase: {{ $json.phase }}\n- Total requirements in this group: {{ $json.total_requisitos }}\n\n### RFQ REQUIREMENTS (LIST)\nBelow is a list of RFQ requirements in JSON format. Each element includes the 'id' field and the requirement text.\n\n{{ JSON.stringify($json.requisitos, null, 2) }}\n\n### PROPOSAL CONTEXT\n{{ $json.context_rag }}\n\n\n---\n### TASK\nAnalyze the proposal and evaluate EACH requirement.\n\n### FOR TECHNICAL EVALUATIONS - Use these labels in 'cumple':\n- INCLUDED (10 pts)\n- INCLUDED WITH CAVEATS (8 pts)\n- PARTIALLY INCLUDED (6 pts)\n- NOT INCLUDED WITH ALTERNATIVE (3 pts)\n- NOT INCLUDED (0 pts)\n- NO INFORMATION (0 pts)\n\n### FOR ECONOMICAL EVALUATIONS - EXTRACT THE ACTUAL VALUE:\n**CRITICAL**: For economic items, the 'cumple' field must contain the ACTUAL VALUE found, not a label.\n\nFormat for 'cumple' field:\n- If value found: \"[VALUE] [CURRENCY/UNIT] - [DESCRIPTION]\"\n  Examples:\n  - \"84,3 ‚Ç¨/h - TARIFA (Process, Mechanical, Piping)\"\n  - \"312.640,62 ‚Ç¨ - PRE-FEED TOTAL BASE QUOTATION\"\n  - \"5.231,21 ‚Ç¨ - Geotechnical survey - Confirmed\"\n  - \"732.588,83 ‚Ç¨ - FEED TOTAL BASE QUOTATION\"\n  - \"97.935 ‚Ç¨ - EPC TENDER QUOTATION\"\n\n- If NO value found: \"NO VALUE FOUND - [REASON]\"\n  Examples:\n  - \"NO VALUE FOUND - 3D model not included in proposal\"\n  - \"NO VALUE FOUND - Methodology not specified\"\n  - \"NO VALUE FOUND - OPEX not quoted\"\n  - \"NO VALUE FOUND - No price for this optional\"\n\nScoring for Economic:\n- Value explicitly quoted: 10 pts\n- Hourly/daily rate given: 7 pts\n- Estimated/approximate value: 5 pts\n- Mentioned but no price: 3 pts\n- Not found: 0 pts\n\n### OUTPUT FORMAT (JSON)\n[\n  {\n    \"id\": \"<requirement id>\",\n    \"cumple\": \"[For Technical: label | For Economic: VALUE or NO VALUE FOUND]\",\n    \"gap_analysis\": \"[Quote from document or 'No mention found']\",\n    \"score\": [0-10]\n  }\n]\n\nJSON only, no explanations.",
        "messages": {
          "messageValues": [
            {
              "message": "=You are an expert auditor for EPC proposals.\n\nRULES:\n- For TECHNICAL: Use labels (INCLUDED, PARTIALLY INCLUDED, etc.)\n- For ECONOMICAL: Extract ACTUAL VALUES with currency/units (e.g., '312.640,62 ‚Ç¨ - PRE-FEED TOTAL'). If no value found: 'NO VALUE FOUND - [reason]'\n- Be conservative: when in doubt, score 0\n- ALL responses in ENGLISH\n- JSON only"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2256,
        -1760
      ],
      "id": "092032dc-bdca-4250-9084-442411fe911a",
      "name": "LLM Chain"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear y Preparar Update (SIN quoted_value)\n// =============================================\n\n// 1. Obtener TODOS los items del LLM Chain\nconst allItems = $input.all();\nconsole.log(`üì• Procesando ${allItems.length} respuestas del LLM`);\n\n// 2. Obtener la lista de requisitos V√ÅLIDOS (para validar FK)\nlet validRequirements = [];\ntry {\n  const getRowsData = $('Get many rows1').all();\n  validRequirements = getRowsData.map(item => item.json.id);\n  console.log(`‚úÖ Lista de requisitos v√°lidos: ${validRequirements.length} items`);\n} catch(e) {\n  console.error('‚ùå Error obteniendo lista de requisitos v√°lidos:', e.message);\n  return [];\n}\n\n// 3. Obtener el provider name (una sola vez, es el mismo para todos)\nlet providerName = \"OTROS\";\ntry {\n  providerName = $('Expandir por Tipo de Evaluaci√≥n').first().json.proveedor_detectado || \"OTROS\";\n} catch(e) {\n  console.warn('‚ö†Ô∏è Error obteniendo provider, usando default:', e.message);\n}\n\n// 4. Procesar CADA respuesta del LLM\nconst resultados = [];\n\nfor (let i = 0; i < allItems.length; i++) {\n  try {\n    const item = allItems[i];\n    const itemData = item.json || item;\n\n    let rawText = itemData.text || itemData.output || \"\";\n\n    if (!rawText || typeof rawText !== 'string') {\n      console.warn(`‚ö†Ô∏è Item ${i}: No se encontr√≥ campo 'text' o 'output'`);\n      continue;\n    }\n\n    let cleanText = rawText\n      .replace(/```json/g, '')\n      .replace(/```/g, '')\n      .trim();\n\n    let parsedData = null;\n\n    try {\n      const start = cleanText.indexOf('[');\n      const end = cleanText.lastIndexOf(']');\n\n      if (start >= 0 && end >= 0 && end > start) {\n        const jsonString = cleanText.substring(start, end + 1);\n        parsedData = JSON.parse(jsonString);\n      } else {\n        parsedData = JSON.parse(cleanText);\n      }\n    } catch (parseError) {\n      console.error(`‚ùå Error parseando JSON del item ${i}:`, parseError.message);\n      console.error(`Texto recibido:`, cleanText.substring(0, 200));\n      continue;\n    }\n\n    const outputArray = Array.isArray(parsedData) ? parsedData : [parsedData];\n\n    for (let j = 0; j < outputArray.length; j++) {\n      const outputItem = outputArray[j];\n\n      if (!outputItem || typeof outputItem !== 'object') {\n        console.warn(`‚ö†Ô∏è Item ${i}.${j}: Elemento de salida no es objeto`);\n        continue;\n      }\n\n      const cumple = outputItem?.cumple || \"ERROR ANALISIS\";\n      const gap = outputItem?.gap_analysis || \"Check logs\";\n      const score = outputItem?.score !== undefined ? outputItem.score : 0;\n      const requirementId = outputItem?.id || null;\n\n      const validatedScore = Math.max(0, Math.min(10, parseInt(score) || 0));\n\n      if (!requirementId) {\n        console.error(`‚ùå Item ${i}.${j}: No se encontr√≥ ID del requisito en la respuesta del LLM`);\n        continue;\n      }\n\n      if (!validRequirements.includes(requirementId)) {\n        console.error(`‚ùå Item ${i}.${j}: El requirement_id ${requirementId} NO existe en rfq_items_master. Saltando...`);\n        continue;\n      }\n\n      console.log(`‚úÖ Item ${i}.${j}: Requisito ${requirementId} - ${cumple} (${validatedScore}/10)`);\n\n      resultados.push({\n        json: {\n          requirement_id: requirementId,\n          provider_name: providerName,\n          evaluation_value: cumple,\n          comment: gap,\n          score: validatedScore\n        }\n      });\n    }\n\n  } catch (error) {\n    console.error(`‚ùå Error procesando item ${i}:`, error.message);\n    continue;\n  }\n}\n\nconsole.log(`‚úÖ Procesados ${resultados.length} de ${allItems.length} items exitosamente`);\n\nreturn resultados;"
      },
      "id": "15c54c56-4632-45e4-ad14-fba046f5deec",
      "name": "Parsear y Preparar Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2704,
        -1632
      ]
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.reiniciar_bucle ? true : false }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        752,
        -1616
      ],
      "id": "c4edb3c5-8957-4d60-9b2b-d49e1a8a5e33",
      "name": "Loop Over Phases"
    },
    {
      "parameters": {
        "content": "### Ingesta de Ofertas de Proveedores",
        "height": 1744,
        "width": 4608,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1056,
        -2000
      ],
      "id": "0444c3a9-a9df-4e6e-b3ca-56d0b2b02259",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1,
          "numCtx": 4096,
          "numPredict": 1024
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2416,
        -432
      ],
      "id": "65d22325-8f63-4a5f-8307-a62e6ebfaf9b",
      "name": "Ollama Model",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "model": "qwen3:8b",
        "options": {
          "temperature": 0.1,
          "numCtx": 8192,
          "numPredict": 1536
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2176,
        -1408
      ],
      "id": "115590f7-7cb6-42e1-a7ab-ab34709a7815",
      "name": "Ollama Model1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "267128b5-e2c0-44ae-9973-7f18dffe292e",
              "leftValue": "={{ $('Set File ID').item.json.proveedor }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            },
            {
              "id": "a9d65ff4-430e-45db-8ca8-6078e5ee32fa",
              "leftValue": "={{ $('Set File ID').item.json.evaluation[0] }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            },
            {
              "id": "d5c265e7-00e5-42f4-95ad-4eca1e3ef530",
              "leftValue": "={{ $('Set File ID').item.json.proyect_name }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        2192,
        -848
      ],
      "id": "cff48a5c-e6ee-4f62-a86c-77931d348f8b",
      "name": "If"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### TECHNICAL AND COMMERCIAL CLASSIFICATION (RFQ)\n\n### DOCUMENT SAMPLE (First 2 pages):\n{{ $json.texto_muestra }}\n\n---\n### CLASSIFICATION TASK:\nIdentify project, provider and evaluation types.\n\n**GOLDEN RULE FOR NOMENCLATURE:**\nYou must translate document titles to these exact names:\n- **\"Commercial Proposal\" / \"Oferta Econ√≥mica\"** ‚Üí MUST BE `Economical Evaluation`.\n- **\"Technical Proposal\" / \"Scope of Work\"** ‚Üí MUST BE `Technical Evaluation`.\n- **Document lists** ‚Üí `Pre-FEED Deliverables` or `FEED Deliverables` (depending on context).\n\n#### REQUIREMENTS:\n1. **PROVIDER**: Must be one of: IDOM, SENER, TRESCA, SACYR, TECNICASREUNIDAS, EA, WORLEY.\n2. **TYPES**: The `tipos_detectados` array can only contain the canonical names mentioned above.\n\n---\n### OUTPUT FORMAT (JSON):\n{\n  \"modo_usado\": \"CLASIFICADOR\",\n  \"proyecto_detectado\": \"Name\",\n  \"proveedor_detectado\": \"IDOM | SENER | TRESCA | SACYR | TECNICASREUNIDAS | EA | WORLEY\",\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Economical Evaluation\"],\n  \"razonamiento\": \"Justification: 'Commercial Proposal' detected -> Economical Evaluation mapped.\"\n}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "Identify the provider and evaluation types present in the document based only on the first pages."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        2464,
        -640
      ],
      "id": "e666889f-5538-4bdc-824a-401327fe05ba",
      "name": "Clasificador de Tipo de Evaluacion y Proveedor"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"modo_usado\": {\n      \"type\": \"string\"\n    },\n    \"proyecto_detectado\": {\n      \"type\": \"string\"\n    },\n    \"proyecto_valido\": {\n      \"type\": \"boolean\"\n    },\n    \"proyecto_nota\": {\n      \"type\": \"string\"\n    },\n    \"proveedor_detectado\": {\n      \"type\": \"string\"\n    },\n    \"proveedor_valido\": {\n      \"type\": \"boolean\",\n      \"description\": \"DEBE ser false si el proveedor detectado es distinto al que el usuario seleccion√≥.\"\n    },\n    \"proveedor_nota\": {\n      \"type\": \"string\"\n    },\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"description\": \"Array con los tipos que realmente tienen evidencia en el doc.\"\n    },\n    \"tipos_validados\": {\n      \"type\": \"boolean\",\n      \"description\": \"DEBE ser false si el tipo seleccionado por el usuario no tiene evidencia clara en el PDF.\"\n    },\n    \"tipos_nota\": {\n      \"type\": \"string\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"proyecto_detectado\",\n    \"proyecto_valido\",\n    \"proveedor_detectado\",\n    \"proveedor_valido\",\n    \"tipos_validados\",\n    \"razonamiento\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2656,
        -848
      ],
      "id": "17c5b554-0b77-4be2-9b7d-206e1bfaf358",
      "name": "Structured Output Parser4"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1,
          "numCtx": 4096,
          "numPredict": 1024
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [
        2416,
        -848
      ],
      "id": "ec5dd542-75b8-47d2-8047-00b5d885f6b2",
      "name": "Ollama Chat Model1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### DOCUMENT AUDIT: CROSS-VALIDATION\n\n**[1. USER MANUAL SELECTION]**\n- Project: \"{{ $('Set File ID').item.json.proyect_name }}\"\n- Provider: \"{{ $('Set File ID').item.json.proveedor }}\"\n- Evaluation Type: \"{{ $('Set File ID').item.json.evaluation }}\"\n- File Name: \"{{ $('Set File ID').item.json.file_title }}\"\n\n---\n**[2. ACTUAL PDF EVIDENCE (Extracted text)]**\n{{ $json.texto_muestra }}\n\n---\n### MAPPING AND VALIDATION INSTRUCTIONS:\n\n#### RULE 1: SYNONYMS AND CANONICAL TYPES\nYou can only use these 4 exact names. Map the evidence as follows:\n- **\"Commercial Proposal\" / \"Oferta Econ√≥mica\" / \"Price Schedule\"** ‚Üí MUST BE `Economical Evaluation`.\n- **\"Technical Proposal\" / \"Scope of Work\" / \"Metodolog√≠a\"** ‚Üí MUST BE `Technical Evaluation`.\n- **\"Technical & Economical Proposal\"** ‚Üí MUST INCLUDE BOTH: `Technical Evaluation` AND `Economical Evaluation`.\n- **Drawing lists** ‚Üí `Pre-FEED Deliverables` or `FEED Deliverables`.\n\n#### RULE 2: TITLE AND FILE NAME ARE DECISIVE\n- Analyze the **File Name** and **Title** of the document. If they say \"Oferta T√©cnica\" or \"Technical Proposal\", the type is `Technical Evaluation`.\n- **IMPORTANT:** DO NOT add other types for minor mentions. Example: If a technical document mentions \"estimated prices\", DO NOT add `Economical Evaluation`. Only add it if you see a complete PRICE TABLE.\n- Be conservative: when in doubt, follow the File Name.\n\n#### RULE 3: INTENTION BALANCING\n- If the PDF is mixed but the user has selected one of the valid types present, mark `tipos_validados: true`.\n\n### OUTPUT FORMAT (SINGLE JSON):\n{\n  \"modo_usado\": \"VALIDADOR\",\n  \"proyecto_detectado\": \"Actual Name\",\n  \"proyecto_valido\": true | false,\n  \"proyecto_nota\": \"Summary\",\n  \"proveedor_detectado\": \"IDOM | SENER | TRESCA | SACYR | TECNICASREUNIDAS | EA | WORLEY\",\n  \"proveedor_valido\": true | false,\n  \"proveedor_nota\": \"Explanation\",\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Economical Evaluation\", \"Pre-FEED Deliverables\", \"FEED Deliverables\"],\n  \"tipos_validados\": true | false,\n  \"tipos_nota\": \"Explain why you validated or rejected the types.\",\n  \"razonamiento\": \"Mention the File Name and Title found.\"\n}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=Act as a strict validator. If there are flagrant discrepancies between the user's suggestion and the actual PDF content, prioritize the PDF content and mark validation as false and report the correct provider/type.\n\nSupported providers: Tecnicas Reunidas, IDOM, SACYR, Empresarios Agrupados, SENER, TRESCA, WORLEY"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        2464,
        -1040
      ],
      "id": "37b02da2-fd94-4747-8cc4-1214189b6de8",
      "name": "Validador de Ofertas"
    },
    {
      "parameters": {
        "model": "qwen3-embedding:8b"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        2960,
        -608
      ],
      "id": "24f58e36-97af-49a6-9ee0-2be2695d1d85",
      "name": "Embeddings Ollama3",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "tableId": "provider_responses",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "provider_name",
              "fieldValue": "={{ $json.provider_name }}"
            },
            {
              "fieldId": "evaluation_value",
              "fieldValue": "={{ $json.evaluation_value }}"
            },
            {
              "fieldId": "comment",
              "fieldValue": "={{ $json.comment }}"
            },
            {
              "fieldId": "score",
              "fieldValue": "={{ $json.score }}"
            },
            {
              "fieldId": "requirement_id",
              "fieldValue": "={{ $json.requirement_id }}"
            },
            {
              "fieldId": "updated_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "file_id",
              "fieldValue": "={{ $('Set File ID').first().json.file_id }}"
            },
            {
              "fieldId": "quoted_value",
              "fieldValue": "={{ $json.quoted_value }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2992,
        -1392
      ],
      "id": "3db41733-e50c-42dd-9ad3-d3b1d01e9e69",
      "name": "Upsert Provider Response",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "rfq_items_master",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "evaluation_type",
              "condition": "eq",
              "keyValue": "={{ $json.tipo_evaluacion_actual }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -80,
        -1680
      ],
      "id": "5e0e1925-ec50-4ae6-a1ff-16158d233bad",
      "name": "Get many rows1",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "model": "mistral-large-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        2080,
        -1552
      ],
      "id": "99bd000d-b3ee-4dd6-bfea-8f9d0195e698",
      "name": "Mistral Cloud Chat Model",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.embeddingsCohere",
      "typeVersion": 1,
      "position": [
        3072,
        -656
      ],
      "id": "ec599407-8cc2-4185-866d-4fff1299e42b",
      "name": "Embeddings Cohere",
      "credentials": {
        "cohereApi": {
          "id": "KGv4zlUJIjLdxpnr",
          "name": "CohereApi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Grupo de Requisitos por Phase\n// Recibe datos ya agrupados del nodo 'Agrupar por Phase'\n// =============================================\n\n// 1. Obtener el grupo actual (ya viene agrupado por phase)\nconst grupoActual = $input.first().json;\n\nconst phase = grupoActual.phase || \"Sin Phase\";\nconst requisitosDelGrupo = grupoActual.requisitos || [];\nconst textoOfertaCompleto = grupoActual.texto_oferta_completo || \"\";\nconst esOfertaLarga = grupoActual.es_oferta_larga || false;\nconst evaluationType = grupoActual.evaluation_type || \"Technical Evaluation\";\n\nconsole.log(`üìã Procesando grupo: ${evaluationType} - ${phase}`);\nconsole.log(`   ‚îú‚îÄ Requisitos en este grupo: ${requisitosDelGrupo.length}`);\nconsole.log(`   ‚îú‚îÄ Tama√±o texto oferta: ${textoOfertaCompleto.length} chars`);\nconsole.log(`   ‚îî‚îÄ Modo: ${esOfertaLarga ? 'RAG' : 'DIRECTO'}`);\n\n// 2. Preparar contexto seg√∫n tama√±o de oferta\nlet contextoParaLLM = \"\";\n\nif (esOfertaLarga) {\n    // MODO RAG: Usaremos el vectorstore (se configura despu√©s)\n    // Por ahora pasamos una muestra y marcamos para RAG\n    contextoParaLLM = textoOfertaCompleto.substring(0, 8000);\n    console.log(`üîç Modo RAG: Contexto limitado a 8000 chars (se complementar√° con retrieval)`);\n} else {\n    // MODO DIRECTO: Pasamos todo el texto\n    contextoParaLLM = textoOfertaCompleto;\n    console.log(`üìÑ Modo DIRECTO: Pasando texto completo`);\n}\n\n// 3. Formatear requisitos para el LLM\nconst requisitosFormateados = requisitosDelGrupo.map(req => ({\n    id: req.id || \"\",\n    requirement_text: req.requirement_text || req.text || \"NO ESPECIFICADO\",\n    phase: req.phase || phase,\n    evaluation_type: req.evaluation_type || evaluationType\n}));\n\n// 4. Retornar datos preparados para el LLM\nreturn [{\n    json: {\n        // Datos del grupo\n        phase: phase,\n        evaluation_type: evaluationType,\n        \n        // Requisitos del grupo\n        requisitos: requisitosFormateados,\n        total_requisitos: requisitosFormateados.length,\n        \n        // Contexto de la oferta\n        context: contextoParaLLM,\n        texto_length: contextoParaLLM.length,\n        \n        // Flags para el flujo\n        es_oferta_larga: esOfertaLarga,\n        usar_rag: esOfertaLarga\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -1600
      ],
      "id": "eafd8daf-fb74-4d88-8402-b44cfa38c002",
      "name": "Preparar Grupo Phase"
    },
    {
      "parameters": {
        "mode": "load",
        "tableName": {
          "__rl": true,
          "value": "proposals",
          "mode": "list",
          "cachedResultName": "proposals"
        },
        "prompt": "={{ $json.requisitos.map(r => r.requirement_text).join(' | ') }}",
        "topK": 20,
        "options": {
          "queryName": "match_proposals",
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $('Set File ID').first().json.file_id }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1.3,
      "position": [
        1616,
        -1760
      ],
      "id": "3f779749-e442-41ee-b7cd-dcbed64f69de",
      "name": "RAG Query Vectorstore",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "model": "qwen3-embedding:8b"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        1680,
        -1552
      ],
      "id": "0c81f752-c317-41cc-ae2c-82373a37a482",
      "name": "Embeddings Ollama RAG",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Contexto RAG (CORREGIDO v3)\n// Output: context_rag para el LLM\n// =============================================\n\nconst items = $input.all();\n\n// Obtener datos del grupo desde el nodo anterior\nlet grupoData;\ntry {\n    grupoData = $('Preparar Grupo Phase').first().json;\n} catch(e) {\n    console.error('‚ùå Error obteniendo datos del grupo:', e.message);\n    grupoData = {};\n}\n\n// Construir contexto desde los chunks RAG\nlet contextRag = \"\";\nlet chunksUsados = 0;\n\nitems.forEach((item, idx) => {\n    const chunk = item.json;\n    \n    // Extraer datos seg√∫n estructura de Supabase\n    let text = \"\";\n    let score = 0;\n    let lineas = {};\n    \n    if (chunk.document && chunk.document.pageContent) {\n        text = chunk.document.pageContent;\n        score = chunk.score || 0;\n        lineas = chunk.document.metadata?.loc?.lines || {};\n    } else if (chunk.pageContent) {\n        text = chunk.pageContent;\n        score = chunk.score || 0;\n        lineas = chunk.metadata?.loc?.lines || {};\n    }\n    \n    if (text && text.trim().length > 50) {\n        chunksUsados++;\n        const scorePercent = (score * 100).toFixed(2);\n        \n        contextRag += `\\n=== FRAGMENTO ${chunksUsados} (Relevancia: ${scorePercent}%, L√≠neas: ${lineas.from || '?'}-${lineas.to || '?'}) ===\\n`;\n        contextRag += text.trim();\n        contextRag += `\\n`;\n    }\n});\n\n// Fallback si no hay chunks\nif (chunksUsados === 0) {\n    contextRag = \"NO SE ENCONTR√ì INFORMACI√ìN RELEVANTE EN LA OFERTA PARA ESTOS REQUISITOS.\";\n}\n\nconsole.log('üîç RAG Preparado:');\nconsole.log('   ‚îú‚îÄ Chunks recibidos: ' + items.length);\nconsole.log('   ‚îú‚îÄ Chunks usados: ' + chunksUsados);\nconsole.log('   ‚îú‚îÄ Tama√±o context_rag: ' + contextRag.length + ' chars');\nconsole.log('   ‚îî‚îÄ Phase: ' + (grupoData.phase || 'N/A'));\n\nreturn [{\n    json: {\n        phase: grupoData.phase || \"Sin Phase\",\n        evaluation_type: grupoData.evaluation_type || \"Technical Evaluation\",\n        requisitos: grupoData.requisitos || [],\n        total_requisitos: grupoData.total_requisitos || 0,\n        context_rag: contextRag,\n        rag_chunks_recibidos: items.length,\n        rag_chunks_usados: chunksUsados,\n        texto_length: contextRag.length\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1936,
        -1760
      ],
      "id": "f97a40b3-d36d-4afa-aa78-aab35f6d8dce",
      "name": "Preparar Contexto RAG"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2304,
        -1552
      ],
      "id": "3ade29b4-75f2-4ab0-b06d-4b417f30b420",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "4AyUqsh1Z35g6bci",
          "name": "OpenRouter account"
        }
      }
    }
  ],
  "connections": {
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Set File ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary1": {
      "main": [
        [
          {
            "node": "Docling OCR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agrupar por Phase": {
      "main": [
        [
          {
            "node": "Reset Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Items": {
      "main": [
        [
          {
            "node": "Loop Over Phases",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Preparar Texto de Muestra",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Clasificador de Tipo de Evaluacion y Proveedor",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Docling OCR": {
      "main": [
        [
          {
            "node": "Aggregate OCR Pages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items1": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get many rows1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expandir por Tipo de Evaluaci√≥n": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Vectorstore": {
      "main": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Texto de Muestra": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate OCR Pages": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "¬øNecesita OCR?": {
      "main": [
        [
          {
            "node": "Base64 a Binary1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Validar Contenido PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Contenido PDF": {
      "main": [
        [
          {
            "node": "¬øNecesita OCR?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert into Supabase Vectorstore": {
      "main": [
        [
          {
            "node": "Expandir por Tipo de Evaluaci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Set File ID": {
      "main": [
        [
          {
            "node": "Delete Old Doc Rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Doc Rows": {
      "main": [
        [
          {
            "node": "Insert Document Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Document Metadata": {
      "main": [
        [
          {
            "node": "Base64 a Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Chain": {
      "main": [
        [
          {
            "node": "Parsear y Preparar Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear y Preparar Update": {
      "main": [
        [
          {
            "node": "Upsert Provider Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Phases": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Preparar Grupo Phase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Model": {
      "ai_languageModel": [
        [
          {
            "node": "Clasificador de Tipo de Evaluacion y Proveedor",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Model1": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clasificador de Tipo de Evaluacion y Proveedor": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser4": {
      "ai_outputParser": [
        [
          {
            "node": "Validador de Ofertas",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Validador de Ofertas",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validador de Ofertas": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Ollama3": {
      "ai_embedding": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Upsert Provider Response": {
      "main": [
        [
          {
            "node": "Loop Over Phases",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many rows1": {
      "main": [
        [
          {
            "node": "Agrupar por Phase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral Cloud Chat Model": {
      "ai_languageModel": [
        []
      ]
    },
    "Embeddings Cohere": {
      "ai_embedding": [
        []
      ]
    },
    "Preparar Grupo Phase": {
      "main": [
        [
          {
            "node": "RAG Query Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Query Vectorstore": {
      "main": [
        [
          {
            "node": "Preparar Contexto RAG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Ollama RAG": {
      "ai_embedding": [
        [
          {
            "node": "RAG Query Vectorstore",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Contexto RAG": {
      "main": [
        [
          {
            "node": "LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        []
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "53140335eaf11280ef77ef2f5a378f48c2b28e822e3e0d96563cdd92175c0eff"
  }
}