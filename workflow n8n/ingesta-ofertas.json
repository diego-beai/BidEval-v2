{
  "nodes": [
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Generate Stable ID + Detectar Modo (NOMBRES CORRECTOS)\n// =============================================\n\nfunction simpleHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(16, '0').substring(0, 16);\n}\n\nconst body = $json.body;\n\n// CAMPOS EXISTENTES\nconst originalFileId = body.file_id || \"unknown\";\nconst fileTitle = body.file_title || \"unknown.pdf\";\nconst fileBinary = body.file_binary || \"\";\nconst fileUrl = body.file_url || \"unknown\";\n\n// ‚úÖ EXTRAER METADATA DEL USUARIO (NOMBRES CORRECTOS)\nconst metadata = body.metadata || {};\nconst rfqProjectId = metadata.proyect_name || null;        // ‚Üê proyect_name\nconst userProveedor = metadata.proveedor || null;          // ‚Üê proveedor\nconst userTipoEval = metadata.evaluation || null;          // ‚Üê evaluation (Array)\n\n// ‚úÖ DETERMINAR MODO DE OPERACI√ìN\nlet modoOperacion = \"CLASIFICADOR\"; // Por defecto\nlet datosCompletos = false;\n\n// Verificar si tiene datos suficientes para VALIDACI√ìN\nif (userProveedor && userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0) {\n    modoOperacion = \"VALIDADOR\";\n    datosCompletos = true;\n} else if (userProveedor || (userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0)) {\n    modoOperacion = \"HIBRIDO\"; // Tiene algunos datos pero no todos\n}\n\n// Generar ID estable del archivo\nconst normalizedTitle = fileTitle.toLowerCase().trim();\nconst stableId = simpleHash(normalizedTitle);\n\n// LOGGING\nconsole.log(\"=== AN√ÅLISIS DE METADATA ===\");\nconsole.log(`Modo Operaci√≥n: ${modoOperacion}`);\nconsole.log(`RFQ Project Name: ${rfqProjectId || 'No especificado'}`);\nconsole.log(`Proveedor (Usuario): ${userProveedor || 'No especificado'}`);\nconsole.log(`Evaluation (Usuario): ${JSON.stringify(userTipoEval) || 'No especificado'}`);\nconsole.log(`Datos Completos: ${datosCompletos}`);\nconsole.log(`Original ID: ${originalFileId}`);\nconsole.log(`Nombre archivo: ${fileTitle}`);\nconsole.log(`ID ESTABLE generado: ${stableId}`);\n\n// RETORNO\nreturn {\n  json: {\n    // Datos directos en ra√≠z\n    file_id: stableId,\n    file_id_original: originalFileId,\n    file_title: fileTitle,\n    file_binary: fileBinary,\n    file_url: fileUrl,\n    \n    rfq_project_id: rfqProjectId || \"proyecto_sin_especificar\",\n    user_proveedor: userProveedor,\n    user_tipo_evaluacion: userTipoEval,\n    modo_operacion: modoOperacion,\n    datos_usuario_completos: datosCompletos,\n    \n    // Mantener body completo\n    body: {\n      ...body,\n      file_id: stableId,\n      file_id_original: originalFileId,\n      rfq_project_id: rfqProjectId || \"proyecto_sin_especificar\",\n      user_proveedor: userProveedor,\n      user_tipo_evaluacion: userTipoEval,\n      modo_operacion: modoOperacion,\n      datos_usuario_completos: datosCompletos\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -656,
        -928
      ],
      "id": "b632c6db-3243-4455-aec8-a49811ef138a",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Convertir Base64 a Binary Data (CORREGIDO v3)\n// =============================================\n\n// LEER DIRECTAMENTE DEL NODO \"Set File ID\"\nlet inputData;\ntry {\n    inputData = $('Set File ID').first().json;\n} catch (e) {\n    throw new Error(\"‚ùå No se puede acceder al nodo 'Set File ID'\");\n}\n\nconst base64Data = inputData.file_binary;\n\n// --- VALIDACI√ìN CR√çTICA ---\nif (!base64Data || base64Data === \"\") {\n    console.error(\"‚ùå ERROR: file_binary est√° vac√≠o\");\n    console.error(\"Datos en 'Set File ID':\", Object.keys(inputData));\n    console.error(\"file_id:\", inputData.file_id);\n    console.error(\"file_title:\", inputData.file_title);\n    \n    throw new Error(\n        \"‚ùå CR√çTICO: 'file_binary' no existe en 'Set File ID'. \" +\n        \"Verifica la configuraci√≥n del nodo.\"\n    );\n}\n\n// Validar que sea string\nif (typeof base64Data !== 'string') {\n    throw new Error(`‚ùå ERROR: 'file_binary' debe ser string, es ${typeof base64Data}`);\n}\n\n// Logging\nconsole.log(\"‚úÖ file_binary recibido de 'Set File ID'\");\nconsole.log(`   ‚îú‚îÄ Longitud: ${base64Data.length} caracteres`);\nconsole.log(`   ‚îú‚îÄ Archivo: ${inputData.file_title}`);\n\n// Convertir base64 a binary\nlet binaryData;\ntry {\n    binaryData = Buffer.from(base64Data, 'base64');\n} catch (e) {\n    throw new Error(`‚ùå ERROR decodificando base64: ${e.message}`);\n}\n\n// Validar tama√±o\nif (binaryData.length === 0) {\n    throw new Error(\"‚ùå ERROR: Archivo decodificado vac√≠o (0 bytes)\");\n}\n\nconsole.log(`‚úÖ Binary generado: ${binaryData.length} bytes`);\n\n// Retornar formato n8n\nreturn {\n    json: {\n        file_id: inputData.file_id,\n        file_title: inputData.file_title,\n        file_url: inputData.file_url || \"unknown\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'document.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        -1040
      ],
      "id": "d5528b93-1d55-4059-bb67-67cf73740932",
      "name": "Base64 a Binary1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Convertir Base64 a Binary Data (CORREGIDO v3)\n// =============================================\n\n// LEER DIRECTAMENTE DEL NODO \"Set File ID\"\nlet inputData;\ntry {\n    inputData = $('Set File ID').first().json;\n} catch (e) {\n    throw new Error(\"‚ùå No se puede acceder al nodo 'Set File ID'\");\n}\n\nconst base64Data = inputData.file_binary;\n\n// --- VALIDACI√ìN CR√çTICA ---\nif (!base64Data || base64Data === \"\") {\n    console.error(\"‚ùå ERROR: file_binary est√° vac√≠o\");\n    console.error(\"Datos en 'Set File ID':\", Object.keys(inputData));\n    console.error(\"file_id:\", inputData.file_id);\n    console.error(\"file_title:\", inputData.file_title);\n    \n    throw new Error(\n        \"‚ùå CR√çTICO: 'file_binary' no existe en 'Set File ID'. \" +\n        \"Verifica la configuraci√≥n del nodo.\"\n    );\n}\n\n// Validar que sea string\nif (typeof base64Data !== 'string') {\n    throw new Error(`‚ùå ERROR: 'file_binary' debe ser string, es ${typeof base64Data}`);\n}\n\n// Logging\nconsole.log(\"‚úÖ file_binary recibido de 'Set File ID'\");\nconsole.log(`   ‚îú‚îÄ Longitud: ${base64Data.length} caracteres`);\nconsole.log(`   ‚îú‚îÄ Archivo: ${inputData.file_title}`);\n\n// Convertir base64 a binary\nlet binaryData;\ntry {\n    binaryData = Buffer.from(base64Data, 'base64');\n} catch (e) {\n    throw new Error(`‚ùå ERROR decodificando base64: ${e.message}`);\n}\n\n// Validar tama√±o\nif (binaryData.length === 0) {\n    throw new Error(\"‚ùå ERROR: Archivo decodificado vac√≠o (0 bytes)\");\n}\n\nconsole.log(`‚úÖ Binary generado: ${binaryData.length} bytes`);\n\n// Retornar formato n8n\nreturn {\n    json: {\n        file_id: inputData.file_id,\n        file_title: inputData.file_title,\n        file_url: inputData.file_url || \"unknown\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'document.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        -928
      ],
      "id": "748a771f-a0fd-4d25-a523-79dc33764fc2",
      "name": "Base64 a Binary"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ofertas-proveedores",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -896,
        -928
      ],
      "id": "e3a38809-7fb1-409c-a3de-a223143018c4",
      "name": "Webhook",
      "webhookId": "a002f7af-bec0-47d3-99c2-9c7d1f508f2c"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        -64,
        -1968
      ],
      "id": "c4a6c16a-2e49-4ee7-91f2-cffcd910f74e",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Agrupar Requisitos por Phase\n// =============================================\n\nconst items = $input.all();\n\n// Agrupar requisitos por phase\nconst grupos = {};\nitems.forEach(item => {\n    const phase = item.json.phase || \"Sin Phase\";\n    if (!grupos[phase]) {\n        grupos[phase] = [];\n    }\n    grupos[phase].push(item.json);\n});\n\n// Obtener informaci√≥n del contexto (texto de oferta y tama√±o)\nlet textoOfertaCompleto = \"\";\nlet totalChars = 0;\nlet esOfertaLarga = false;\n\ntry {\n    const loopData = $('Loop Over Items1').first().json;\n    textoOfertaCompleto = loopData.texto_oferta_completo || \"\";\n    totalChars = textoOfertaCompleto.length;\n    // SIEMPRE usar RAG - el documento completo est√° indexado en Supabase\n    // Esto garantiza que el LLM tenga acceso a todo el contenido relevante\n    esOfertaLarga = true;\n} catch(e) {\n    console.warn('‚ö†Ô∏è No se pudo obtener texto de oferta:', e.message);\n}\n\nconsole.log(`üìä Agrupaci√≥n por Phase:`);\nconsole.log(`   ‚îú‚îÄ Total requisitos: ${items.length}`);\nconsole.log(`   ‚îú‚îÄ Grupos (phases): ${Object.keys(grupos).length}`);\nconsole.log(`   ‚îú‚îÄ Tama√±o oferta: ${totalChars} chars`);\nconsole.log(`   ‚îî‚îÄ Modo: ${esOfertaLarga ? 'RAG (oferta larga)' : 'DIRECTO (oferta corta)'}`);\n\n// Retornar un item por cada grupo de phase\nreturn Object.entries(grupos).map(([phase, requisitos]) => ({\n    json: {\n        phase: phase,\n        requisitos: requisitos,\n        total_requisitos: requisitos.length,\n        texto_oferta_completo: textoOfertaCompleto,\n        total_chars: totalChars,\n        es_oferta_larga: esOfertaLarga,\n        evaluation_type: requisitos[0]?.evaluation_type || \"Technical Evaluation\"\n    }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        -1760
      ],
      "id": "f8a2b3c4-d5e6-4f7a-8b9c-0d1e2f3a4b5c",
      "name": "Agrupar por Phase"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => ({\n    json: {\n        ...item.json, // Mantiene todos los datos originales (incluido tipo_evaluacion)\n        \n        // Aqu√≠ est√° la correcci√≥n: Usamos dos puntos, no el igual.\n        reiniciar_bucle: true \n    }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        496,
        -1760
      ],
      "id": "54dea7d2-d47a-47dd-9a37-bc804d07a622",
      "name": "Reset Items"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1792,
        -928
      ],
      "id": "76ee22dd-4342-43a8-a2c3-147024f29e5b",
      "name": "Merge1"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"proveedor_detectado\": {\n      \"type\": \"string\",\n      \"description\": \"Nombre de la empresa proveedora (Ej: SACYR, IDOM, etc.)\"\n    },\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"Technical Evaluation\",\n          \"Economical Evaluation\",\n          \"Pre-FEED Deliverables\",\n          \"FEED Deliverables\"\n        ]\n      },\n      \"description\": \"Lista de tipos de oferta detectados en el documento.\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\",\n      \"description\": \"Breve explicaci√≥n de por qu√© se eligieron esos tipos.\"\n    }\n  },\n  \"required\": [\n    \"proveedor_detectado\",\n    \"tipos_detectados\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2640,
        -512
      ],
      "id": "4266acc2-99ac-427f-beb0-d171ffb28674",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://unlaconic-ardelle-pretenceful.ngrok-free.dev/v1/convert/file",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "files",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {
          "timeout": 300000
        }
      },
      "id": "7d82950a-6505-4b2d-b798-0ac7a7620300",
      "name": "Docling OCR",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1328,
        -1136
      ],
      "retryOnFail": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -512,
        -1712
      ],
      "id": "eae51a02-0da8-43d5-9a25-6f9e5ab4aa89",
      "name": "Loop Over Items1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Expandir por Tipo de Evaluaci√≥n (v2 - Valida Metadatos)\n// =============================================\n\n// 1. RECUPERAR TEXTO Y CONTENIDO BASE\nlet fullText = \"\";\nlet totalPages = 1;\ntry {\n    const mergeData = $('Merge1').first().json;\n    fullText = (mergeData.pages && mergeData.pages[0]) \n        ? mergeData.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\") \n        : (mergeData.text || \"\");\n    totalPages = mergeData.totalPages || 1;\n} catch (e) {\n    console.error(\"‚ùå Error leyendo Merge1\");\n}\n\n// 2. RECUPERAR DATOS VALIDADOS PRIORITARIAMENTE\nlet proveedor = \"OTROS\";\nlet tipoEval = [\"Technical Evaluation\"];\nlet projectName = \"proyecto_sin_especificar\";\n\ntry {\n    let llmNode = null;\n    try { llmNode = $('Validador de Ofertas').first().json; } catch(e) {}\n    if (!llmNode) { try { llmNode = $('Clasificador de Tipo de Evaluacion y Proveedor').first().json; } catch(e) {} }\n\n    if (llmNode) {\n        const data = llmNode.output || llmNode;\n        proveedor = data.proveedor_detectado || proveedor;\n        tipoEval = data.tipos_detectados || tipoEval;\n        // El proyecto tambi√©n puede venir del validador si se detect√≥\n        if (data.proyecto_detectado) projectName = data.proyecto_detectado;\n    }\n} catch (e) {\n    console.log(\"‚ö†Ô∏è Fall√≥ lectura de LLM, intentando fallbacks...\");\n}\n\n// 3. FALLBACK A SET FILE ID (Si el LLM no dio datos)\nlet fileId = \"unknown\";\ntry {\n    const fileData = $('Set File ID').first().json;\n    fileId = fileData.file_id || \"unknown\";\n    if (proveedor === \"OTROS\") proveedor = fileData.proveedor || \"OTROS\";\n    if (projectName === \"proyecto_sin_especificar\") projectName = fileData.proyect_name || \"proyecto_sin_especificar\";\n} catch (e) {}\n\n// 4. NORMALIZAR TIPOS\nif (!Array.isArray(tipoEval)) tipoEval = [tipoEval];\ntipoEval = tipoEval.filter(t => t && t.trim() !== \"\");\nif (tipoEval.length === 0) tipoEval = [\"Technical Evaluation\"];\n\n// 5. GENERAR FILAS\nreturn tipoEval.map((tipo, idx) => ({\n    json: {\n        tipo_evaluacion_actual: tipo,\n        proveedor_detectado: proveedor,\n        proyecto_nombre: projectName,\n        texto_oferta_completo: fullText,\n        indice_actual: idx + 1,\n        total_tipos: tipoEval.length,\n        file_id: fileId\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -816,
        -1632
      ],
      "id": "c8794556-7fb1-47b4-9c6a-e71cb4c81b0a",
      "name": "Expandir por Tipo de Evaluaci√≥n"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Format for Vectorstore (FINAL v2)\n// =============================================\n\n// 1. RECUPERAR CONTENIDO (Instrucci√≥n expl√≠cita)\nlet fullText = \"\";\nlet totalPages = 1;\n\ntry {\n    const mergeData = $('Merge1').first().json;\n    if (mergeData.pages && mergeData.pages[0]) {\n        fullText = mergeData.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\");\n    } else {\n        fullText = mergeData.text || \"\";\n    }\n    totalPages = mergeData.totalPages || 1;\n} catch (e) {\n    console.log(\"‚ùå Error leyendo de Merge1\");\n}\n\n// 2. RECUPERAR CLASIFICACI√ìN O VALIDACI√ìN\nlet proveedor = \"OTROS\";\nlet tipoEval = [\"Technical Evaluation\"];\nlet proyecto = \"\";\n\ntry {\n    // Intentamos leer del validador primero, si no, del clasificador\n    let llmData;\n    try {\n        llmData = $('Validador de Ofertas').first().json;\n    } catch (e) {\n        llmData = $('Clasificador de Tipo de Evaluacion y Proveedor').first().json;\n    }\n\n    const output = llmData.output || llmData;\n\n    if (output.proveedor_detectado) proveedor = output.proveedor_detectado;\n    if (output.proyecto_detectado) proyecto = output.proyecto_detectado;\n    \n    if (output.tipos_detectados) {\n        tipoEval = Array.isArray(output.tipos_detectados) \n            ? output.tipos_detectados \n            : [output.tipos_detectados];\n    }\n} catch (e) {\n    console.log(\"‚ö†Ô∏è Error leyendo clasificaci√≥n/validaci√≥n LLM, usando defaults.\");\n}\n\n// 3. RECUPERAR METADATOS DEL ARCHIVO Y FALLBACKS\nlet fileId = \"unknown\";\nlet fileTitle = \"unknown\";\ntry {\n    const fileNode = $('Set File ID').first().json;\n    fileId = fileNode.file_id;\n    fileTitle = fileNode.file_title;\n    if (!proyecto) proyecto = fileNode.proyect_name;\n} catch(e) {}\n\n// 4. GENERAR SALIDA\nreturn {\n    json: {\n        text: fullText,\n        metadata: {\n            file_id: fileId,\n            file_title: fileTitle,\n            proveedor: proveedor,\n            tipo_evaluacion: tipoEval,\n            project_name: proyecto,\n            processed_at: new Date().toISOString(),\n            total_pages: totalPages\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2848,
        -944
      ],
      "id": "1312d640-de2d-4131-9de4-749adb72622e",
      "name": "Format for Vectorstore"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Texto de Muestra (STRICT LIMIT)\n// =============================================\n\nconst items = $input.all();\n\nreturn items.map(item => {\n    let texto_muestra = \"SIN TEXTO\";\n\n    try {\n        if (item.json.pages && Array.isArray(item.json.pages) && item.json.pages.length > 0) {\n            // Unimos las 2 primeras p√°ginas pero limitamos el total a 3000 caracteres\n            let rawJoin = item.json.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\");\n            texto_muestra = rawJoin.substring(0, 3000);\n        } else {\n            // Fallback extremadamente corto para texto plano\n            texto_muestra = (item.json.text || \"\").substring(0, 500);\n        }\n    } catch (e) {\n        console.error(\"Error al procesar p√°ginas:\", e);\n    }\n\n    return {\n        json: {\n            ...item.json,\n            texto_muestra: texto_muestra\n        }\n    };\n});"
      },
      "id": "32b1f6f2-1b98-4432-a57e-0775197232c5",
      "name": "Preparar Texto de Muestra",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1984,
        -928
      ]
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Aggregate OCR Pages (CORREGIDO)\n// =============================================\n\nconst items = $input.all();\nlet fullText = \"\";\nlet pagesArray = [];\n\n// OPCI√ìN A: Si Tesseract devuelve m√∫ltiples items (1 por p√°gina)\nif (items.length > 1) {\n  items.forEach((item, idx) => {\n    const pageText = item.json.text || \"\";\n    fullText += pageText + \"\\n\\n\";\n    \n    // Construimos array compatible con vectorstore\n    pagesArray.push({\n      text: pageText,\n      pageNumber: idx + 1\n    });\n  });\n}\n// OPCI√ìN B: Si Tesseract devuelve un solo item con todo el texto\nelse if (items.length === 1) {\n  fullText = items[0].json.text || \"\";\n  pagesArray = [{\n    text: fullText,\n    pageNumber: 1\n  }];\n}\n\n// RECUPERAR METADATOS ORIGINALES (CR√çTICO)\nlet fileId, fileName, proveedor;\ntry {\n  fileId = $('Set File ID').first().json.file_id;\n  fileName = $('Set File ID').first().json.file_title;\n  proveedor = $('Set File ID').first().json.proveedor || \"OTROS\";\n} catch (e) {\n  console.error(\"‚ö†Ô∏è No se pudieron recuperar metadatos:\", e.message);\n  fileId = \"unknown\";\n  fileName = \"unknown\";\n  proveedor = \"OTROS\";\n}\n\nconsole.log(`üîÑ OCR Agregado: ${items.length} p√°ginas ‚Üí ${fullText.length} caracteres`);\n\n// ESTRUCTURA COMPATIBLE CON VECTORSTORE\nreturn {\n  json: {\n    pages: pagesArray, // ‚Üê Array de p√°ginas (requerido por Default Data Loader)\n    text: fullText, // ‚Üê Texto completo (backup)\n    \n    // Metadatos cr√≠ticos\n    file_id: fileId,\n    file_title: fileName,\n    proveedor: proveedor,\n    \n    // Marca de origen\n    origen_datos: \"OCR_TESSERACT\",\n    ocr_pages_processed: items.length,\n    ocr_total_chars: fullText.length\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1536,
        -1040
      ],
      "id": "e62b1043-7796-473c-9721-50d625910846",
      "name": "Aggregate OCR Pages"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "57b9c551-9997-4ed5-8ddd-f80c108a177c",
              "leftValue": "={{ $json.needsOCR }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        896,
        -928
      ],
      "id": "6e651182-d478-4c0a-80ae-19706525422f",
      "name": "¬øNecesita OCR?"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        336,
        -928
      ],
      "id": "ee86f839-9ca3-41be-85f1-4bef40990cb5",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Validar Contenido PDF (FIX PAGINACI√ìN)\n// =============================================\n\nconst input = $input.first().json;\n\n// Variables de inicializaci√≥n\nlet pages = [];\nlet totalChars = 0;\nlet hasTablesDetected = false;\n\n// --- 1. PROCESAMIENTO DEL TEXTO ---\n\n// CASO A: Viene desglosado por p√°ginas (Array)\nif (input.pages && Array.isArray(input.pages) && input.pages.length > 0) {\n  pages = input.pages;\n  pages.forEach(page => {\n    const text = page.text || page.pageContent || \"\";\n    totalChars += text.length;\n    // Detecci√≥n simple de tablas\n    if ((text.match(/\\s{4,}/g) || []).length > 5) hasTablesDetected = true;\n  });\n\n// CASO B: Viene todo el texto junto (String) - ESTE ES TU CASO ACTUAL\n} else if (input.text && typeof input.text === 'string') {\n  const text = input.text;\n  totalChars = text.length;\n  // Creamos una \"p√°gina √∫nica\" contenedora para no romper el flujo\n  pages = [{ text: text, pageNumber: 1 }];\n  \n  // Detectar tablas en el texto completo\n  if ((text.match(/\\s{4,}/g) || []).length > 20) hasTablesDetected = true;\n  \n} else {\n  // CASO C: Vac√≠o\n  pages = [];\n}\n\n// --- 2. C√ÅLCULO DE P√ÅGINAS REALES (FIX CR√çTICO) ---\n\n// Intentamos leer el metadato 'numpages' que se ve en tu captura\nlet realPageCount = input.numpages || input.numPages || input.numberOfPages || 0;\n\n// Si no existe el metadato, usamos la longitud del array (fallback)\nif (!realPageCount || realPageCount === 0) {\n    realPageCount = pages.length;\n}\n\n// Si sigue siendo 1 pero el texto es enorme (>10k chars), estimamos\nif (realPageCount <= 1 && totalChars > 10000) {\n    // Estimaci√≥n conservadora: 3000 caracteres por p√°gina t√©cnica\n    realPageCount = Math.ceil(totalChars / 3000);\n}\n\n// Evitar divisi√≥n por cero\nrealPageCount = Math.max(1, realPageCount);\n\n\n// --- 3. M√âTRICAS FINALES ---\n\nconst avgCharsPerPage = totalChars / realPageCount;\n\n// CRITERIO: ¬øNecesita OCR?\n// Si hay texto (< 100 chars/pag) es probable que sea escaneado.\nconst needsOCR = avgCharsPerPage < 100; \n\n// Metadatos\nlet fileId = \"unknown\";\nlet fileTitle = \"unknown\";\ntry {\n  const metaNode = $('Set File ID').first().json;\n  fileId = metaNode.file_id;\n  fileTitle = metaNode.file_title;\n} catch (e) {}\n\n// --- LOGGING ---\nconsole.log(`üìÑ An√°lisis: ${fileTitle}`);\nconsole.log(`   ‚îú‚îÄ P√°ginas (Metadato): ${input.numpages}`); \nconsole.log(`   ‚îú‚îÄ P√°ginas (Usadas): ${realPageCount}`);\nconsole.log(`   ‚îú‚îÄ Caracteres Totales: ${totalChars}`);\nconsole.log(`   ‚îú‚îÄ Promedio/P√°g: ${Math.round(avgCharsPerPage)}`);\n\nreturn {\n  json: {\n    // M√©tricas corregidas\n    totalPages: realPageCount, // Ahora dir√° 235\n    totalChars: totalChars,\n    avgCharsPerPage: Math.round(avgCharsPerPage), // Ahora ser√° un n√∫mero razonable (~2800)\n    hasTables: hasTablesDetected,\n    needsOCR: needsOCR,\n    \n    // Contenido\n    pages: pages, \n    \n    // Metadatos\n    fileId: fileId,\n    fileName: fileTitle\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        -928
      ],
      "id": "48eaf238-60c2-4528-b503-3dda25edfae5",
      "name": "Validar Contenido PDF"
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "proposals",
          "mode": "list",
          "cachedResultName": "proposals"
        },
        "options": {
          "queryName": "match_proposals"
        }
      },
      "id": "6ae5e6a7-d483-480c-bc5b-155a223c0d44",
      "name": "Insert into Supabase Vectorstore",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1,
      "position": [
        3024,
        -944
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "chunkSize": 1200,
        "chunkOverlap": 200,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        3056,
        -480
      ],
      "id": "ba4f53be-7dd4-4568-88df-ff1dc6668825",
      "name": "Recursive Character Text Splitter"
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $json.text }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $json.metadata.file_id }}"
              },
              {
                "name": "file_title",
                "value": "={{ $json.metadata.file_title }}"
              },
              {
                "name": "tipo_evaluacion",
                "value": "={{ $json.metadata.tipo_evaluacion }}"
              },
              {
                "name": "proveedor",
                "value": "={{ $json.metadata.proveedor }}"
              },
              {
                "name": "project_name",
                "value": "={{ $json.metadata.project_name }}"
              }
            ]
          }
        }
      },
      "id": "62b7bed6-b77e-4b5e-b4cc-6abd056b2efb",
      "name": "Default Data Loader",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        3152,
        -656
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "10646eae-ae46-4327-a4dc-9987c2d76173",
              "name": "file_id",
              "value": "={{ $json.body.file_id }}",
              "type": "string"
            },
            {
              "id": "77d782de-169d-4a46-8a8e-a3831c04d90f",
              "name": "file_title",
              "value": "={{ $json.body.file_title }}",
              "type": "string"
            },
            {
              "id": "9bde4d7f-e4f3-4ebd-9338-dce1350f9eab",
              "name": "file_url",
              "value": "={{ $json.body.file_url }}",
              "type": "string"
            },
            {
              "id": "b1dbe9b9-248a-4593-a769-a085b34e0810",
              "name": "file_binary",
              "value": "={{ $json.body.file_binary }}",
              "type": "string"
            },
            {
              "id": "74d93dce-cddc-4947-ae19-88bc5cacd146",
              "name": "file_metadata",
              "value": "={{ $json.body.metadata }}",
              "type": "string"
            },
            {
              "id": "5e43f8d4-b48e-4188-89c8-3723f184dbeb",
              "name": "proyect_name",
              "value": "={{ $json.body.metadata.proyecto }}",
              "type": "string"
            },
            {
              "id": "1093ebc6-8dd8-4c5d-b146-b6f01b069be6",
              "name": "proveedor",
              "value": "={{ $json.body.user_proveedor }}",
              "type": "string"
            },
            {
              "id": "6e0e6e2a-9b88-403e-aa0a-da0eecccd3f9",
              "name": "evaluation",
              "value": "={{ $json.body.metadata.tipoEvaluacion }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "id": "ca93fd2f-4d8d-4297-ae93-e71bd000eeb9",
      "name": "Set File ID",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -464,
        -928
      ]
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "proposals",
        "filterType": "string",
        "filterString": "=metadata->>file_id=like.*{{ $json.file_id }}*"
      },
      "id": "67a3ddf0-348c-4108-a36a-921327cc688d",
      "name": "Delete Old Doc Rows",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -272,
        -928
      ],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_metadata",
          "mode": "list",
          "cachedResultName": "document_metadata"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $('Set File ID').item.json.file_id }}",
            "title": "={{ $('Set File ID').item.json.file_title }}",
            "project_name": "={{ $('Set File ID').item.json.proyect_name }}\n",
            "evaluation_types": "={{ $('Set File ID').item.json.evaluation }}",
            "document_type": "PROPOSAL",
            "provider": "={{ $('Set File ID').item.json.proveedor }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": true,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "title",
              "displayName": "title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "project_name",
              "displayName": "project_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "document_type",
              "displayName": "document_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "provider",
              "displayName": "provider",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "evaluation_types",
              "displayName": "evaluation_types",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -64,
        -928
      ],
      "id": "e65aed95-ed11-4065-b018-2092cf3cda69",
      "name": "Insert Document Metadata",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "V0REAPph5JBLqze3",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### EVALUATION GROUP\n- Type: {{ $json.evaluation_type }}\n- Phase: {{ $json.phase }}\n- Total requirements in this group: {{ $json.total_requisitos }}\n\n### RFQ REQUIREMENTS (LIST)\nBelow is a list of RFQ requirements in JSON format. Each element includes the 'id' field and the requirement text.\n\n{{ JSON.stringify($json.requisitos, null, 2) }}\n\n### PROPOSAL CONTEXT\n{{ $json.context }}\n\n---\n### TASK\nAnalyze the proposal context and determine the provider's compliance with EACH requirement in the list.\n\n### EVALUATION CRITERIA\n\n#### For Technical Evaluations:\n- **INCLUDED** (10 pts): Full explicit compliance with the requirement\n- **INCLUDED WITH CAVEATS** (8 pts): Complies but with minor documented conditions\n- **PARTIALLY INCLUDED** (6 pts): Complies with only part of the requirement\n- **NOT INCLUDED WITH ALTERNATIVE** (3 pts): Does not comply but proposes alternative solution\n- **NOT INCLUDED** (0 pts): Does not comply and no alternative proposed\n- **NO INFORMATION** (0 pts): Document does not mention this requirement\n\n#### For Economic Evaluations (EXTRACT THE ACTUAL VALUE):\n- **QUOTED** (10 pts): Clear price/cost quoted - MUST extract the exact value\n- **HOURLY RATE** (7 pts): Only hourly/daily rate given - MUST extract the rate value\n- **ESTIMATED** (5 pts): Estimated or approximate price given - MUST extract the value\n- **MENTIONED NO PRICE** (3 pts): Item mentioned but no price provided\n- **NOT QUOTED** (0 pts): Item does not appear in economic proposal\n\n### SPECIAL INSTRUCTIONS\n1. **Exact quote**: In gap_analysis, include the textual quote from the document supporting your evaluation\n2. **Location**: If possible, mention the page or section where you found the information\n3. **Conservative**: If in doubt, prefer lower scores and mark as \"NO INFORMATION\"\n4. **Clear evidence**: Only assign high scores if there is explicit evidence in the context\n5. **ECONOMIC EVALUATIONS**: You MUST extract and include the actual quoted value (price, hours, rate) in the 'quoted_value' field. Include currency and units.\n\n### OUTPUT FORMAT (JSON)\nReturn an array with one object per input requirement:\n[\n  {\n    \"id\": \"<requirement id>\",\n    \"cumple\": \"[INCLUDED | INCLUDED WITH CAVEATS | PARTIALLY INCLUDED | NOT INCLUDED WITH ALTERNATIVE | NOT INCLUDED | NO INFORMATION | QUOTED | HOURLY RATE | ESTIMATED | MENTIONED NO PRICE | NOT QUOTED]\",\n    \"gap_analysis\": \"[TEXTUAL QUOTE from document with location (e.g.: 'Page 15: The provider states...')]. If no information: 'No mention of this requirement found in the proposal text.'\",\n    \"quoted_value\": \"[For ECONOMIC evaluations ONLY: Extract the exact price/rate/hours quoted, e.g. '45,000 EUR', '120 EUR/hour', '500 man-hours'. Use null for technical evaluations or if no value found]\",\n    \"score\": [0-10]\n  }\n]\n\nRespond ONLY with the JSON. Do not add explanations outside the JSON.",
        "messages": {
          "messageValues": [
            {
              "message": "=You are an expert technical-commercial auditor specialized in industrial proposal evaluation.\n\nYour role is:\n1. Analyze technical and commercial proposals with precision\n2. Search for specific textual evidence in documents\n3. Be objective and conservative: when in doubt, score low\n4. Document each evaluation with textual quotes from the document\n\nIMPORTANT: ALL your responses MUST be in ENGLISH, regardless of the source document language.\n\nDO NOT invent information. If you don't find clear evidence, mark it as \"NO INFORMATION\" with score 0."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        1680,
        -1680
      ],
      "id": "191c1539-412b-4905-a3e9-be7647c8add8",
      "name": "LLM Chain"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear y Preparar Update (CON VALIDACI√ìN DE FK)\n// =============================================\n\n// 1. Obtener TODOS los items del LLM Chain\nconst allItems = $input.all();\nconsole.log(`üì• Procesando ${allItems.length} respuestas del LLM`);\n\n// 2. Obtener la lista de requisitos V√ÅLIDOS (para validar FK)\nlet validRequirements = [];\ntry {\n  const getRowsData = $('Get many rows1').all();\n  validRequirements = getRowsData.map(item => item.json.id);\n  console.log(`‚úÖ Lista de requisitos v√°lidos: ${validRequirements.length} items`);\n} catch(e) {\n  console.error('‚ùå Error obteniendo lista de requisitos v√°lidos:', e.message);\n  // Si no podemos obtener la lista v√°lida, no procesamos nada\n  return [];\n}\n\n// 3. Obtener el provider name (una sola vez, es el mismo para todos)\nlet providerName = \"OTROS\";\ntry {\n  providerName = $('Expandir por Tipo de Evaluaci√≥n').first().json.proveedor_detectado || \"OTROS\";\n} catch(e) {\n  console.warn('‚ö†Ô∏è Error obteniendo provider, usando default:', e.message);\n}\n\n// 4. Procesar CADA respuesta del LLM\nconst resultados = [];\n\nfor (let i = 0; i < allItems.length; i++) {\n  try {\n    const item = allItems[i];\n    const itemData = item.json || item;\n\n    // El LLM Chain devuelve el resultado en el campo 'text' o 'output'\n    let rawText = itemData.text || itemData.output || \"\";\n\n    if (!rawText || typeof rawText !== 'string') {\n      console.warn(`‚ö†Ô∏è Item ${i}: No se encontr√≥ campo 'text' o 'output'`);\n      continue;\n    }\n\n    // Limpiar el texto: remover code blocks de markdown\n    let cleanText = rawText\n      .replace(/```json/g, '')\n      .replace(/```/g, '')\n      .trim();\n\n    // Extraer el JSON del texto\n    let parsedData = null;\n\n    try {\n      // Buscar el JSON array en el texto\n      const start = cleanText.indexOf('[');\n      const end = cleanText.lastIndexOf(']');\n\n      if (start >= 0 && end >= 0 && end > start) {\n        const jsonString = cleanText.substring(start, end + 1);\n        parsedData = JSON.parse(jsonString);\n      } else {\n        // Intentar parsear directamente\n        parsedData = JSON.parse(cleanText);\n      }\n    } catch (parseError) {\n      console.error(`‚ùå Error parseando JSON del item ${i}:`, parseError.message);\n      console.error(`Texto recibido:`, cleanText.substring(0, 200));\n      continue;\n    }\n\n    // El LLM puede devolver un array (1 objeto por requisito) o un objeto √∫nico\n    const outputArray = Array.isArray(parsedData) ? parsedData : [parsedData];\n\n    for (let j = 0; j < outputArray.length; j++) {\n      const outputItem = outputArray[j];\n\n      if (!outputItem || typeof outputItem !== 'object') {\n        console.warn(`‚ö†Ô∏è Item ${i}.${j}: Elemento de salida no es objeto`);\n        continue;\n      }\n\n      // Extraer valores del an√°lisis\n      const cumple = outputItem?.cumple || \"ERROR ANALISIS\";\n      const gap = outputItem?.gap_analysis || outputItem?.gap_analysis || \"Check logs\";\n      const score = outputItem?.score !== undefined ? outputItem.score : 0;\n      const requirementId = outputItem?.id || null;\n      const quotedValue = outputItem?.quoted_value || null;\n\n      // Validar que score est√© en rango 0-10\n      const validatedScore = Math.max(0, Math.min(10, parseInt(score) || 0));\n\n      // VALIDACI√ìN CR√çTICA: Verificar que el requirement_id existe en la base de datos\n      if (!requirementId) {\n        console.error(`‚ùå Item ${i}.${j}: No se encontr√≥ ID del requisito en la respuesta del LLM`);\n        continue;\n      }\n\n      if (!validRequirements.includes(requirementId)) {\n        console.error(`‚ùå Item ${i}.${j}: El requirement_id ${requirementId} NO existe en rfq_items_master. Saltando...`);\n        console.error(`   Requisitos v√°lidos disponibles:`, validRequirements.slice(0, 5), '...');\n        continue;\n      }\n\n      console.log(`‚úÖ Item ${i}.${j}: Requisito ${requirementId} - ${cumple} (${validatedScore}/10)${quotedValue ? ' - Value: ' + quotedValue : ''}`);\n\n      // Preparar resultado para Upsert\n      resultados.push({\n        json: {\n          requirement_id: requirementId,\n          provider_name: providerName,\n          evaluation_value: cumple,\n          comment: gap,\n          score: validatedScore,\n          quoted_value: quotedValue\n        }\n      });\n    }\n\n  } catch (error) {\n    console.error(`‚ùå Error procesando item ${i}:`, error.message);\n    // Continuar con el siguiente item\n    continue;\n  }\n}\n\nconsole.log(`‚úÖ Procesados ${resultados.length} de ${allItems.length} items exitosamente (con FK v√°lidas)`);\n\n// 5. Retornar todos los resultados\nreturn resultados;"
      },
      "id": "273f103a-cc43-4640-831f-fafc8b014c47",
      "name": "Parsear y Preparar Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2208,
        -1680
      ]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {
          "reset": "={{ $json.reiniciar_bucle ? true : false }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        736,
        -1696
      ],
      "id": "1cdc513d-8eee-4901-87eb-152790d45282",
      "name": "Loop Over Phases"
    },
    {
      "parameters": {
        "content": "### Ingesta de Ofertas de Proveedores",
        "height": 1744,
        "width": 4608,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1072,
        -2048
      ],
      "id": "a006b7a2-f363-4a88-a94b-fa5307afc950",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2400,
        -512
      ],
      "id": "d5e6d09f-cd4e-417a-8d86-b239883425a8",
      "name": "Ollama Model",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "model": "qwen3:14b",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        1680,
        -1504
      ],
      "id": "ad73cba8-b86b-44e5-9101-f0936ff952ec",
      "name": "Ollama Model1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "267128b5-e2c0-44ae-9973-7f18dffe292e",
              "leftValue": "={{ $('Set File ID').item.json.proveedor }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            },
            {
              "id": "a9d65ff4-430e-45db-8ca8-6078e5ee32fa",
              "leftValue": "={{ $('Set File ID').item.json.evaluation[0] }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            },
            {
              "id": "d5c265e7-00e5-42f4-95ad-4eca1e3ef530",
              "leftValue": "={{ $('Set File ID').item.json.proyect_name }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        2176,
        -928
      ],
      "id": "0c3713b6-69d9-4bb3-b0d7-13e368b38c21",
      "name": "If"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"id\": {\n        \"type\": \"integer\",\n        \"description\": \"Numeric ID of the evaluated item\"\n      },\n      \"cumple\": {\n        \"type\": \"string\",\n        \"description\": \"Compliance status. Technical: INCLUDED, INCLUDED WITH CAVEATS, PARTIALLY INCLUDED, NOT INCLUDED WITH ALTERNATIVE, NOT INCLUDED, NO INFORMATION. Economic: QUOTED, HOURLY RATE, ESTIMATED, MENTIONED NO PRICE, NOT QUOTED\",\n        \"enum\": [\"INCLUDED\", \"INCLUDED WITH CAVEATS\", \"PARTIALLY INCLUDED\", \"NOT INCLUDED WITH ALTERNATIVE\", \"NOT INCLUDED\", \"NO INFORMATION\", \"QUOTED\", \"HOURLY RATE\", \"ESTIMATED\", \"MENTIONED NO PRICE\", \"NOT QUOTED\"]\n      },\n      \"gap_analysis\": {\n        \"type\": \"string\",\n        \"description\": \"Textual quote from document with exact location (page/section) supporting the evaluation\"\n      },\n      \"quoted_value\": {\n        \"type\": [\"string\", \"null\"],\n        \"description\": \"For economic evaluations: the exact price, rate or hours quoted (e.g. '45000 EUR', '120 EUR/hour'). Null for technical evaluations.\"\n      },\n      \"score\": {\n        \"type\": \"integer\",\n        \"description\": \"Score from 0 to 10 based on requirement compliance\",\n        \"minimum\": 0,\n        \"maximum\": 10\n      }\n    },\n    \"required\": [\"id\", \"cumple\", \"gap_analysis\", \"score\"]\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1904,
        -1504
      ],
      "id": "bba3a55f-f75b-472d-96d1-53c63873c158",
      "name": "Structured Output Parser3"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### CLASIFICACI√ìN T√âCNICA Y COMERCIAL (RFQ)\n\n### DOCUMENTO DE MUESTRA (Primeras 2 p√°ginas):\n{{ $json.texto_muestra }}\n\n---\n### TAREA DE CLASIFICACI√ìN:\nIdentifica proyecto, proveedor y tipos de evaluaci√≥n. \n\n**REGLA DE ORO DE NOMENCLATURA:**\nDebes traducir los t√≠tulos del documento a estos nombres exactos:\n- **\"Commercial Proposal\" / \"Oferta Econ√≥mica\"** ‚Üí DEBE SER `Economical Evaluation`.\n- **\"Technical Proposal\" / \"Scope of Work\"** ‚Üí DEBE SER `Technical Evaluation`.\n- **Listas de documentos** ‚Üí `Pre-FEED Deliverables` o `FEED Deliverables` (seg√∫n contexto).\n\n#### REQUISITOS:\n1. **PROVEEDOR**: Debe ser uno de: IDOM, SENER, TRESCA, SACYR, TECNICASREUNIDAS, EA, WORLEY.\n2. **TIPOS**: El array `tipos_detectados` solo puede contener los nombres can√≥nicos arriba mencionados.\n\n---\n### FORMATO DE SALIDA (JSON):\n{\n  \"modo_usado\": \"CLASIFICADOR\",\n  \"proyecto_detectado\": \"Nombre\",\n  \"proveedor_detectado\": \"IDOM | SENER | TRESCA | SACYR | TECNICASREUNIDAS | EA | WORLEY\",\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Economical Evaluation\"],\n  \"razonamiento\": \"Justificaci√≥n: 'Commercial Proposal' detectado -> Economical Evaluation mapeada.\"\n}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "Identifica al proveedor y los tipos de evaluaci√≥n presentes en el documento bas√°ndote solo en las primeras p√°ginas."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        2448,
        -720
      ],
      "id": "5930bb5f-cb58-486d-b825-45b6ad7483dc",
      "name": "Clasificador de Tipo de Evaluacion y Proveedor"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"modo_usado\": {\n      \"type\": \"string\"\n    },\n    \"proyecto_detectado\": {\n      \"type\": \"string\"\n    },\n    \"proyecto_valido\": {\n      \"type\": \"boolean\"\n    },\n    \"proyecto_nota\": {\n      \"type\": \"string\"\n    },\n    \"proveedor_detectado\": {\n      \"type\": \"string\"\n    },\n    \"proveedor_valido\": {\n      \"type\": \"boolean\",\n      \"description\": \"DEBE ser false si el proveedor detectado es distinto al que el usuario seleccion√≥.\"\n    },\n    \"proveedor_nota\": {\n      \"type\": \"string\"\n    },\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"description\": \"Array con los tipos que realmente tienen evidencia en el doc.\"\n    },\n    \"tipos_validados\": {\n      \"type\": \"boolean\",\n      \"description\": \"DEBE ser false si el tipo seleccionado por el usuario no tiene evidencia clara en el PDF.\"\n    },\n    \"tipos_nota\": {\n      \"type\": \"string\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"proyecto_detectado\",\n    \"proyecto_valido\",\n    \"proveedor_detectado\",\n    \"proveedor_valido\",\n    \"tipos_validados\",\n    \"razonamiento\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2640,
        -928
      ],
      "id": "36b8065f-934d-4b46-92ec-3110aadfe8d1",
      "name": "Structured Output Parser4"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [
        2400,
        -928
      ],
      "id": "d412c0ae-af3b-4ad2-b86c-aff3437b25eb",
      "name": "Ollama Chat Model1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### AUDITOR√çA DE DOCUMENTO: VALIDACI√ìN CRUZADA\n\n**[1. SELECCI√ìN MANUAL DEL USUARIO]**\n- Proyecto: \"{{ $('Set File ID').item.json.proyect_name }}\"\n- Proveedor: \"{{ $('Set File ID').item.json.proveedor }}\"\n- Tipo de Evaluaci√≥n: \"{{ $('Set File ID').item.json.evaluation }}\"\n- Nombre Archivo: \"{{ $('Set File ID').item.json.file_title }}\"\n\n---\n**[2. EVIDENCIA REAL DEL PDF (Texto extra√≠do)]**\n{{ $json.texto_muestra }}\n\n---\n### INSTRUCCIONES DE MAPEADO Y VALIDACI√ìN:\n\n#### REGLA 1: SIN√ìNIMOS Y TIPOS CAN√ìNICOS\nSolo puedes usar estos 4 nombres exactos. Mapea la evidencia as√≠:\n- **\"Commercial Proposal\" / \"Oferta Econ√≥mica\" / \"Price Schedule\"** ‚Üí DEBE SER `Economical Evaluation`.\n- **\"Technical Proposal\" / \"Scope of Work\" / \"Metodolog√≠a\"** ‚Üí DEBE SER `Technical Evaluation`.\n- **\"Technical & Economical Proposal\"** ‚Üí DEBE INCLUIR AMBOS: `Technical Evaluation` Y `Economical Evaluation`.\n- **Listas de planos** ‚Üí `Pre-FEED Deliverables` o `FEED Deliverables`.\n\n#### REGLA 2: EL T√çTULO Y NOMBRE DE ARCHIVO SON DECISIVOS\n- Analiza el **Nombre Archivo** y el **T√≠tulo** del documento. Si dicen \"Oferta T√©cnica\" o \"Technical Proposal\", el tipo es `Technical Evaluation`.\n- **IMPORTANTE:** NO agregues otros tipos por menciones menores. Ejemplo: Si un documento t√©cnico menciona \"precios estimados\", NO agregues `Economical Evaluation`. Solo agr√©galo si ves una TABLA DE PRECIOS completa.\n- S√© conservador: ante la duda, gu√≠ate por el Nombre del Archivo.\n\n#### REGLA 3: BALANCEO DE INTENCI√ìN\n- Si el PDF es mixto pero el usuario ha seleccionado uno de los tipos v√°lidos presentes, marca `tipos_validados: true`.\n\n### FORMATO DE SALIDA (JSON √öNICO):\n{\n  \"modo_usado\": \"VALIDADOR\",\n  \"proyecto_detectado\": \"Nombre Real\",\n  \"proyecto_valido\": true | false,\n  \"proyecto_nota\": \"Resumen\",\n  \"proveedor_detectado\": \"IDOM | SENER | TRESCA | SACYR | TECNICASREUNIDAS | EA | WORLEY\",\n  \"proveedor_valido\": true | false,\n  \"proveedor_nota\": \"Explicaci√≥n\",\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Economical Evaluation\", \"Pre-FEED Deliverables\", \"FEED Deliverables\"],\n  \"tipos_validados\": true | false,\n  \"tipos_nota\": \"Explica por qu√© validaste o rechazaste los tipos.\",\n  \"razonamiento\": \"Menciona el Nombre del Archivo y el T√≠tulo encontrado.\"\n}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=Act√∫a como un validador estricto. Si hay discrepancias flagrantes entre la sugerencia del usuario y el contenido real del PDF, prioriza el contenido del PDF y marca la validaci√≥n como falsa y reporta el proveedor/tipo correcto.\n\nProveedores soportados: T√©cnicas Reunidas, IDOM, SACYR, Empresarios Agrupados, SENER, TRESCA, WORLEY"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        2448,
        -1120
      ],
      "id": "e4d33bad-ff6c-46f8-b886-742009c87696",
      "name": "Validador de Ofertas"
    },
    {
      "parameters": {
        "model": "qwen3-embedding:8b"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        2944,
        -688
      ],
      "id": "02c796f9-cb00-40ae-b106-49e19d3e36bd",
      "name": "Embeddings Ollama3",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "tableId": "provider_responses",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "provider_name",
              "fieldValue": "={{ $json.provider_name }}"
            },
            {
              "fieldId": "evaluation_value",
              "fieldValue": "={{ $json.evaluation_value }}"
            },
            {
              "fieldId": "comment",
              "fieldValue": "={{ $json.comment }}"
            },
            {
              "fieldId": "score",
              "fieldValue": "={{ $json.score }}"
            },
            {
              "fieldId": "requirement_id",
              "fieldValue": "={{ $json.requirement_id }}"
            },
            {
              "fieldId": "updated_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "file_id",
              "fieldValue": "={{ $('Set File ID').first().json.file_id }}"
            },
            {
              "fieldId": "quoted_value",
              "fieldValue": "={{ $json.quoted_value }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2640,
        -1488
      ],
      "id": "652815e9-8fcb-4df3-ba3d-5313ec697741",
      "name": "Upsert Provider Response",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "rfq_items_master",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "evaluation_type",
              "condition": "eq",
              "keyValue": "={{ $json.tipo_evaluacion_actual }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -96,
        -1760
      ],
      "id": "2fad598c-31c7-4ae3-970f-ddc157ced80c",
      "name": "Get many rows1",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "model": "mistral-large-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        1472,
        -1504
      ],
      "id": "a841c7e9-3e9d-4666-abfb-cf93a7a1655e",
      "name": "Mistral Cloud Chat Model",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.embeddingsCohere",
      "typeVersion": 1,
      "position": [
        3056,
        -736
      ],
      "id": "d8cca829-9cf1-4ac5-a1fd-5b2101578706",
      "name": "Embeddings Cohere",
      "credentials": {
        "cohereApi": {
          "id": "KGv4zlUJIjLdxpnr",
          "name": "CohereApi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Grupo de Requisitos por Phase\n// Recibe datos ya agrupados del nodo 'Agrupar por Phase'\n// =============================================\n\n// 1. Obtener el grupo actual (ya viene agrupado por phase)\nconst grupoActual = $input.first().json;\n\nconst phase = grupoActual.phase || \"Sin Phase\";\nconst requisitosDelGrupo = grupoActual.requisitos || [];\nconst textoOfertaCompleto = grupoActual.texto_oferta_completo || \"\";\nconst esOfertaLarga = grupoActual.es_oferta_larga || false;\nconst evaluationType = grupoActual.evaluation_type || \"Technical Evaluation\";\n\nconsole.log(`üìã Procesando grupo: ${evaluationType} - ${phase}`);\nconsole.log(`   ‚îú‚îÄ Requisitos en este grupo: ${requisitosDelGrupo.length}`);\nconsole.log(`   ‚îú‚îÄ Tama√±o texto oferta: ${textoOfertaCompleto.length} chars`);\nconsole.log(`   ‚îî‚îÄ Modo: ${esOfertaLarga ? 'RAG' : 'DIRECTO'}`);\n\n// 2. Preparar contexto seg√∫n tama√±o de oferta\nlet contextoParaLLM = \"\";\n\nif (esOfertaLarga) {\n    // MODO RAG: Usaremos el vectorstore (se configura despu√©s)\n    // Por ahora pasamos una muestra y marcamos para RAG\n    contextoParaLLM = textoOfertaCompleto.substring(0, 8000);\n    console.log(`üîç Modo RAG: Contexto limitado a 8000 chars (se complementar√° con retrieval)`);\n} else {\n    // MODO DIRECTO: Pasamos todo el texto\n    contextoParaLLM = textoOfertaCompleto;\n    console.log(`üìÑ Modo DIRECTO: Pasando texto completo`);\n}\n\n// 3. Formatear requisitos para el LLM\nconst requisitosFormateados = requisitosDelGrupo.map(req => ({\n    id: req.id || \"\",\n    requirement_text: req.requirement_text || req.text || \"NO ESPECIFICADO\",\n    phase: req.phase || phase,\n    evaluation_type: req.evaluation_type || evaluationType\n}));\n\n// 4. Retornar datos preparados para el LLM\nreturn [{\n    json: {\n        // Datos del grupo\n        phase: phase,\n        evaluation_type: evaluationType,\n        \n        // Requisitos del grupo\n        requisitos: requisitosFormateados,\n        total_requisitos: requisitosFormateados.length,\n        \n        // Contexto de la oferta\n        context: contextoParaLLM,\n        texto_length: contextoParaLLM.length,\n        \n        // Flags para el flujo\n        es_oferta_larga: esOfertaLarga,\n        usar_rag: esOfertaLarga\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1184,
        -1680
      ],
      "id": "a0573c54-146b-48ba-82a7-67a08b147f4f",
      "name": "Preparar Grupo Phase"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "rag-condition-1",
              "leftValue": "={{ $json.es_oferta_larga }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1400,
        -1680
      ],
      "id": "if-oferta-larga-001",
      "name": "IF Oferta Larga"
    },
    {
      "parameters": {
        "mode": "load",
        "tableName": {
          "__rl": true,
          "value": "proposals",
          "mode": "list",
          "cachedResultName": "proposals"
        },
        "prompt": "={{ $json.evaluation_type }} {{ $json.phase }} {{ $json.requisitos.slice(0, 5).map(r => r.requirement_text).join('. ') }}",
        "topK": 15,
        "options": {
          "queryName": "match_proposals",
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $('Set File ID').first().json.file_id }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1.3,
      "position": [
        1600,
        -1840
      ],
      "id": "rag-vectorstore-001",
      "name": "RAG Query Vectorstore",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "model": "qwen3-embedding:8b"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        1600,
        -1680
      ],
      "id": "embeddings-rag-001",
      "name": "Embeddings Ollama RAG",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Contexto RAG\n// Combina los chunks recuperados con los requisitos\n// =============================================\n\nconst items = $input.all();\n\n// Obtener datos del grupo desde el nodo anterior\nlet grupoData;\ntry {\n    grupoData = $('Preparar Grupo Phase').first().json;\n} catch(e) {\n    grupoData = {};\n}\n\n// Construir contexto desde los chunks RAG\n// Estructura de Supabase Vector Store: { document: { pageContent, metadata }, score }\nlet contextoRAG = \"\";\nitems.forEach((item, idx) => {\n    const chunk = item.json;\n    \n    // Extraer texto - puede estar en document.pageContent o directamente\n    let text = \"\";\n    if (chunk.document && chunk.document.pageContent) {\n        text = chunk.document.pageContent;\n    } else if (chunk.pageContent) {\n        text = chunk.pageContent;\n    } else if (chunk.text) {\n        text = chunk.text;\n    } else if (chunk.content) {\n        text = chunk.content;\n    }\n    \n    // Extraer metadata para referencia\n    const metadata = chunk.document?.metadata || chunk.metadata || {};\n    const lines = metadata.loc?.lines || {};\n    const score = chunk.score || 0;\n    \n    if (text) {\n        contextoRAG += `\\n--- Fragment ${idx + 1} (lines ${lines.from || '?'}-${lines.to || '?'}, relevance: ${score.toFixed(4)}) ---\\n${text}\\n`;\n    }\n});\n\nconsole.log(`üîç RAG: ${items.length} chunks recuperados`);\nconsole.log(`   ‚îî‚îÄ Total contexto: ${contextoRAG.length} chars`);\n\n// Retornar con el mismo formato que espera LLM Chain\nreturn [{\n    json: {\n        // Datos del grupo\n        phase: grupoData.phase || \"Sin Phase\",\n        evaluation_type: grupoData.evaluation_type || \"Technical Evaluation\",\n        \n        // Requisitos (vienen del grupo)\n        requisitos: grupoData.requisitos || [],\n        total_requisitos: grupoData.total_requisitos || 0,\n        \n        // Contexto RAG (reemplaza el contexto directo)\n        context: contextoRAG,\n        texto_length: contextoRAG.length,\n        \n        // Flags\n        es_oferta_larga: true,\n        usar_rag: true,\n        rag_chunks: items.length\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1840,
        -1840
      ],
      "id": "preparar-contexto-rag-001",
      "name": "Preparar Contexto RAG"
    }
  ],
  "connections": {
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Set File ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary1": {
      "main": [
        [
          {
            "node": "Docling OCR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Items": {
      "main": [
        [
          {
            "node": "Loop Over Phases",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Preparar Texto de Muestra",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Clasificador de Tipo de Evaluacion y Proveedor",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Docling OCR": {
      "main": [
        [
          {
            "node": "Aggregate OCR Pages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items1": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get many rows1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expandir por Tipo de Evaluaci√≥n": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Vectorstore": {
      "main": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Texto de Muestra": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate OCR Pages": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "¬øNecesita OCR?": {
      "main": [
        [
          {
            "node": "Base64 a Binary1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Validar Contenido PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Contenido PDF": {
      "main": [
        [
          {
            "node": "¬øNecesita OCR?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert into Supabase Vectorstore": {
      "main": [
        [
          {
            "node": "Expandir por Tipo de Evaluaci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Set File ID": {
      "main": [
        [
          {
            "node": "Delete Old Doc Rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Doc Rows": {
      "main": [
        [
          {
            "node": "Insert Document Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Document Metadata": {
      "main": [
        [
          {
            "node": "Base64 a Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Chain": {
      "main": [
        [
          {
            "node": "Parsear y Preparar Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear y Preparar Update": {
      "main": [
        [
          {
            "node": "Upsert Provider Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Phases": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Preparar Grupo Phase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Model": {
      "ai_languageModel": [
        [
          {
            "node": "Clasificador de Tipo de Evaluacion y Proveedor",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Validador de Ofertas",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Clasificador de Tipo de Evaluacion y Proveedor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clasificador de Tipo de Evaluacion y Proveedor": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser4": {
      "ai_outputParser": [
        [
          {
            "node": "Validador de Ofertas",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Validador de Ofertas",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Validador de Ofertas": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert Provider Response": {
      "main": [
        [
          {
            "node": "Loop Over Phases",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many rows1": {
      "main": [
        [
          {
            "node": "Agrupar por Phase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agrupar por Phase": {
      "main": [
        [
          {
            "node": "Reset Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral Cloud Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Cohere": {
      "ai_embedding": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Grupo Phase": {
      "main": [
        [
          {
            "node": "IF Oferta Larga",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Oferta Larga": {
      "main": [
        [
          {
            "node": "RAG Query Vectorstore",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Query Vectorstore": {
      "main": [
        [
          {
            "node": "Preparar Contexto RAG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Contexto RAG": {
      "main": [
        [
          {
            "node": "LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Ollama RAG": {
      "ai_embedding": [
        [
          {
            "node": "RAG Query Vectorstore",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "53140335eaf11280ef77ef2f5a378f48c2b28e822e3e0d96563cdd92175c0eff"
  }
}