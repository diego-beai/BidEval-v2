{
  "nodes": [
    {
      "parameters": {
        "model": "mistral-large-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        2144,
        -1680
      ],
      "id": "9429f3f9-516f-44ea-85e1-7b66458c30e2",
      "name": "Mistral Cloud Chat Model3",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "rfq_items_master",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "evaluation_type",
              "condition": "eq",
              "keyValue": "={{ $json.tipo_evaluacion_actual }}"
            },
            {
              "keyName": "project_id",
              "condition": "eq",
              "keyValue": "={{ $('Set File ID').first().json.project_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -128,
        -1808
      ],
      "id": "77e57cc8-1fc5-4015-916f-da2b36d35005",
      "name": "Get many rows1",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "model": "qwen3-embedding:8b"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        2912,
        -720
      ],
      "id": "c3e69201-bb5a-4a15-acbd-1b1444cfd1d4",
      "name": "Embeddings Ollama3",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### DOCUMENT AUDIT: CROSS-VALIDATION\n\n**[1. USER MANUAL SELECTION]**\n- Project: \"{{ $('Set File ID').item.json.proyect_name }}\"\n- Provider: \"{{ $('Set File ID').item.json.proveedor }}\"\n- Evaluation Type: \"{{ $('Set File ID').item.json.evaluation }}\"\n- File Name: \"{{ $('Set File ID').item.json.file_title }}\"\n\n---\n**[2. ACTUAL PDF EVIDENCE (Extracted text)]**\n{{ $json.texto_muestra }}\n\n---\n### MAPPING AND VALIDATION INSTRUCTIONS:\n\n#### RULE 1: SYNONYMS AND CANONICAL TYPES\nYou can only use these 4 exact names. Map the evidence as follows:\n- **\"Commercial Proposal\" / \"Oferta Econ√≥mica\" / \"Price Schedule\"** ‚Üí MUST BE `Economical Evaluation`.\n- **\"Technical Proposal\" / \"Scope of Work\" / \"Metodolog√≠a\"** ‚Üí MUST BE `Technical Evaluation`.\n- **\"Technical & Economical Proposal\"** ‚Üí MUST INCLUDE BOTH: `Technical Evaluation` AND `Economical Evaluation`.\n- **Drawing lists** ‚Üí `Pre-FEED Deliverables` or `FEED Deliverables`.\n\n#### RULE 2: TITLE AND FILE NAME ARE DECISIVE\n- Analyze the **File Name** and **Title** of the document. If they say \"Oferta T√©cnica\" or \"Technical Proposal\", the type is `Technical Evaluation`.\n- **IMPORTANT:** DO NOT add other types for minor mentions. Example: If a technical document mentions \"estimated prices\", DO NOT add `Economical Evaluation`. Only add it if you see a complete PRICE TABLE.\n- Be conservative: when in doubt, follow the File Name.\n\n#### RULE 3: INTENTION BALANCING\n- If the PDF is mixed but the user has selected one of the valid types present, mark `tipos_validados: true`.\n\n### OUTPUT FORMAT (SINGLE JSON):\n{\n  \"modo_usado\": \"VALIDADOR\",\n  \"proyecto_detectado\": \"Actual Name\",\n  \"proyecto_valido\": true | false,\n  \"proyecto_nota\": \"Summary\",\n  \"proveedor_detectado\": \"IDOM | SENER | TRESCA | SACYR | TECNICASREUNIDAS | EA | WORLEY\",\n  \"proveedor_valido\": true | false,\n  \"proveedor_nota\": \"Explanation\",\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Economical Evaluation\", \"Pre-FEED Deliverables\", \"FEED Deliverables\"],\n  \"tipos_validados\": true | false,\n  \"tipos_nota\": \"Explain why you validated or rejected the types.\",\n  \"razonamiento\": \"Mention the File Name and Title found.\"\n}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=Act as a strict validator. If there are flagrant discrepancies between the user's suggestion and the actual PDF content, prioritize the PDF content and mark validation as false and report the correct provider/type.\n\nSupported providers: Tecnicas Reunidas, IDOM, SACYR, Empresarios Agrupados, SENER, TRESCA, WORLEY"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        2416,
        -1168
      ],
      "id": "71e777a0-7652-4d79-90c3-0778d5756c92",
      "name": "Validador de Ofertas"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1,
          "numCtx": 4096,
          "numPredict": 1024
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [
        2368,
        -976
      ],
      "id": "3c6e807d-e353-4030-b8ab-6cc268bbd839",
      "name": "Ollama Chat Model1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"modo_usado\": {\n      \"type\": \"string\"\n    },\n    \"proyecto_detectado\": {\n      \"type\": \"string\"\n    },\n    \"proyecto_valido\": {\n      \"type\": \"boolean\"\n    },\n    \"proyecto_nota\": {\n      \"type\": \"string\"\n    },\n    \"proveedor_detectado\": {\n      \"type\": \"string\"\n    },\n    \"proveedor_valido\": {\n      \"type\": \"boolean\",\n      \"description\": \"DEBE ser false si el proveedor detectado es distinto al que el usuario seleccion√≥.\"\n    },\n    \"proveedor_nota\": {\n      \"type\": \"string\"\n    },\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"description\": \"Array con los tipos que realmente tienen evidencia en el doc.\"\n    },\n    \"tipos_validados\": {\n      \"type\": \"boolean\",\n      \"description\": \"DEBE ser false si el tipo seleccionado por el usuario no tiene evidencia clara en el PDF.\"\n    },\n    \"tipos_nota\": {\n      \"type\": \"string\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"proyecto_detectado\",\n    \"proyecto_valido\",\n    \"proveedor_detectado\",\n    \"proveedor_valido\",\n    \"tipos_validados\",\n    \"razonamiento\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2608,
        -976
      ],
      "id": "98f6a635-bfbb-4229-bf7a-8c149fde43d9",
      "name": "Structured Output Parser4"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### TECHNICAL AND COMMERCIAL CLASSIFICATION (RFQ)\n\n### DOCUMENT SAMPLE (First 2 pages):\n{{ $json.texto_muestra }}\n\n---\n### CLASSIFICATION TASK:\nIdentify project, provider and evaluation types.\n\n**GOLDEN RULE FOR NOMENCLATURE:**\nYou must translate document titles to these exact names:\n- **\"Commercial Proposal\" / \"Oferta Econ√≥mica\"** ‚Üí MUST BE `Economical Evaluation`.\n- **\"Technical Proposal\" / \"Scope of Work\"** ‚Üí MUST BE `Technical Evaluation`.\n- **Document lists** ‚Üí `Pre-FEED Deliverables` or `FEED Deliverables` (depending on context).\n\n#### REQUIREMENTS:\n1. **PROVIDER**: Must be one of: IDOM, SENER, TRESCA, SACYR, TECNICASREUNIDAS, EA, WORLEY.\n2. **TYPES**: The `tipos_detectados` array can only contain the canonical names mentioned above.\n\n---\n### OUTPUT FORMAT (JSON):\n{\n  \"modo_usado\": \"CLASIFICADOR\",\n  \"proyecto_detectado\": \"Name\",\n  \"proveedor_detectado\": \"IDOM | SENER | TRESCA | SACYR | TECNICASREUNIDAS | EA | WORLEY\",\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Economical Evaluation\"],\n  \"razonamiento\": \"Justification: 'Commercial Proposal' detected -> Economical Evaluation mapped.\"\n}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "Identify the provider and evaluation types present in the document based only on the first pages."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        2416,
        -752
      ],
      "id": "780371b3-9866-42c2-92a8-9d6081187947",
      "name": "Clasificador de Tipo de Evaluacion y Proveedor"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "267128b5-e2c0-44ae-9973-7f18dffe292e",
              "leftValue": "={{ $('Set File ID').item.json.proveedor }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            },
            {
              "id": "a9d65ff4-430e-45db-8ca8-6078e5ee32fa",
              "leftValue": "={{ $('Set File ID').item.json.evaluation[0] }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            },
            {
              "id": "d5c265e7-00e5-42f4-95ad-4eca1e3ef530",
              "leftValue": "={{ $('Set File ID').item.json.proyect_name }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        2144,
        -976
      ],
      "id": "45e5aa83-ecde-43d7-b70a-9f8d8d20eb72",
      "name": "If"
    },
    {
      "parameters": {
        "model": "qwen3:8b",
        "options": {
          "temperature": 0.1,
          "numCtx": 8192,
          "numPredict": 1536
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2128,
        -1536
      ],
      "id": "aa225eab-78a4-4dd6-a55d-f949b157b1aa",
      "name": "Ollama Model1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1,
          "numCtx": 4096,
          "numPredict": 1024
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2368,
        -544
      ],
      "id": "ca4ac30b-374a-4d5f-bbec-98120890b952",
      "name": "Ollama Model",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "content": "### Ingesta de Ofertas de Proveedores",
        "height": 1744,
        "width": 4608,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1104,
        -2128
      ],
      "id": "17c4268a-3583-4822-bf0a-f6f94b720f39",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "batchSize": 50,
        "options": {
          "reset": "={{ $json.reiniciar_bucle ? true : false }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        704,
        -1744
      ],
      "id": "fcc7fa09-78bb-43ba-b7d9-64c6cd2f1b19",
      "name": "Loop Over Phases"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear y Preparar Update (SIN quoted_value)\n// =============================================\n\n// 1. Obtener TODOS los items del LLM Chain\nconst allItems = $input.all();\nconsole.log(`üì• Procesando ${allItems.length} respuestas del LLM`);\n\n// 2. Obtener la lista de requisitos V√ÅLIDOS (para validar FK)\nlet validRequirements = [];\ntry {\n  const getRowsData = $('Get many rows1').all();\n  validRequirements = getRowsData.map(item => item.json.id);\n  console.log(`‚úÖ Lista de requisitos v√°lidos: ${validRequirements.length} items`);\n} catch(e) {\n  console.error('‚ùå Error obteniendo lista de requisitos v√°lidos:', e.message);\n  return [];\n}\n\n// 3. Obtener el provider name (una sola vez, es el mismo para todos)\nlet providerName = \"OTROS\";\ntry {\n  providerName = $('Expandir por Tipo de Evaluaci√≥n').first().json.proveedor_detectado || \"OTROS\";\n} catch(e) {\n  console.warn('‚ö†Ô∏è Error obteniendo provider, usando default:', e.message);\n}\n\n// 4. Procesar CADA respuesta del LLM\nconst resultados = [];\n\nfor (let i = 0; i < allItems.length; i++) {\n  try {\n    const item = allItems[i];\n    const itemData = item.json || item;\n\n    let rawText = itemData.text || itemData.output || \"\";\n\n    if (!rawText || typeof rawText !== 'string') {\n      console.warn(`‚ö†Ô∏è Item ${i}: No se encontr√≥ campo 'text' o 'output'`);\n      continue;\n    }\n\n    let cleanText = rawText\n      .replace(/```json/g, '')\n      .replace(/```/g, '')\n      .trim();\n\n    let parsedData = null;\n\n    try {\n      const start = cleanText.indexOf('[');\n      const end = cleanText.lastIndexOf(']');\n\n      if (start >= 0 && end >= 0 && end > start) {\n        const jsonString = cleanText.substring(start, end + 1);\n        parsedData = JSON.parse(jsonString);\n      } else {\n        parsedData = JSON.parse(cleanText);\n      }\n    } catch (parseError) {\n      console.error(`‚ùå Error parseando JSON del item ${i}:`, parseError.message);\n      console.error(`Texto recibido:`, cleanText.substring(0, 200));\n      continue;\n    }\n\n    const outputArray = Array.isArray(parsedData) ? parsedData : [parsedData];\n\n    for (let j = 0; j < outputArray.length; j++) {\n      const outputItem = outputArray[j];\n\n      if (!outputItem || typeof outputItem !== 'object') {\n        console.warn(`‚ö†Ô∏è Item ${i}.${j}: Elemento de salida no es objeto`);\n        continue;\n      }\n\n      const cumple = outputItem?.cumple || \"ERROR ANALISIS\";\n      const gap = outputItem?.gap_analysis || \"Check logs\";\n      const score = outputItem?.score !== undefined ? outputItem.score : 0;\n      const requirementId = outputItem?.id || null;\n\n      const validatedScore = Math.max(0, Math.min(10, parseInt(score) || 0));\n\n      if (!requirementId) {\n        console.error(`‚ùå Item ${i}.${j}: No se encontr√≥ ID del requisito en la respuesta del LLM`);\n        continue;\n      }\n\n      if (!validRequirements.includes(requirementId)) {\n        console.error(`‚ùå Item ${i}.${j}: El requirement_id ${requirementId} NO existe en rfq_items_master. Saltando...`);\n        continue;\n      }\n\n      console.log(`‚úÖ Item ${i}.${j}: Requisito ${requirementId} - ${cumple} (${validatedScore}/10)`);\n\n      resultados.push({\n        json: {\n          requirement_id: requirementId,\n          provider_name: providerName,\n          evaluation_value: cumple,\n          comment: gap,\n          score: validatedScore\n        }\n      });\n    }\n\n  } catch (error) {\n    console.error(`‚ùå Error procesando item ${i}:`, error.message);\n    continue;\n  }\n}\n\nconsole.log(`‚úÖ Procesados ${resultados.length} de ${allItems.length} items exitosamente`);\n\nreturn resultados;"
      },
      "id": "e923febc-2bfb-4e41-90fd-eb51c1dea43b",
      "name": "Parsear y Preparar Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2656,
        -1760
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### EVALUATION GROUP\n- Type: {{ $json.evaluation_type }}\n- Total requirements in this batch: {{ $json.total_requisitos }}\n- Batch: {{ $json.batch_index }} of {{ $json.total_batches }}\n\n### RFQ REQUIREMENTS (LIST)\nBelow is a list of RFQ requirements in JSON format. Each element includes the 'id' field and the requirement text.\n\n{{ JSON.stringify($json.requisitos, null, 2) }}\n\n### FULL PROPOSAL TEXT\n\n{{ $('Loop Over Items1').first().json.texto_oferta_completo }}\n---\n### TASK\nAnalyze the proposal and evaluate EACH requirement.\n\n### FOR TECHNICAL EVALUATIONS - Use these labels in 'cumple':\n- INCLUDED (10 pts)\n- INCLUDED WITH CAVEATS (8 pts)\n- PARTIALLY INCLUDED (6 pts)\n- NOT INCLUDED WITH ALTERNATIVE (3 pts)\n- NOT INCLUDED (0 pts)\n- NO INFORMATION (0 pts)\n\n### FOR ECONOMICAL EVALUATIONS - EXTRACT THE ACTUAL VALUE:\n**CRITICAL**: For economic items, the 'cumple' field must contain the ACTUAL VALUE found, not a label.\n\nFormat for 'cumple' field:\n- If value found: \"[VALUE] [CURRENCY/UNIT] - [DESCRIPTION]\"\n  Examples:\n  - \"84,3 ‚Ç¨/h - TARIFA (Process, Mechanical, Piping)\"\n  - \"312.640,62 ‚Ç¨ - PRE-FEED TOTAL BASE QUOTATION\"\n  - \"5.231,21 ‚Ç¨ - Geotechnical survey - Confirmed\"\n  - \"732.588,83 ‚Ç¨ - FEED TOTAL BASE QUOTATION\"\n  - \"97.935 ‚Ç¨ - EPC TENDER QUOTATION\"\n\n- If NO value found: \"NO VALUE FOUND - [REASON]\"\n  Examples:\n  - \"NO VALUE FOUND - 3D model not included in proposal\"\n  - \"NO VALUE FOUND - Methodology not specified\"\n  - \"NO VALUE FOUND - OPEX not quoted\"\n  - \"NO VALUE FOUND - No price for this optional\"\n\nScoring for Economic:\n- Value explicitly quoted: 10 pts\n- Hourly/daily rate given: 7 pts\n- Estimated/approximate value: 5 pts\n- Mentioned but no price: 3 pts\n- Not found: 0 pts\n\n### OUTPUT FORMAT (JSON)\n[\n  {\n    \"id\": \"<requirement id>\",\n    \"cumple\": \"[For Technical: label | For Economic: VALUE or NO VALUE FOUND]\",\n    \"gap_analysis\": \"[Quote from document or 'No mention found']\",\n    \"score\": [0-10]\n  }\n]\n\nJSON only, no explanations.",
        "messages": {
          "messageValues": [
            {
              "message": "=You are an expert auditor for EPC proposals.\n\nRULES:\n- For TECHNICAL: Use labels (INCLUDED, PARTIALLY INCLUDED, etc.)\n- For ECONOMICAL: Extract ACTUAL VALUES with currency/units (e.g., '312.640,62 ‚Ç¨ - PRE-FEED TOTAL'). If no value found: 'NO VALUE FOUND - [reason]'\n- Be conservative: when in doubt, score 0\n- ALL responses in ENGLISH\n- JSON only"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2208,
        -1888
      ],
      "id": "804b0c85-320b-4619-88ad-4480013b14c4",
      "name": "LLM Chain"
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_metadata",
          "mode": "list",
          "cachedResultName": "document_metadata"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $('Set File ID').item.json.file_id }}",
            "title": "={{ $('Set File ID').item.json.file_title }}",
            "project_name": "={{ $('Set File ID').item.json.proyect_name }}\n",
            "project_id": "={{ $('Set File ID').item.json.project_id }}",
            "evaluation_types": "={{ $('Set File ID').item.json.evaluation }}",
            "document_type": "PROPOSAL",
            "provider": "={{ $('Set File ID').item.json.proveedor }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": true,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "title",
              "displayName": "title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "project_name",
              "displayName": "project_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "document_type",
              "displayName": "document_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "provider",
              "displayName": "provider",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "evaluation_types",
              "displayName": "evaluation_types",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -96,
        -976
      ],
      "id": "a6eb624b-4d1e-4b4b-99f5-7893ec811e65",
      "name": "Insert Document Metadata",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "V0REAPph5JBLqze3",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "proposals",
        "filterType": "string",
        "filterString": "=metadata->>file_id=like.*{{ $json.file_id }}*"
      },
      "id": "d8b3b3ee-14e9-46fa-bf91-06223e0e573e",
      "name": "Delete Old Doc Rows",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -304,
        -976
      ],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "10646eae-ae46-4327-a4dc-9987c2d76173",
              "name": "file_id",
              "value": "={{ $json.body.file_id }}",
              "type": "string"
            },
            {
              "id": "77d782de-169d-4a46-8a8e-a3831c04d90f",
              "name": "file_title",
              "value": "={{ $json.body.file_title }}",
              "type": "string"
            },
            {
              "id": "9bde4d7f-e4f3-4ebd-9338-dce1350f9eab",
              "name": "file_url",
              "value": "={{ $json.body.file_url }}",
              "type": "string"
            },
            {
              "id": "b1dbe9b9-248a-4593-a769-a085b34e0810",
              "name": "file_binary",
              "value": "={{ $json.body.file_binary }}",
              "type": "string"
            },
            {
              "id": "74d93dce-cddc-4947-ae19-88bc5cacd146",
              "name": "file_metadata",
              "value": "={{ $json.body.metadata }}",
              "type": "string"
            },
            {
              "id": "5e43f8d4-b48e-4188-89c8-3723f184dbeb",
              "name": "proyect_name",
              "value": "={{ $json.body.metadata.proyecto }}",
              "type": "string"
            },
            {
              "id": "1093ebc6-8dd8-4c5d-b146-b6f01b069be6",
              "name": "proveedor",
              "value": "={{ $json.body.user_proveedor }}",
              "type": "string"
            },
            {
              "id": "6e0e6e2a-9b88-403e-aa0a-da0eecccd3f9",
              "name": "evaluation",
              "value": "={{ $json.body.metadata.tipoEvaluacion }}",
              "type": "array"
            },
            {
              "id": "project-id-uuid-field",
              "name": "project_id",
              "value": "={{ $json.body.project_id }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "943062f7-12b2-4bc8-a473-25ac3dad2e27",
      "name": "Set File ID",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -496,
        -976
      ]
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $json.text }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $json.metadata.file_id }}"
              },
              {
                "name": "file_title",
                "value": "={{ $json.metadata.file_title }}"
              },
              {
                "name": "tipo_evaluacion",
                "value": "={{ $json.metadata.tipo_evaluacion }}"
              },
              {
                "name": "proveedor",
                "value": "={{ $json.metadata.proveedor }}"
              },
              {
                "name": "project_name",
                "value": "={{ $json.metadata.project_name }}"
              },
              {
                "name": "project_id",
                "value": "={{ $json.metadata.project_id }}"
              }
            ]
          }
        }
      },
      "id": "12b16d88-a08c-48c6-964a-99874614d713",
      "name": "Default Data Loader",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        3120,
        -688
      ]
    },
    {
      "parameters": {
        "chunkSize": 1200,
        "chunkOverlap": 200,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        3024,
        -512
      ],
      "id": "400e24b8-6e21-4005-9bc0-59f5a9eac69a",
      "name": "Recursive Character Text Splitter"
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "proposals",
          "mode": "list",
          "cachedResultName": "proposals"
        },
        "options": {
          "queryName": "match_proposals"
        }
      },
      "id": "67b7fbeb-7a63-4889-a415-d6399db9bc27",
      "name": "Insert into Supabase Vectorstore",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1,
      "position": [
        2992,
        -992
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Validar Contenido PDF (FIX PAGINACI√ìN)\n// =============================================\n\nconst input = $input.first().json;\n\n// Variables de inicializaci√≥n\nlet pages = [];\nlet totalChars = 0;\nlet hasTablesDetected = false;\n\n// --- 1. PROCESAMIENTO DEL TEXTO ---\n\n// CASO A: Viene desglosado por p√°ginas (Array)\nif (input.pages && Array.isArray(input.pages) && input.pages.length > 0) {\n  pages = input.pages;\n  pages.forEach(page => {\n    const text = page.text || page.pageContent || \"\";\n    totalChars += text.length;\n    // Detecci√≥n simple de tablas\n    if ((text.match(/\\s{4,}/g) || []).length > 5) hasTablesDetected = true;\n  });\n\n// CASO B: Viene todo el texto junto (String) - ESTE ES TU CASO ACTUAL\n} else if (input.text && typeof input.text === 'string') {\n  const text = input.text;\n  totalChars = text.length;\n  // Creamos una \"p√°gina √∫nica\" contenedora para no romper el flujo\n  pages = [{ text: text, pageNumber: 1 }];\n  \n  // Detectar tablas en el texto completo\n  if ((text.match(/\\s{4,}/g) || []).length > 20) hasTablesDetected = true;\n  \n} else {\n  // CASO C: Vac√≠o\n  pages = [];\n}\n\n// --- 2. C√ÅLCULO DE P√ÅGINAS REALES (FIX CR√çTICO) ---\n\n// Intentamos leer el metadato 'numpages' que se ve en tu captura\nlet realPageCount = input.numpages || input.numPages || input.numberOfPages || 0;\n\n// Si no existe el metadato, usamos la longitud del array (fallback)\nif (!realPageCount || realPageCount === 0) {\n    realPageCount = pages.length;\n}\n\n// Si sigue siendo 1 pero el texto es enorme (>10k chars), estimamos\nif (realPageCount <= 1 && totalChars > 10000) {\n    // Estimaci√≥n conservadora: 3000 caracteres por p√°gina t√©cnica\n    realPageCount = Math.ceil(totalChars / 3000);\n}\n\n// Evitar divisi√≥n por cero\nrealPageCount = Math.max(1, realPageCount);\n\n\n// --- 3. M√âTRICAS FINALES ---\n\nconst avgCharsPerPage = totalChars / realPageCount;\n\n// CRITERIO: ¬øNecesita OCR?\n// Si hay texto (< 100 chars/pag) es probable que sea escaneado.\nconst needsOCR = avgCharsPerPage < 100; \n\n// Metadatos\nlet fileId = \"unknown\";\nlet fileTitle = \"unknown\";\ntry {\n  const metaNode = $('Set File ID').first().json;\n  fileId = metaNode.file_id;\n  fileTitle = metaNode.file_title;\n} catch (e) {}\n\n// --- LOGGING ---\nconsole.log(`üìÑ An√°lisis: ${fileTitle}`);\nconsole.log(`   ‚îú‚îÄ P√°ginas (Metadato): ${input.numpages}`); \nconsole.log(`   ‚îú‚îÄ P√°ginas (Usadas): ${realPageCount}`);\nconsole.log(`   ‚îú‚îÄ Caracteres Totales: ${totalChars}`);\nconsole.log(`   ‚îú‚îÄ Promedio/P√°g: ${Math.round(avgCharsPerPage)}`);\n\nreturn {\n  json: {\n    // M√©tricas corregidas\n    totalPages: realPageCount, // Ahora dir√° 235\n    totalChars: totalChars,\n    avgCharsPerPage: Math.round(avgCharsPerPage), // Ahora ser√° un n√∫mero razonable (~2800)\n    hasTables: hasTablesDetected,\n    needsOCR: needsOCR,\n    \n    // Contenido\n    pages: pages, \n    \n    // Metadatos\n    fileId: fileId,\n    fileName: fileTitle\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        576,
        -976
      ],
      "id": "ff05ce65-a106-45ae-902e-8b1c0f33c33d",
      "name": "Validar Contenido PDF"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        304,
        -976
      ],
      "id": "4276f42a-9d05-449a-8590-c78124b8c1a4",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "57b9c551-9997-4ed5-8ddd-f80c108a177c",
              "leftValue": "={{ $json.needsOCR }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        864,
        -976
      ],
      "id": "77f93e30-6b81-4da8-862d-b02ed5a2616d",
      "name": "¬øNecesita OCR?"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Aggregate OCR Pages (CORREGIDO)\n// =============================================\n\nconst items = $input.all();\nlet fullText = \"\";\nlet pagesArray = [];\n\n// OPCI√ìN A: Si Tesseract devuelve m√∫ltiples items (1 por p√°gina)\nif (items.length > 1) {\n  items.forEach((item, idx) => {\n    const pageText = item.json.text || \"\";\n    fullText += pageText + \"\\n\\n\";\n    \n    // Construimos array compatible con vectorstore\n    pagesArray.push({\n      text: pageText,\n      pageNumber: idx + 1\n    });\n  });\n}\n// OPCI√ìN B: Si Tesseract devuelve un solo item con todo el texto\nelse if (items.length === 1) {\n  fullText = items[0].json.text || \"\";\n  pagesArray = [{\n    text: fullText,\n    pageNumber: 1\n  }];\n}\n\n// RECUPERAR METADATOS ORIGINALES (CR√çTICO)\nlet fileId, fileName, proveedor;\ntry {\n  fileId = $('Set File ID').first().json.file_id;\n  fileName = $('Set File ID').first().json.file_title;\n  proveedor = $('Set File ID').first().json.proveedor || \"OTROS\";\n} catch (e) {\n  console.error(\"‚ö†Ô∏è No se pudieron recuperar metadatos:\", e.message);\n  fileId = \"unknown\";\n  fileName = \"unknown\";\n  proveedor = \"OTROS\";\n}\n\nconsole.log(`üîÑ OCR Agregado: ${items.length} p√°ginas ‚Üí ${fullText.length} caracteres`);\n\n// ESTRUCTURA COMPATIBLE CON VECTORSTORE\nreturn {\n  json: {\n    pages: pagesArray, // ‚Üê Array de p√°ginas (requerido por Default Data Loader)\n    text: fullText, // ‚Üê Texto completo (backup)\n    \n    // Metadatos cr√≠ticos\n    file_id: fileId,\n    file_title: fileName,\n    proveedor: proveedor,\n    \n    // Marca de origen\n    origen_datos: \"OCR_TESSERACT\",\n    ocr_pages_processed: items.length,\n    ocr_total_chars: fullText.length\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1504,
        -1088
      ],
      "id": "5004cb1f-2327-4b40-a545-356787eaca4e",
      "name": "Aggregate OCR Pages"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Texto de Muestra (STRICT LIMIT)\n// =============================================\n\nconst items = $input.all();\n\nreturn items.map(item => {\n    let texto_muestra = \"SIN TEXTO\";\n\n    try {\n        if (item.json.pages && Array.isArray(item.json.pages) && item.json.pages.length > 0) {\n            // Unimos las 2 primeras p√°ginas pero limitamos el total a 3000 caracteres\n            let rawJoin = item.json.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\");\n            texto_muestra = rawJoin.substring(0, 3000);\n        } else {\n            // Fallback extremadamente corto para texto plano\n            texto_muestra = (item.json.text || \"\").substring(0, 500);\n        }\n    } catch (e) {\n        console.error(\"Error al procesar p√°ginas:\", e);\n    }\n\n    return {\n        json: {\n            ...item.json,\n            texto_muestra: texto_muestra\n        }\n    };\n});"
      },
      "id": "7f16ab0e-95b9-4f5b-84f8-3c26c2ed78d0",
      "name": "Preparar Texto de Muestra",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1952,
        -976
      ]
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Format for Vectorstore (v3 - DIRECTO DEL USUARIO)\n// SIN clasificador ni validador LLM\n// =============================================\n\n// 1. RECUPERAR CONTENIDO\nlet fullText = \"\";\nlet totalPages = 1;\n\ntry {\n    const mergeData = $('Merge1').first().json;\n    if (mergeData.pages && mergeData.pages[0]) {\n        fullText = mergeData.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\");\n    } else {\n        fullText = mergeData.text || \"\";\n    }\n    totalPages = mergeData.totalPages || 1;\n} catch (e) {\n    console.log(\"‚ùå Error leyendo de Merge1\");\n}\n\n// 2. USAR DIRECTAMENTE DATOS DEL USUARIO (Set File ID)\nlet fileId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet proveedor = \"OTROS\";\nlet tipoEval = [\"Technical Evaluation\"];\nlet proyecto = \"\";\nlet projectId = null;\n\ntry {\n    const fileNode = $('Set File ID').first().json;\n    fileId = fileNode.file_id || \"unknown\";\n    fileTitle = fileNode.file_title || \"unknown\";\n    proveedor = fileNode.proveedor || \"OTROS\";\n    proyecto = fileNode.proyect_name || \"\";\n    projectId = fileNode.project_id || null;\n    \n    if (fileNode.evaluation && Array.isArray(fileNode.evaluation) && fileNode.evaluation.length > 0) {\n        tipoEval = fileNode.evaluation;\n    } else if (fileNode.evaluation && typeof fileNode.evaluation === 'string') {\n        tipoEval = [fileNode.evaluation];\n    }\n} catch(e) {\n    console.log(\"‚ùå Error leyendo Set File ID\");\n}\n\n// 3. GENERAR SALIDA\nreturn {\n    json: {\n        text: fullText,\n        metadata: {\n            file_id: fileId,\n            file_title: fileTitle,\n            proveedor: proveedor,\n            tipo_evaluacion: tipoEval,\n            project_name: proyecto,\n            project_id: projectId,\n            processed_at: new Date().toISOString(),\n            total_pages: totalPages\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2816,
        -992
      ],
      "id": "eeff3b60-71d9-4fdf-8e02-cc205d475dbe",
      "name": "Format for Vectorstore"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Expandir por Tipo de Evaluaci√≥n (v3 - DIRECTO DEL USUARIO)\n// SIN clasificador ni validador LLM - usa datos del usuario directamente\n// =============================================\n\n// 1. RECUPERAR TEXTO Y CONTENIDO BASE\nlet fullText = \"\";\nlet totalPages = 1;\ntry {\n    const mergeData = $('Merge1').first().json;\n    fullText = (mergeData.pages && mergeData.pages[0]) \n        ? mergeData.pages.slice(0, 2).map(p => p.text || \"\").join(\"\\n\\n\") \n        : (mergeData.text || \"\");\n    totalPages = mergeData.totalPages || 1;\n} catch (e) {\n    console.error(\"‚ùå Error leyendo Merge1\");\n}\n\n// 2. USAR DIRECTAMENTE DATOS DEL USUARIO (Set File ID)\nlet fileId = \"unknown\";\nlet proveedor = \"OTROS\";\nlet tipoEval = [\"Technical Evaluation\"];\nlet projectName = \"proyecto_sin_especificar\";\n\ntry {\n    const fileData = $('Set File ID').first().json;\n    fileId = fileData.file_id || \"unknown\";\n    proveedor = fileData.proveedor || \"OTROS\";\n    projectName = fileData.proyect_name || \"proyecto_sin_especificar\";\n    \n    // Tipos de evaluaci√≥n del usuario\n    if (fileData.evaluation && Array.isArray(fileData.evaluation) && fileData.evaluation.length > 0) {\n        tipoEval = fileData.evaluation;\n    } else if (fileData.evaluation && typeof fileData.evaluation === 'string') {\n        tipoEval = [fileData.evaluation];\n    }\n    \n    console.log(`‚úÖ Usando datos del usuario directamente:`);\n    console.log(`   Proveedor: ${proveedor}`);\n    console.log(`   Proyecto: ${projectName}`);\n    console.log(`   Tipos: ${JSON.stringify(tipoEval)}`);\n} catch (e) {\n    console.error(\"‚ùå Error leyendo Set File ID:\", e.message);\n}\n\n// 3. NORMALIZAR TIPOS\nif (!Array.isArray(tipoEval)) tipoEval = [tipoEval];\ntipoEval = tipoEval.filter(t => t && t.trim() !== \"\");\nif (tipoEval.length === 0) tipoEval = [\"Technical Evaluation\"];\n\n// 4. GENERAR FILAS\nreturn tipoEval.map((tipo, idx) => ({\n    json: {\n        tipo_evaluacion_actual: tipo,\n        proveedor_detectado: proveedor,\n        proyecto_nombre: projectName,\n        texto_oferta_completo: fullText,\n        indice_actual: idx + 1,\n        total_tipos: tipoEval.length,\n        file_id: fileId\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -848,
        -1680
      ],
      "id": "bfc20008-f85c-4f77-b9c6-82c82a1bbdb3",
      "name": "Expandir por Tipo de Evaluaci√≥n"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -544,
        -1760
      ],
      "id": "0e9f1435-d5c3-4978-bda1-eb3de666dd1e",
      "name": "Loop Over Items1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://unlaconic-ardelle-pretenceful.ngrok-free.dev/v1/convert/file",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "files",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {
          "timeout": 300000
        }
      },
      "id": "6cbb19a2-355d-434c-ba4e-7925427268cc",
      "name": "Docling OCR",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1296,
        -1184
      ],
      "retryOnFail": true
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"proveedor_detectado\": {\n      \"type\": \"string\",\n      \"description\": \"Nombre de la empresa proveedora (Ej: SACYR, IDOM, etc.)\"\n    },\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"Technical Evaluation\",\n          \"Economical Evaluation\",\n          \"Pre-FEED Deliverables\",\n          \"FEED Deliverables\"\n        ]\n      },\n      \"description\": \"Lista de tipos de oferta detectados en el documento.\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\",\n      \"description\": \"Breve explicaci√≥n de por qu√© se eligieron esos tipos.\"\n    }\n  },\n  \"required\": [\n    \"proveedor_detectado\",\n    \"tipos_detectados\"\n  ]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2608,
        -544
      ],
      "id": "fab2117f-fda9-4e3e-b7e1-35258e728fd9",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1760,
        -976
      ],
      "id": "8be48018-ae5a-4e67-a432-476c715b9f68",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => ({\n    json: {\n        ...item.json, // Mantiene todos los datos originales (incluido tipo_evaluacion)\n        \n        // Aqu√≠ est√° la correcci√≥n: Usamos dos puntos, no el igual.\n        reiniciar_bucle: true \n    }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        -1808
      ],
      "id": "8705fcfa-40a0-4197-9e5d-516268b098f8",
      "name": "Reset Items"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        -96,
        -2032
      ],
      "id": "6794f448-0a80-42a2-bec2-eb326d2e0656",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ofertas-proveedores",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -928,
        -976
      ],
      "id": "3627fc67-8297-4036-95ca-097234dc9ab9",
      "name": "Webhook",
      "webhookId": "54339356-4e6d-4e22-9820-6e1e98e167a8"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Convertir Base64 a Binary Data (CORREGIDO v3)\n// =============================================\n\n// LEER DIRECTAMENTE DEL NODO \"Set File ID\"\nlet inputData;\ntry {\n    inputData = $('Set File ID').first().json;\n} catch (e) {\n    throw new Error(\"‚ùå No se puede acceder al nodo 'Set File ID'\");\n}\n\nconst base64Data = inputData.file_binary;\n\n// --- VALIDACI√ìN CR√çTICA ---\nif (!base64Data || base64Data === \"\") {\n    console.error(\"‚ùå ERROR: file_binary est√° vac√≠o\");\n    console.error(\"Datos en 'Set File ID':\", Object.keys(inputData));\n    console.error(\"file_id:\", inputData.file_id);\n    console.error(\"file_title:\", inputData.file_title);\n    \n    throw new Error(\n        \"‚ùå CR√çTICO: 'file_binary' no existe en 'Set File ID'. \" +\n        \"Verifica la configuraci√≥n del nodo.\"\n    );\n}\n\n// Validar que sea string\nif (typeof base64Data !== 'string') {\n    throw new Error(`‚ùå ERROR: 'file_binary' debe ser string, es ${typeof base64Data}`);\n}\n\n// Logging\nconsole.log(\"‚úÖ file_binary recibido de 'Set File ID'\");\nconsole.log(`   ‚îú‚îÄ Longitud: ${base64Data.length} caracteres`);\nconsole.log(`   ‚îú‚îÄ Archivo: ${inputData.file_title}`);\n\n// Convertir base64 a binary\nlet binaryData;\ntry {\n    binaryData = Buffer.from(base64Data, 'base64');\n} catch (e) {\n    throw new Error(`‚ùå ERROR decodificando base64: ${e.message}`);\n}\n\n// Validar tama√±o\nif (binaryData.length === 0) {\n    throw new Error(\"‚ùå ERROR: Archivo decodificado vac√≠o (0 bytes)\");\n}\n\nconsole.log(`‚úÖ Binary generado: ${binaryData.length} bytes`);\n\n// Retornar formato n8n\nreturn {\n    json: {\n        file_id: inputData.file_id,\n        file_title: inputData.file_title,\n        file_url: inputData.file_url || \"unknown\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'document.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        -976
      ],
      "id": "fa25290b-7c7b-40a9-a030-1568ea466c01",
      "name": "Base64 a Binary"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Convertir Base64 a Binary Data (CORREGIDO v3)\n// =============================================\n\n// LEER DIRECTAMENTE DEL NODO \"Set File ID\"\nlet inputData;\ntry {\n    inputData = $('Set File ID').first().json;\n} catch (e) {\n    throw new Error(\"‚ùå No se puede acceder al nodo 'Set File ID'\");\n}\n\nconst base64Data = inputData.file_binary;\n\n// --- VALIDACI√ìN CR√çTICA ---\nif (!base64Data || base64Data === \"\") {\n    console.error(\"‚ùå ERROR: file_binary est√° vac√≠o\");\n    console.error(\"Datos en 'Set File ID':\", Object.keys(inputData));\n    console.error(\"file_id:\", inputData.file_id);\n    console.error(\"file_title:\", inputData.file_title);\n    \n    throw new Error(\n        \"‚ùå CR√çTICO: 'file_binary' no existe en 'Set File ID'. \" +\n        \"Verifica la configuraci√≥n del nodo.\"\n    );\n}\n\n// Validar que sea string\nif (typeof base64Data !== 'string') {\n    throw new Error(`‚ùå ERROR: 'file_binary' debe ser string, es ${typeof base64Data}`);\n}\n\n// Logging\nconsole.log(\"‚úÖ file_binary recibido de 'Set File ID'\");\nconsole.log(`   ‚îú‚îÄ Longitud: ${base64Data.length} caracteres`);\nconsole.log(`   ‚îú‚îÄ Archivo: ${inputData.file_title}`);\n\n// Convertir base64 a binary\nlet binaryData;\ntry {\n    binaryData = Buffer.from(base64Data, 'base64');\n} catch (e) {\n    throw new Error(`‚ùå ERROR decodificando base64: ${e.message}`);\n}\n\n// Validar tama√±o\nif (binaryData.length === 0) {\n    throw new Error(\"‚ùå ERROR: Archivo decodificado vac√≠o (0 bytes)\");\n}\n\nconsole.log(`‚úÖ Binary generado: ${binaryData.length} bytes`);\n\n// Retornar formato n8n\nreturn {\n    json: {\n        file_id: inputData.file_id,\n        file_title: inputData.file_title,\n        file_url: inputData.file_url || \"unknown\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'document.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        -1088
      ],
      "id": "3ef5fb76-8559-4ac1-8420-84570c0c57dc",
      "name": "Base64 a Binary1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Generate Stable ID + Detectar Modo (NOMBRES CORRECTOS)\n// =============================================\n\nfunction simpleHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(16, '0').substring(0, 16);\n}\n\nconst body = $json.body;\n\n// CAMPOS EXISTENTES\nconst originalFileId = body.file_id || \"unknown\";\nconst fileTitle = body.file_title || \"unknown.pdf\";\nconst fileBinary = body.file_binary || \"\";\nconst fileUrl = body.file_url || \"unknown\";\n\n// ‚úÖ EXTRAER METADATA DEL USUARIO (NOMBRES CORRECTOS)\nconst metadata = body.metadata || {};\nconst rfqProjectId = metadata.proyect_name || null;        // ‚Üê proyect_name\nconst userProveedor = metadata.proveedor || null;          // ‚Üê proveedor\nconst userTipoEval = metadata.evaluation || null;          // ‚Üê evaluation (Array)\n\n// ‚úÖ DETERMINAR MODO DE OPERACI√ìN\nlet modoOperacion = \"CLASIFICADOR\"; // Por defecto\nlet datosCompletos = false;\n\n// Verificar si tiene datos suficientes para VALIDACI√ìN\nif (userProveedor && userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0) {\n    modoOperacion = \"VALIDADOR\";\n    datosCompletos = true;\n} else if (userProveedor || (userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0)) {\n    modoOperacion = \"HIBRIDO\"; // Tiene algunos datos pero no todos\n}\n\n// Generar ID estable del archivo\nconst normalizedTitle = fileTitle.toLowerCase().trim();\nconst stableId = simpleHash(normalizedTitle);\n\n// LOGGING\nconsole.log(\"=== AN√ÅLISIS DE METADATA ===\");\nconsole.log(`Modo Operaci√≥n: ${modoOperacion}`);\nconsole.log(`RFQ Project Name: ${rfqProjectId || 'No especificado'}`);\nconsole.log(`Proveedor (Usuario): ${userProveedor || 'No especificado'}`);\nconsole.log(`Evaluation (Usuario): ${JSON.stringify(userTipoEval) || 'No especificado'}`);\nconsole.log(`Datos Completos: ${datosCompletos}`);\nconsole.log(`Original ID: ${originalFileId}`);\nconsole.log(`Nombre archivo: ${fileTitle}`);\nconsole.log(`ID ESTABLE generado: ${stableId}`);\n\n// RETORNO\nreturn {\n  json: {\n    // Datos directos en ra√≠z\n    file_id: stableId,\n    file_id_original: originalFileId,\n    file_title: fileTitle,\n    file_binary: fileBinary,\n    file_url: fileUrl,\n    \n    rfq_project_id: rfqProjectId || \"proyecto_sin_especificar\",\n    user_proveedor: userProveedor,\n    user_tipo_evaluacion: userTipoEval,\n    modo_operacion: modoOperacion,\n    datos_usuario_completos: datosCompletos,\n    \n    // Mantener body completo\n    body: {\n      ...body,\n      file_id: stableId,\n      file_id_original: originalFileId,\n      rfq_project_id: rfqProjectId || \"proyecto_sin_especificar\",\n      user_proveedor: userProveedor,\n      user_tipo_evaluacion: userTipoEval,\n      modo_operacion: modoOperacion,\n      datos_usuario_completos: datosCompletos\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -688,
        -976
      ],
      "id": "ca33073b-1329-4684-b931-6d9da209a0e8",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "provider_responses",
          "mode": "list",
          "cachedResultName": "provider_responses"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "provider_name": "={{ $json.provider_name }}",
            "evaluation_value": "={{ $json.evaluation_value }}",
            "comment": "={{ $json.comment }}",
            "requirement_id": "={{ $json.requirement_id }}",
            "file_id": "={{ $('Set File ID').first().json.file_id }}",
            "score": "={{ $json.score }}",
            "project_id": "={{ $('Set File ID').first().json.project_id }}",
            "updated_at": "={{ $now }}"
          },
          "matchingColumns": [
            "requirement_id",
            "provider_name"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "requirement_id",
              "displayName": "requirement_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "provider_name",
              "displayName": "provider_name",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "evaluation_value",
              "displayName": "evaluation_value",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "comment",
              "displayName": "comment",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "file_id",
              "displayName": "file_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "updated_at",
              "displayName": "updated_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false
            },
            {
              "id": "score",
              "displayName": "score",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": false
            },
            {
              "id": "project_id",
              "displayName": "project_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3168,
        -1536
      ],
      "id": "77941625-fff5-4722-8c93-af08ec9ad8d3",
      "name": "Insert or update rows in a table",
      "credentials": {
        "postgres": {
          "id": "V0REAPph5JBLqze3",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.embeddingsCohere",
      "typeVersion": 1,
      "position": [
        3040,
        -784
      ],
      "id": "50cb23c0-7658-4e3d-a8b4-8a2c90868c2e",
      "name": "Embeddings Cohere",
      "credentials": {
        "cohereApi": {
          "id": "KGv4zlUJIjLdxpnr",
          "name": "CohereApi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Todo para LLM (SIN RAG, SIN FASES)\n// Pasa TODOS los requisitos directamente al LLM\n// =============================================\n\nconst items = $input.all();\n\nconsole.log('üì• Requisitos recibidos:', items.length);\n\n// Obtener texto completo de la oferta desde Loop Over Items1\nlet textoOfertaCompleto = \"\";\nlet evaluationType = \"Technical Evaluation\";\n\ntry {\n    const loopData = $('Loop Over Items1').first().json;\n    textoOfertaCompleto = loopData.texto_oferta_completo || \"\";\n    evaluationType = loopData.tipo_evaluacion_actual || \"Technical Evaluation\";\n    console.log('‚úÖ Datos obtenidos de Loop Over Items1');\n    console.log('   ‚îú‚îÄ Tipo evaluaci√≥n:', evaluationType);\n    console.log('   ‚îî‚îÄ Texto oferta:', textoOfertaCompleto.length, 'chars');\n} catch(e) {\n    console.warn('‚ö†Ô∏è No se pudo obtener texto de oferta de Loop Over Items1:', e.message);\n    // Fallback: intentar obtener de otro lugar\n    try {\n        const expandirData = $('Expandir por Tipo de Evaluaci√≥n').first().json;\n        textoOfertaCompleto = expandirData.texto_oferta_completo || \"\";\n        evaluationType = expandirData.tipo_evaluacion_actual || \"Technical Evaluation\";\n        console.log('‚úÖ Fallback: Datos obtenidos de Expandir por Tipo de Evaluaci√≥n');\n    } catch(e2) {\n        console.error('‚ùå No se pudo obtener texto de ning√∫n nodo');\n    }\n}\n\n// Formatear TODOS los requisitos (sin batching)\nconst todosLosRequisitos = items.map(item => ({\n    id: item.json.id || \"\",\n    requirement_text: item.json.requirement_text || item.json.text || \"NO ESPECIFICADO\",\n    evaluation_type: item.json.evaluation_type || evaluationType\n}));\n\nconsole.log('üìã Preparaci√≥n directa (sin RAG ni fases):');\nconsole.log('   ‚îú‚îÄ Total requisitos:', todosLosRequisitos.length);\nconsole.log('   ‚îú‚îÄ Tipo evaluaci√≥n:', evaluationType);\nconsole.log('   ‚îî‚îÄ Tama√±o texto oferta:', textoOfertaCompleto.length, 'chars');\n\n// Retornar UN SOLO item con TODOS los requisitos\nreturn [{\n    json: {\n        evaluation_type: evaluationType,\n        requisitos: todosLosRequisitos,\n        total_requisitos: todosLosRequisitos.length,\n        batch_index: 1,\n        total_batches: 1,\n        context: textoOfertaCompleto,\n        texto_length: textoOfertaCompleto.length\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1216,
        -1888
      ],
      "id": "6309e06c-7270-40f8-abc3-b60459179072",
      "name": "Preparar Todo para LLM1"
    }
  ],
  "connections": {
    "Mistral Cloud Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Get many rows1": {
      "main": [
        [
          {
            "node": "Reset Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validador de Ofertas": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Validador de Ofertas",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser4": {
      "ai_outputParser": [
        [
          {
            "node": "Validador de Ofertas",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Clasificador de Tipo de Evaluacion y Proveedor": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Model": {
      "ai_languageModel": [
        [
          {
            "node": "Clasificador de Tipo de Evaluacion y Proveedor",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Phases": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Preparar Todo para LLM1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear y Preparar Update": {
      "main": [
        [
          {
            "node": "Insert or update rows in a table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Chain": {
      "main": [
        [
          {
            "node": "Parsear y Preparar Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Document Metadata": {
      "main": [
        [
          {
            "node": "Base64 a Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Doc Rows": {
      "main": [
        [
          {
            "node": "Insert Document Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set File ID": {
      "main": [
        [
          {
            "node": "Delete Old Doc Rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Insert into Supabase Vectorstore": {
      "main": [
        [
          {
            "node": "Expandir por Tipo de Evaluaci√≥n",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Contenido PDF": {
      "main": [
        [
          {
            "node": "¬øNecesita OCR?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Validar Contenido PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "¬øNecesita OCR?": {
      "main": [
        [
          {
            "node": "Base64 a Binary1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Aggregate OCR Pages": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Texto de Muestra": {
      "main": [
        [
          {
            "node": "Format for Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Vectorstore": {
      "main": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expandir por Tipo de Evaluaci√≥n": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items1": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get many rows1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Docling OCR": {
      "main": [
        [
          {
            "node": "Aggregate OCR Pages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Clasificador de Tipo de Evaluacion y Proveedor",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Preparar Texto de Muestra",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Items": {
      "main": [
        [
          {
            "node": "Loop Over Phases",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary1": {
      "main": [
        [
          {
            "node": "Docling OCR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Set File ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert or update rows in a table": {
      "main": [
        [
          {
            "node": "Loop Over Phases",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Cohere": {
      "ai_embedding": [
        [
          {
            "node": "Insert into Supabase Vectorstore",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Todo para LLM1": {
      "main": [
        [
          {
            "node": "LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "53140335eaf11280ef77ef2f5a378f48c2b28e822e3e0d96563cdd92175c0eff"
  }
}