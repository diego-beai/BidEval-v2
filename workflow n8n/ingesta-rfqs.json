{
  "nodes": [
    {
      "parameters": {
        "content": "### Ingesta de RFQ, actualizaci√≥n de requisitos",
        "height": 1280,
        "width": 4390,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1104,
        -304
      ],
      "id": "fd799bf2-f618-46f3-bd2c-fe3d4610e07e",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ingesta-rfq",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -992,
        -96
      ],
      "id": "1e20f158-188b-4ed1-9e6f-0661da9bc2fc",
      "name": "Webhook RFQ",
      "webhookId": "86850b01-70b4-4c99-a63a-6ccad35c0be2"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Texto (Agregador de P√°ginas)\n// =============================================\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n    return { json: { error: \"No input items received\" } };\n}\n\n// Recuperar metadatos del inicio del flujo (Generate IDs1)\nlet metadata = {};\ntry {\n    metadata = $('Generate IDs1').first().json;\n} catch (e) {\n    console.log(\"‚ö†Ô∏è No se pudo recuperar metadata de Generate IDs1\");\n}\n\n// 1. Agregado de Texto Completo (todas las p√°ginas)\n// Intentamos md_content primero (mejor para LLMs), luego text\nlet fullText = items.map(item => item.json.md_content || item.json.text || \"\").join('\\n\\n').trim();\n\nif (!fullText) {\n    console.log(\"‚ö†Ô∏è Advertencia: No se extrajo texto del documento.\");\n}\n\n// 2. Limpieza b√°sica\nfullText = fullText.replace(/\\x00/g, ''); // Eliminar caracteres nulos\n\n// 3. Preparar fragmento para clasificaci√≥n (m√°x 40k chars para no saturar context)\nconst textForClassification = fullText.substring(0, 40000);\n\nconsole.log(`‚úÖ Texto preparado: ${items.length} p√°ginas aggregadas. Chars: ${fullText.length}`);\n\nreturn {\n    json: {\n        rfq_project_id: metadata.rfq_project_id || \"unknown\",\n        rfq_document_id: metadata.rfq_document_id || \"unknown\",\n        project_name: metadata.project_name || \"Sin Nombre\",\n        file_title: metadata.file_title || \"document.pdf\",\n        text: fullText, \n        text_for_classification: textForClassification || \"SIN TEXTO DETECTADO\",\n        pages_count: items.length\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        128,
        -96
      ],
      "id": "e46eacc0-2412-44a8-87ac-5bb431929654",
      "name": "Preparar Texto1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### DOCUMENTO RFQ\n\nNombre del Archivo: {{ $json.file_title }}\nNombre Proyect: {{ $('Webhook RFQ').item.json.body.project_name }}\n### CONTENIDO (FRAGMENTO):\n{{ $json.pages ? $json.pages.slice(0, 1).map(p => p.text).join('\\n\\n') : ($json.text ? $json.text.substring(0, 2000) : 'SIN TEXTO') }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=## TAREA: CLASIFICAR TIPOS DE EVALUACI√ìN EN DOCUMENTO RFQ Y NOMBRE DEL PROYECTO\n\nEres un auditor experto en documentaci√≥n de ingenier√≠a EPC del sector energ√©tico.\nAnaliza el documento RFQ y determina qu√© tipos de evaluaci√≥n contiene y el nombre del proyecto.\n\n### IMPORTANTE\n\nUn documento puede contener 1, 2, 3 o 4 tipos de evaluaci√≥n.\n**No asumas que est√°n todos.**\nDetecta **SOLO** los que realmente est√°n presentes.\n\n### REGLA DE T√çTULO (CR√çTICA)\n**Si el nombre del archivo o el t√≠tulo del documento es \"RFQ\" o \"Request for quotation\", clasifica autom√°ticamente como \"Technical Evaluation\" Y \"Economical Evaluation\"**, ya que por definici√≥n una licitaci√≥n completa implica evaluar ambos alcances.\n\n### TIPOS POSIBLES\n\n1. **Technical Evaluation**\n\n   **Evidencia requerida:**\n   - Secciones de **Scope of Work**, **Scope of Facilities**, **Technical Requirements**\n   - Requisitos t√©cnicos generales (metodolog√≠a, normativas, est√°ndares)\n   - Descripci√≥n de alcance por fases (PRE-FEED, FEED, EPC, Conceptual, Basic Engineering, Detailed Engineering)\n   - Especificaciones de ingenier√≠a, criterios de dise√±o\n\n2. **Economical Evaluation**\n\n   **Evidencia requerida:**\n   - Tablas de **precios** o **tarifas**\n   - **Hours per discipline**, **EUR/hora**, **USD/hour**, tarifas horarias\n   - Formato de **cotizaci√≥n econ√≥mica**, **pricing schedule**\n   - **Desglose de costos por fase** o por disciplina\n   - Secciones **Commercial**, **Pricing**, **Budget**, **Cost Breakdown**\n\n3. **Pre-FEED Deliverables** (o equivalentes: Conceptual Design Deliverables, Feasibility Deliverables)\n\n   **Evidencia requerida:**\n   - Lista o tabla de documentos a entregar en fase preliminar/conceptual\n   - Organizada por **disciplinas** (Process, Mechanical, Electrical, Civil, I&C, etc.)\n   - Documentos conceptuales: **Basis of Design**, **PFDs**, **P&IDs preliminares**, **Block diagrams**\n   - Estudios: **HAZID**, **Risk Analysis**, **Site Assessment**\n   - **CAPEX Class 3‚Äì5 (AACEI)**, estimaciones preliminares (+/- 30%)\n\n4. **FEED Deliverables** (o equivalentes: Basic Engineering Deliverables)\n\n   **Evidencia requerida:**\n   - Lista o tabla de documentos a entregar en fase FEED/Basic Engineering\n   - Documentos m√°s detallados que en Pre-FEED\n   - **Especificaciones de compra**, **datasheets**, **equipment lists**\n   - **MTO** (Material Take-Off), **cable schedules**, **instrument lists**\n   - **CAPEX Class 2‚Äì3 (AACEI)**, estimaciones m√°s precisas (+/- 15%)\n   - **HAZOP**, **SIL studies**, **3D Model review**\n\n### NOMENCLATURA ALTERNATIVA\n\nEl documento puede usar nombres diferentes para las mismas fases. Aqu√≠ tienes equivalencias:\n\n| Nombre en RFQ | Clasificar como |\n|---------------|-----------------|\n| Pre-FEED, Conceptual Design, Feasibility Study, Phase 1 | Pre-FEED Deliverables |\n| FEED, Basic Engineering, Basic Design, Phase 2 | FEED Deliverables |\n| Technical Proposal, Technical Offer, Scope of Work | Technical Evaluation |\n| Commercial Proposal, Pricing, Cost Estimate, Quotation | Economical Evaluation |\n\n### C√ìMO DIFERENCIAR\n\n| Si ves... | Es probablemente... |\n| --- | --- |\n| **Scope of Work** general, **metodolog√≠a**, requisitos t√©cnicos | **Technical Evaluation** |\n| Tablas de precios, horas, **EUR/h**, tarifas | **Economical Evaluation** |\n| Lista de docs por disciplina + fase preliminar/conceptual | **Pre-FEED Deliverables** |\n| Lista de docs por disciplina + fase FEED/Basic Engineering | **FEED Deliverables** |\n\n### TAREA OBLIGATORIA: IDENTIFICAR NOMBRE DEL PROYECTO\n\nEsta tarea es **obligatoria** y **NO** puede omitirse.\n**Deber√°s devolver SIEMPRE** un valor para `nombre_proyecto`.\n\n### ORDEN DE PRIORIDAD (estricto)\n\n1. **Nombre expl√≠cito del proyecto**\n   - Busca en la **portada** o el **t√≠tulo principal**.\n   - Encabezados repetidos que contengan el nombre del proyecto.\n   - Frases como **Project**, **Project Name**, **Project Title**, **RFQ for...**\n\n2. **Nombre impl√≠cito pero oficial**\n   Si no encuentras un t√≠tulo literal, genera el nombre combinando los siguientes elementos:\n   - Tipo de instalaci√≥n energ√©tica (**Hydrogen Plant**, **PV Plant**, **Solar Plant**, **Wind Farm**, **Battery Storage**, **Power Plant**, **Electrolyzer**, **Substation**, etc.)\n   - Ubicaci√≥n (ciudad, regi√≥n o pa√≠s)\n   - Cliente o **site** si est√° claramente indicado\n   - Capacidad si se menciona (ej: 100 MW, 50 MWp, 20 MW electrolyzer)\n   - Ejemplo: **100 MW Solar PV Plant ‚Äì Andaluc√≠a, Spain**\n\n3. **Fallback obligatorio**\n   Si el documento no declara claramente un nombre:\n   - **NO dejes el campo vac√≠o**.\n   - **NO uses valores gen√©ricos**.\n   - Genera un nombre t√©cnico-descriptivo utilizando:\n     - **Formato obligatorio**: `<Tipo de Proyecto Energ√©tico> ‚Äì <Ubicaci√≥n o Cliente> (RFQ)`\n   - Ejemplo: **Green Hydrogen Production Facility ‚Äì Northern Spain (RFQ)**\n\n### REGLAS DURAS\n\n- **No usar**: Unknown, N/A, Not specified\n- **No inventar nombres comerciales**\n- El nombre debe ser v√°lido para un entorno EPC / PMO del sector energ√©tico\n- Prioriza claridad, trazabilidad y profesionalidad\n\n### FORMATO DE SALIDA (JSON PLANO ‚Äì ESTRICTO)\n\n**ATENCI√ìN: REGLAS DE ESTRUCTURA**\n1. Devuelve **√öNICAMENTE** un objeto JSON que empiece por `{` y termine por `}`.\n2. **PROHIBIDO** devolver el JSON dentro de una lista o array `[]`.\n3. **PROHIBIDO** usar claves contenedoras como `\"output\"`, `\"response\"` o `\"json\"`. El nivel ra√≠z debe tener directamente las claves `tipos_detectados` y `nombre_proyecto`.\n4. No incluyas bloques de c√≥digo markdown (\\`\\`\\`json). Solo el texto plano del JSON.\n\n**FORMATO DE SALIDA CORRECTO:**\n{\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Pre-FEED Deliverables\"],\n  \"razonamiento\": \"El documento incluye un Scope of Work t√©cnico y una lista de documentos para la fase Pre-FEED...\"\n}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        -176,
        144
      ],
      "id": "7559e381-bb36-451b-84ed-d0909e155d33",
      "name": "Clasificador de Tipos1"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        -224,
        368
      ],
      "id": "e55601a3-2366-45cc-86c0-e0a44e145f66",
      "name": "Ollama Clasificador1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\"Technical Evaluation\", \"Economical Evaluation\", \"Pre-FEED Deliverables\", \"FEED Deliverables\"]\n      }\n    },\n\"razonamiento\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"tipos_detectados\", \"nombre_proyecto\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        16,
        368
      ],
      "id": "9b342015-9d6f-4609-8673-43aa66a6aad0",
      "name": "Output Parser1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Expandir por Tipo (CORREGIDO)\n// =============================================\n\n// 1. Recuperar metadatos de nodos anteriores\nlet projectId = \"unknown\";\nlet documentId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet fullText = \"\";\nlet metadataProjectName = \"\";\n\ntry {\n    const textNode = $('Preparar Texto1').first().json;\n    projectId = textNode.rfq_project_id || \"unknown\";\n    documentId = textNode.rfq_document_id || \"unknown\";\n    fileTitle = textNode.file_title || \"unknown\";\n    fullText = textNode.text || \"\";\n    metadataProjectName = textNode.project_name || \"\"; \n} catch(e) {\n    console.log(\"‚ö†Ô∏è No se pudieron leer metadatos de Preparar Texto1\");\n}\n\n// 2. Obtener los tipos DIRECTAMENTE del Clasificador (no del input actual)\nlet tipos = [];\nlet nombreProyecto = \"\";\n\ntry {\n    const clasificadorData = $('Clasificador de Tipos1').first().json;\n    \n    // El clasificador puede devolver el output de diferentes formas\n    let output = clasificadorData.output || clasificadorData;\n    \n    // Intentar parsear si es string\n    if (typeof output === 'string') {\n        try {\n            const clean = output.replace(/```json/gi, '').replace(/```/g, '').trim();\n            const start = clean.indexOf('{');\n            const end = clean.lastIndexOf('}');\n            if (start !== -1 && end !== -1) {\n                output = JSON.parse(clean.substring(start, end + 1));\n            } else {\n                output = JSON.parse(clean);\n            }\n        } catch(e) {\n            console.log(\"‚ö†Ô∏è Error parseando output del clasificador\");\n        }\n    }\n    \n    // Extraer tipos y nombre del proyecto\n    tipos = output.tipos_detectados || [];\n    nombreProyecto = output.nombre_proyecto || \"\";\n    \n    console.log(`‚úÖ Tipos detectados por IA: ${JSON.stringify(tipos)}`);\n} catch(e) {\n    console.log(\"‚ö†Ô∏è Error recuperando datos del Clasificador de Tipos1\");\n}\n\n// 3. Validaci√≥n y fallback SOLO si NO hay tipos\nif (!Array.isArray(tipos)) tipos = [];\n\nif (tipos.length === 0) {\n    // Fallback: si el clasificador fall√≥ completamente\n    const titleLower = (fileTitle || \"\").toLowerCase();\n    const isRFQ = titleLower.includes(\"rfq\") || titleLower.includes(\"request for quotation\");\n    \n    if (isRFQ) {\n        tipos = [\"Technical Evaluation\", \"Economical Evaluation\"];\n        console.log(\"‚ö†Ô∏è Fallback: Usando tipos por defecto para RFQ\");\n    } else {\n        tipos = [\"Technical Evaluation\"];\n        console.log(\"‚ö†Ô∏è Fallback: Usando Technical Evaluation por defecto\");\n    }\n}\n\n// Eliminar duplicados\ntipos = [...new Set(tipos)];\n\n// 4. Nombre del Proyecto\nlet finalProjectName = nombreProyecto || metadataProjectName;\n\nif (!finalProjectName || finalProjectName === \"Sin Nombre\" || finalProjectName.includes(\"La Zaida\")) {\n    finalProjectName = fileTitle.replace(/\\.pdf$/i, '') + \" (Project)\";\n}\n\nconsole.log(`üìã Expandiendo ${tipos.length} tipos: ${tipos.join(', ')}`);\n\n// 5. Generar Salida (Expandir items)\nreturn tipos.map((tipo, idx) => ({\n    json: {\n        tipo_evaluacion: tipo,\n        rfq_project_id: projectId,\n        rfq_document_id: documentId,\n        nombre_proyecto: finalProjectName,\n        file_title: fileTitle,\n        texto_rfq: fullText,\n        indice: idx + 1,\n        total_tipos: tipos.length\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        784,
        144
      ],
      "id": "05163ff9-5522-480b-a533-1432b027ce68",
      "name": "Expandir por Tipo1"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        992,
        144
      ],
      "id": "1c614f6f-c31b-4454-87bb-aaaa3eab21c3",
      "name": "Loop por Tipo1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear Final (Con Nombre Proyecto)\n// =============================================\nconst inputJson = $input.first().json;\n// Asegurar que sea string\nlet llmOutput = \"\";\nif (typeof inputJson === 'string') llmOutput = inputJson;\nelse if (inputJson.text && typeof inputJson.text === 'string') llmOutput = inputJson.text;\nelse if (inputJson.output && typeof inputJson.output === 'string') llmOutput = inputJson.output;\nelse if (inputJson.content && typeof inputJson.content === 'string') llmOutput = inputJson.content;\nelse llmOutput = JSON.stringify(inputJson.text || inputJson.output || inputJson.content || inputJson);\n\nllmOutput = String(llmOutput || \"[]\");\n\n// 1. Recuperar Contexto del Loop\nlet projectId = \"unknown\";\nlet documentId = \"unknown\";\nlet tipoEvaluacion = \"Unknown\";\nlet nombreProyecto = \"Sin Nombre\";\n\ntry {\n    const loopData = $('Loop por Tipo1').first().json;\n    projectId = loopData.rfq_project_id;\n    documentId = loopData.rfq_document_id;\n    tipoEvaluacion = loopData.tipo_evaluacion;\n    nombreProyecto = loopData.nombre_proyecto || \"Sin Nombre\";\n} catch(e) {}\n\n// 2. L√≥gica de Parsing\nlet items = [];\n\ntry {\n    let clean = llmOutput.replace(/```json/gi, '').replace(/```/g, '').trim();\n    const start = clean.indexOf('[');\n    const end = clean.lastIndexOf(']');\n    if (start !== -1 && end !== -1) {\n        items = JSON.parse(clean.substring(start, end + 1));\n    }\n} catch(e) {}\n\nif (items.length === 0) {\n    const lines = llmOutput.split('\\n');\n    let currentPhase = \"General\";\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        if (/^\\d+\\./.test(line) && !line.includes('Estimate')) {\n            const text = line.replace(/^\\d+\\.\\s*/, '').trim();\n            if (i+1 < lines.length && (lines[i+1].trim().startsWith('-') || lines[i+1].trim().startsWith('‚Ä¢'))) {\n                currentPhase = text;\n            } else {\n                 items.push({ fase: \"General\", requisito_rfq: text });\n            }\n        }\n        else if (line.startsWith('-') || line.startsWith('‚Ä¢')) {\n            items.push({ fase: currentPhase, requisito_rfq: line.replace(/^[-‚Ä¢]\\s*/, '').trim() });\n        }\n    }\n}\n\nfunction generateId(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) - hash) + str.charCodeAt(i);\n        hash = hash & hash;\n    }\n    return 'item_' + Math.abs(hash).toString(16).padStart(12, '0');\n}\n\nreturn items.map(item => ({\n    json: {\n        rfq_project_id: projectId,\n        project_name: nombreProyecto,\n        rfq_document_id: documentId,\n        evaluation: tipoEvaluacion,\n        fase: item.fase || \"General\",\n        requisito_rfq: item.requisito_rfq || \"Sin Nombre\"\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        80
      ],
      "id": "239578f0-3a2a-4be8-9411-02fb2d039373",
      "name": "Parsear Items1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Agregar Resultados del Tipo Actual\n// =============================================\n\nconst items = $input.all();\n\n// Contar items insertados\nconst totalInserted = items.length;\n\n// Recuperar info del tipo actual\nlet tipoActual = \"unknown\";\ntry {\n    tipoActual = $('Loop por Tipo1').first().json.tipo_evaluacion;\n} catch(e) {}\n\nconsole.log(`‚úÖ Tipo ${tipoActual}: ${totalInserted} items insertados`);\n\nreturn {\n    json: {\n        tipo_procesado: tipoActual,\n        items_insertados: totalInserted,\n        continuar_loop: true\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3088,
        272
      ],
      "id": "09942533-1b31-43eb-b653-76c02a638d8f",
      "name": "Agregar Resultados1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Resumen Final\n// =============================================\n\n// Recuperar datos del proyecto\nlet projectId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet tiposDetectados = [];\n\ntry {\n    const projectNode = $('Generate IDs1').first().json;\n    projectId = projectNode.rfq_project_id;\n    fileTitle = projectNode.file_title;\n} catch(e) {}\n\ntry {\n    const clasificador = $('Clasificador de Tipos1').first().json;\n    const output = clasificador.output || clasificador;\n    tiposDetectados = output.tipos_detectados || [];\n} catch(e) {}\n\nconsole.log(\"========================================\");\nconsole.log(\"‚úÖ PROCESAMIENTO RFQ COMPLETADO\");\nconsole.log(`   Proyecto: ${projectId}`);\nconsole.log(`   Archivo: ${fileTitle}`);\nconsole.log(`   Tipos procesados: ${tiposDetectados.length}`);\nconsole.log(\"========================================\");\n\nreturn {\n    json: {\n        success: true,\n        rfq_project_id: projectId,\n        file_title: fileTitle,\n        tipos_procesados: tiposDetectados,\n        mensaje: `RFQ procesada correctamente. ${tiposDetectados.length} tipo(s) de evaluaci√≥n detectados y poblados.`\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2288,
        -240
      ],
      "id": "70a10156-b662-4528-8e1c-2439378c41fc",
      "name": "Resumen Final1"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        2576,
        -240
      ],
      "id": "367348f7-7583-4c13-9db8-c16ab5cd6898",
      "name": "Respond Success1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Base64 a Binary\n// =============================================\n\n// Recuperar metadatos del inicio del flujo (Generate IDs1)\nlet inputData = {};\ntry {\n    inputData = $('Generate IDs1').first().json;\n} catch (e) {\n    inputData = $json; // Fallback\n}\n\nconst base64Data = inputData.file_binary;\n\nif (!base64Data || base64Data === \"\") {\n    throw new Error(\"‚ùå CR√çTICO: 'file_binary' est√° vac√≠o\");\n}\n\nconst binaryData = Buffer.from(base64Data, 'base64');\n\nconsole.log(`‚úÖ PDF convertido: ${binaryData.length} bytes`);\n\nreturn {\n    json: {\n        rfq_project_id: inputData.rfq_project_id || \"unknown\",\n        rfq_document_id: inputData.rfq_document_id || \"unknown\",\n        project_name: inputData.project_name || \"Sin Nombre\",\n        file_title: inputData.file_title || \"document.pdf\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'rfq.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -96
      ],
      "id": "08b965b9-7bb6-47d6-b37b-d5cf0eb4b99c",
      "name": "Base64 a Binary3"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        -96,
        -96
      ],
      "id": "3eeb97ef-c3da-43d3-bc0d-fec5ee015fe9",
      "name": "Extract from File3"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Generate Stable ID + Detectar Modo (CORREGIDO)\n// Con soporte para project_id (UUID) del frontend\n// =============================================\n\nfunction simpleHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(16, '0').substring(0, 16);\n}\n\n// Aseguramos capturar el body correctamente desde el nodo anterior\nconst body = $json.body || $json;\n\n// CAMPOS B√ÅSICOS\nconst originalFileId = body.file_id || \"unknown\";\nconst fileTitle = body.file_title || \"unknown.pdf\";\nconst fileBinary = body.file_binary || \"\";\nconst fileUrl = body.file_url || \"unknown\";\n\n// ‚úÖ EXTRAER project_id (UUID) del payload del frontend\nconst projectIdFromPayload = body.project_id || null;\n\n// ‚úÖ EXTRAER METADATA DEL USUARIO\n// Usamos el operador ?. para evitar errores si metadata no existe\nconst metadata = body.metadata || {};\nconst rfqProjectName = metadata.proyect_name || body.project_name || null;\nconst userProveedor = metadata.proveedor || null;\nconst userTipoEval = metadata.evaluation || null; \n\n// ‚úÖ DETERMINAR MODO DE OPERACI√ìN\nlet modoOperacion = \"CLASIFICADOR\"; \nlet datosCompletos = false;\n\nif (userProveedor && userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0) {\n    modoOperacion = \"VALIDADOR\";\n    datosCompletos = true;\n} else if (userProveedor || (userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0)) {\n    modoOperacion = \"HIBRIDO\";\n}\n\n// Generar ID estable basado en el t√≠tulo (como pediste)\nconst normalizedTitle = fileTitle.toLowerCase().trim();\nconst stableId = simpleHash(normalizedTitle);\n\n// ID de Documento (√∫nico por contenido para evitar duplicados en Supabase)\nconst documentId = 'doc_' + stableId;\n\nconsole.log('üìã Generate IDs - project_id from frontend:', projectIdFromPayload);\n\nreturn {\n  json: {\n    file_id: stableId, // Este es tu ID estable\n    rfq_document_id: documentId,\n    file_id_original: originalFileId,\n    file_title: fileTitle,\n    file_binary: fileBinary,\n    file_url: fileUrl,\n    \n    // ‚úÖ project_id (UUID) real del frontend - usado para filtrar por proyecto\n    project_id: projectIdFromPayload,\n    \n    // Si no hay nombre de proyecto, usamos el nombre del archivo como fallback\n    project_name: rfqProjectName || fileTitle.replace(/\\.[^/.]+$/, \"\"),\n    rfq_project_id: projectIdFromPayload || (rfqProjectName ? 'proj_' + simpleHash(rfqProjectName.toLowerCase().trim()) : 'proj_generic'),\n    \n    user_proveedor: userProveedor,\n    user_tipo_evaluacion: userTipoEval,\n    modo_operacion: modoOperacion,\n    datos_usuario_completos: datosCompletos,\n    \n    // Guardamos una copia limpia para los nodos siguientes\n    metadata_limpia: {\n        proyect_name: rfqProjectName,\n        proveedor: userProveedor,\n        evaluation: userTipoEval\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -768,
        -96
      ],
      "id": "247e7f0d-83c8-4c0a-b1ab-23ebb11bcfea",
      "name": "Generate IDs1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.tipo_evaluacion }}",
                    "rightValue": "Evaluation",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "c3ac36b0-dcd7-4e84-a72a-7e88b6f2fc2a"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "529ee554-7a05-413a-9782-710d0deb6365",
                    "leftValue": "={{ $json.tipo_evaluacion }}",
                    "rightValue": "Deliverables",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        1888,
        272
      ],
      "id": "0027e70f-d5e7-4a92-b5ba-bd94ab6d1094",
      "name": "Switch1"
    },
    {
      "parameters": {
        "model": "qwen3:8b",
        "options": {
          "temperature": 0.1,
          "numCtx": 8192,
          "numPredict": 2048
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2144,
        720
      ],
      "id": "364078e4-795c-4421-8490-327445204c7e",
      "name": "Ollama Extractor2",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### TAREA: EXTRACCI√ìN MASIVA DE ENTREGABLES (DELIVERABLES)\n\n**OBJETIVO:** Extraer **TODOS** los documentos, planos y entregables listados. **EXHAUSTIVIDAD TOTAL**.\n\n### INSTRUCCIONES CR√çTICAS (NO RESUMIR):\n1. **TABLAS:** Si encuentras una tabla, extrae **CADA FILA**. Si hay 140 filas, devuelve 140 √≠tems.\n2. **NO AGRUPES:** Mant√©n la granularidad.\n3. **FASES:** Infiere la fase/disciplina. Si no, usa 'General'.\n\n### EXTRACCI√ìN DE LISTA DE ENTREGABLES (TEXTO DESORDENADO)\n\n### EXTRACCI√ìN DE LISTA DE ENTREGABLES (TEXTO DESORDENADO)\n\nProyecto: {{ $json.nombre_proyecto }}\nEvaluaci√≥n: {{ $('Loop por Tipo1').item.json.tipo_evaluacion }}\nArchivo: {{ $('Generate IDs1').first().json.file_title }}\n\n### TEXTO DEL PDF:\n{{ $json.texto_chunk }}\n\n### FORMATO DE SALIDA:\n```json\n[\n  { \"fase\": \"Process\", \"requisito_rfq\": \"PFD\" },\n  { \"fase\": \"Civil\", \"requisito_rfq\": \"Foundation Layout\" }\n]\n```\n\n**RESPUESTA (JSON PURO):**",
        "messages": {
          "messageValues": [
            {
              "message": "=Eres una API que devuelve JSON. \n- NO saludes.\n- NO expliques.\n- NO uses markdown fuera del JSON.\n- Tu salida DEBE empezar con `[` y terminar con `]`."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2208,
        496
      ],
      "id": "73180c46-8f86-4398-9296-3f1bd8e3356f",
      "name": "LLM Extractor - Deliverables"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear Deliverables (ROBUST FALLBACK)\n// =============================================\n\nconst inputJson = $input.first().json;\n\n// 1. RECOGIDA DE DATOS RAW\nlet rawOutput = \"\";\nif (inputJson.output && typeof inputJson.output === 'string') rawOutput = inputJson.output;\nelse if (inputJson.text && typeof inputJson.text === 'string') rawOutput = inputJson.text;\nelse if (inputJson.content && typeof inputJson.content === 'string') rawOutput = inputJson.content;\nelse if (typeof inputJson === 'string') rawOutput = inputJson;\n\n// 2. INTENTO A: EXTRAER JSON\nlet items = [];\ntry {\n    const clean = rawOutput.replace(/```json/gi, '').replace(/```/g, '').trim();\n    const start = clean.indexOf('[');\n    const end = clean.lastIndexOf(']');\n    if (start !== -1 && end !== -1) {\n        items = JSON.parse(clean.substring(start, end + 1));\n    }\n} catch(e) {}\n\n// 3. INTENTO B: FALLBACK DE LISTA\nif (items.length === 0 && rawOutput) {\n    const lines = rawOutput.split('\\n');\n    let currentPhase = \"General\";\n    lines.forEach(line => {\n        const trimmed = line.trim();\n        if (!trimmed) return;\n        const numberMatch = trimmed.match(/^\\d+\\.\\s*(.*)/);\n        const bulletMatch = trimmed.match(/^[-‚Ä¢*]\\s*(.*)/);\n        if (numberMatch) {\n            items.push({ fase: currentPhase, requisito_rfq: numberMatch[1] });\n        } else if (bulletMatch) {\n             items.push({ fase: currentPhase, requisito_rfq: bulletMatch[1] });\n        }\n    });\n}\n\n// 4. HELPER: GENERAR ID ESTABLE\nfunction generateId(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) - hash) + str.charCodeAt(i);\n        hash = hash & hash;\n    }\n    return 'item_' + Math.abs(hash).toString(16).padStart(12, '0');\n}\n\n// 5. NORMALIZAR Y RETORNAR\nlet loopCtx = {};\ntry {\n   const outerLoop = $('Loop por Tipo1').first().json;\n   loopCtx = {\n       rfq_project_id: outerLoop.rfq_project_id,\n       rfq_document_id: outerLoop.rfq_document_id,\n       project_name: outerLoop.nombre_proyecto,\n       tipo_evaluacion: outerLoop.tipo_evaluacion\n   };\n} catch(e){}\n\nreturn items.map(item => {\n    const phase = item.fase || \"General\";\n    const req = item.requisito_rfq || \"Sin Nombre\";\n    return {\n        json: {\n            rfq_project_id: loopCtx.rfq_project_id || \"unknown\",\n            rfq_document_id: loopCtx.rfq_document_id || \"unknown\",\n            project_name: loopCtx.project_name || \"Unknown\",\n            evaluation: loopCtx.tipo_evaluacion || \"Deliverables\",\n            fase: phase,\n            requisito_rfq: req\n        }\n    };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        496
      ],
      "id": "4d086a76-7263-48c7-8769-8a51deb28666",
      "name": "Parsear deliverables"
    },
    {
      "parameters": {
        "model": "qwen3:8b",
        "options": {
          "temperature": 0.1,
          "numCtx": 8192,
          "numPredict": 2048
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2144,
        272
      ],
      "id": "4cefb136-ad7b-4bfd-821c-02a3460a213e",
      "name": "Ollama Extractor1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"fase\": {\n        \"type\": \"string\",\n        \"description\": \"Nombre de la disciplina o √°rea (ej: Process Engineering, Mechanical Engineering, Civil and Structural, Electrical Engineering, etc.)\"\n      },\n      \"requisito_rfq\": {\n        \"type\": \"string\",\n        \"description\": \"Nombre del documento o entregable espec√≠fico\"\n      }\n    },\n    \"required\": [\"fase\", \"requisito_rfq\"]\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2448,
        704
      ],
      "id": "3fd27669-16f0-4c67-a08a-25991b3db94b",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"fase\": {\n        \"type\": \"string\",\n        \"description\": \"Fase del proyecto o disciplina (ej: PRE-FEED, FEED, EPC, Process Engineering, etc.)\"\n      },\n      \"requisito_rfq\": {\n        \"type\": \"string\",\n        \"description\": \"Requisito t√©cnico o econ√≥mico espec√≠fico\"\n      }\n    },\n    \"required\": [\"fase\", \"requisito_rfq\"]\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2384,
        272
      ],
      "id": "bf1fbfb4-0c93-482a-aee5-936f4447a6ee",
      "name": "Structured Output Parser2"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Dividir en Trozos (Chunking)\n// =============================================\n\nconst input = $input.first().json;\nconst fullText = input.texto_rfq || \"\";\n\n// OPTIMIZADO: Chunks m√°s peque√±os para procesamiento m√°s r√°pido\n// ~6000 caracteres (aprox 1.5k-2k tokens) = respuestas en 10-15 seg\nconst chunkSize = 6000;\nconst overlap = 400;\nconst chunks = [];\n\nif (fullText.length <= chunkSize) {\n    chunks.push({\n        ...input,\n        texto_chunk: fullText,\n        chunk_index: 1,\n        total_chunks: 1\n    });\n} else {\n    let start = 0;\n    while (start < fullText.length) {\n        let end = start + chunkSize;\n        let chunk = fullText.substring(start, end);\n        \n        chunks.push({\n            ...input,\n            texto_chunk: chunk,\n            chunk_index: chunks.length + 1\n        });\n\n        start += (chunkSize - overlap);\n        if (start >= fullText.length) break;\n    }\n    chunks.forEach(c => c.total_chunks = chunks.length);\n}\n\nreturn chunks;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1280,
        256
      ],
      "id": "0e566018-2fe0-4f48-a281-421c3af4c3eb",
      "name": "Dividir en Trozos1"
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.reiniciar_bucle ? true : false }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1632,
        256
      ],
      "id": "ff1dbc0b-fa5f-4431-80cc-2ed422fee6cf",
      "name": "Loop por Trozo1"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => ({\n    json: {\n        ...item.json, // Mantiene todos los datos originales (incluido tipo_evaluacion)\n        \n        // Aqu√≠ est√° la correcci√≥n: Usamos dos puntos, no el igual.\n        reiniciar_bucle: true \n    }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        256
      ],
      "id": "24dee0e5-951c-4182-8bee-494011553f9f",
      "name": "Reset Items1"
    },
    {
      "parameters": {
        "model": "qwen3-embedding:8b"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        352,
        368
      ],
      "id": "9e63cb1f-6386-4e96-9368-2d0b1964080e",
      "name": "Embeddings Ollama1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "rfq",
          "mode": "list",
          "cachedResultName": "rfq"
        },
        "options": {
          "queryName": "match_rfq"
        }
      },
      "id": "2b7261b1-89d3-4f54-a52f-a6d21bc4075d",
      "name": "Insert into Supabase Vectorstore1",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1,
      "position": [
        432,
        144
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "chunkSize": 800,
        "chunkOverlap": 150,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        608,
        576
      ],
      "id": "f0ff3957-c0b1-48df-b751-6d1be8c9147d",
      "name": "Recursive Character Text Splitter1"
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $('Preparar Texto1').item.json.text_for_classification }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $('Generate IDs1').first().json.rfq_document_id }}"
              },
              {
                "name": "file_title",
                "value": "={{ $('Generate IDs1').first().json.file_title }}"
              },
              {
                "name": "tipo_evaluacion",
                "value": "={{ $('Clasificador de Tipos1').item.json.output.tipos_detectados }}"
              },
              {
                "name": "tipo-doc",
                "value": "RFQ"
              }
            ]
          }
        }
      },
      "id": "2a5def6d-d0f9-47e8-9c9f-879e1cd886a6",
      "name": "Default Data Loader1",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        528,
        368
      ]
    },
    {
      "parameters": {
        "tableId": "rfq_items_master",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "project_name",
              "fieldValue": "={{ $('Webhook RFQ').first().json.body.project_name }}"
            },
            {
              "fieldId": "project_id",
              "fieldValue": "={{ $('Generate IDs1').first().json.project_id }}"
            },
            {
              "fieldId": "evaluation_type",
              "fieldValue": "={{ $json.evaluation }}"
            },
            {
              "fieldId": "phase",
              "fieldValue": "={{ $json.fase }}"
            },
            {
              "fieldId": "requirement_text",
              "fieldValue": "={{ $json.requisito_rfq }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2880,
        272
      ],
      "id": "141c004e-a0d8-4a83-9b58-9b1ee9ca8f06",
      "name": "Create a row",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "rfq",
        "filterType": "string",
        "filterString": "=metadata->>file_id=like.*{{ $json.file_id }}*"
      },
      "id": "61ab864b-c90a-490a-981f-7e2424667f95",
      "name": "Delete Old Doc Rows1",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -544,
        -96
      ],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_metadata",
          "mode": "list",
          "cachedResultName": "document_metadata"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $('Generate IDs1').first().json.rfq_document_id }}",
            "title": "={{ $('Generate IDs1').first().json.file_title }}",
            "project_name": "={{ $('Webhook RFQ').item.json.body.project_name }}",
            "document_type": "=RFQ",
            "evaluation_types": "={{ $json.output.tipos_detectados }}",
            "provider": "IGNIS"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": true,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "title",
              "displayName": "title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "project_name",
              "displayName": "project_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "document_type",
              "displayName": "document_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "provider",
              "displayName": "provider",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "evaluation_types",
              "displayName": "evaluation_types",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        208,
        144
      ],
      "id": "241c1538-006a-43bd-8a9e-d912201209b6",
      "name": "Insert Document Metadata2",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "V0REAPph5JBLqze3",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### EXTRACCI√ìN DE REQUISITOS RFQ - SOLO √çTEMS EXPL√çCITOS\n\nProyecto: {{ $json.nombre_proyecto }}\nTipo: {{ $json.tipo_evaluacion }}\nArchivo: {{ $json.file_title }}\n\n### TEXTO:\n{{ $json.texto_chunk }}\n\n---\n### INSTRUCCIONES:\n\n**SOLO EXTRAER √çTEMS QUE APARECEN CLARAMENTE EN LISTAS, TABLAS O COMO REQUISITOS EXPL√çCITOS**\n\n#### Para Technical Evaluation:\n- Buscar: \"The vendor shall provide/submit/deliver...\"\n- Buscar: Listas de documentos, entregables o planos\n- NO extraer: Descripciones generales, introducciones, alcance\n\n#### Para Economical Evaluation:  \n- Buscar: \"Item\", \"Line item\", tablas de precios, BOQ\n- Buscar: Partidas espec√≠ficas a cotizar\n- NO extraer: Textos descriptivos sin √≠tems concretos\n\n### REGLAS ESTRICTAS:\n1. **M√çNIMO**: Extraer solo lo que es claramente un requisito/lista\n2. **CONCRETO**: Un √≠tem por cada l√≠nea de lista/tabla\n3. **ESPEC√çFICO**: Si hay duda, NO extraer\n\n### FORMATO:\n```json\n[\n  { \"fase\": \"Disciplina\", \"requisito_rfq\": \"√çtem exacto del texto\" }\n]\n```\n\n**RESPUESTA:**",
        "messages": {
          "messageValues": [
            {
              "message": "=Eres un Extractor de Requisitos de Ingenier√≠a. Tu trabajo es poblar la base de datos maestra de requisitos del proyecto.\nNO inventes datos.\nNO resumas.\nUsa JSON estricto."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2192,
        80
      ],
      "id": "ff5a2167-8df6-417e-8acd-1702309dcf11",
      "name": "LLM Extractor Tech-Econ"
    },
    {
      "parameters": {
        "model": "mistral-large-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        2256,
        256
      ],
      "id": "a68e819e-b97f-4d44-b426-3e59baf2aa59",
      "name": "Mistral Cloud Chat Model7",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {
        "model": "mistral-large-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        2272,
        704
      ],
      "id": "49b9eaa4-d664-4ba7-b901-65cd86555cbe",
      "name": "Mistral Cloud Chat Model8",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        -144,
        496
      ],
      "id": "1442254f-cd8d-446a-92ff-545c92a85574",
      "name": "Mistral Cloud Chat Model9",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    }
  ],
  "connections": {
    "Webhook RFQ": {
      "main": [
        [
          {
            "node": "Generate IDs1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Texto1": {
      "main": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clasificador de Tipos1": {
      "main": [
        [
          {
            "node": "Insert Document Metadata2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Clasificador1": {
      "ai_languageModel": [
        []
      ]
    },
    "Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Expandir por Tipo1": {
      "main": [
        [
          {
            "node": "Loop por Tipo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop por Tipo1": {
      "main": [
        [
          {
            "node": "Resumen Final1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Dividir en Trozos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear Items1": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agregar Resultados1": {
      "main": [
        [
          {
            "node": "Loop por Trozo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resumen Final1": {
      "main": [
        [
          {
            "node": "Respond Success1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary3": {
      "main": [
        [
          {
            "node": "Extract from File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File3": {
      "main": [
        [
          {
            "node": "Preparar Texto1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate IDs1": {
      "main": [
        [
          {
            "node": "Delete Old Doc Rows1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "LLM Extractor Tech-Econ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "LLM Extractor - Deliverables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Extractor2": {
      "ai_languageModel": [
        []
      ]
    },
    "LLM Extractor - Deliverables": {
      "main": [
        [
          {
            "node": "Parsear deliverables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear deliverables": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Extractor1": {
      "ai_languageModel": [
        []
      ]
    },
    "Dividir en Trozos1": {
      "main": [
        [
          {
            "node": "Reset Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop por Trozo1": {
      "main": [
        [
          {
            "node": "Loop por Tipo1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Items1": {
      "main": [
        [
          {
            "node": "Loop por Trozo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Ollama1": {
      "ai_embedding": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Insert into Supabase Vectorstore1": {
      "main": [
        [
          {
            "node": "Expandir por Tipo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter1": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader1",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader1": {
      "ai_document": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Create a row": {
      "main": [
        [
          {
            "node": "Agregar Resultados1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Doc Rows1": {
      "main": [
        [
          {
            "node": "Base64 a Binary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Document Metadata2": {
      "main": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Extractor Tech-Econ": {
      "main": [
        [
          {
            "node": "Parsear Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral Cloud Chat Model7": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Extractor Tech-Econ",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Mistral Cloud Chat Model8": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Extractor - Deliverables",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Mistral Cloud Chat Model9": {
      "ai_languageModel": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "53140335eaf11280ef77ef2f5a378f48c2b28e822e3e0d96563cdd92175c0eff"
  }
}