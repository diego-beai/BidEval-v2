{
  "nodes": [
    {
      "parameters": {
        "content": "### Ingesta de RFQ, actualizaci√≥n de requisitos",
        "height": 1280,
        "width": 4390,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -928,
        -96
      ],
      "id": "a2e8ab8f-82d4-4e03-8f9a-ee6de6ab16f4",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ingesta-rfq",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -816,
        112
      ],
      "id": "60d2ff85-9939-4a54-8d88-5c57eb7c0984",
      "name": "Webhook RFQ",
      "webhookId": "ce591645-290f-46ab-a153-0dca369b1ebd"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Texto (Agregador de P√°ginas)\n// =============================================\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n    return { json: { error: \"No input items received\" } };\n}\n\n// Recuperar metadatos del inicio del flujo (Generate IDs1)\nlet metadata = {};\ntry {\n    metadata = $('Generate IDs1').first().json;\n} catch (e) {\n    console.log(\"‚ö†Ô∏è No se pudo recuperar metadata de Generate IDs1\");\n}\n\n// 1. Agregado de Texto Completo (todas las p√°ginas)\n// Intentamos md_content primero (mejor para LLMs), luego text\nlet fullText = items.map(item => item.json.md_content || item.json.text || \"\").join('\\n\\n').trim();\n\nif (!fullText) {\n    console.log(\"‚ö†Ô∏è Advertencia: No se extrajo texto del documento.\");\n}\n\n// 2. Limpieza b√°sica\nfullText = fullText.replace(/\\x00/g, ''); // Eliminar caracteres nulos\n\n// 3. Preparar fragmento para clasificaci√≥n (m√°x 40k chars para no saturar context)\nconst textForClassification = fullText.substring(0, 40000);\n\nconsole.log(`‚úÖ Texto preparado: ${items.length} p√°ginas aggregadas. Chars: ${fullText.length}`);\n\nreturn {\n    json: {\n        rfq_project_id: metadata.rfq_project_id || \"unknown\",\n        rfq_document_id: metadata.rfq_document_id || \"unknown\",\n        project_name: metadata.project_name || \"Sin Nombre\",\n        file_title: metadata.file_title || \"document.pdf\",\n        text: fullText, \n        text_for_classification: textForClassification || \"SIN TEXTO DETECTADO\",\n        pages_count: items.length\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        304,
        112
      ],
      "id": "7b5bd344-3ca0-4864-9f9e-1c4e030ec37c",
      "name": "Preparar Texto1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### DOCUMENTO RFQ\n\nNombre del Archivo: {{ $json.file_title }}\n\n### CONTENIDO (FRAGMENTO):\n{{ $json.pages ? $json.pages.slice(0, 1).map(p => p.text).join('\\n\\n') : ($json.text ? $json.text.substring(0, 2000) : 'SIN TEXTO') }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=## TAREA: CLASIFICAR TIPOS DE EVALUACI√ìN EN DOCUMENTO RFQ Y NOMBRE DEL PROYECTO\n\nEres un auditor experto en documentaci√≥n de ingenier√≠a EPC del sector energ√©tico.\nAnaliza el documento RFQ y determina qu√© tipos de evaluaci√≥n contiene y el nombre del proyecto.\n\n### IMPORTANTE\n\nUn documento puede contener 1, 2, 3 o 4 tipos de evaluaci√≥n.\n**No asumas que est√°n todos.**\nDetecta **SOLO** los que realmente est√°n presentes.\n\n### REGLA DE T√çTULO (CR√çTICA)\n**Si el nombre del archivo o el t√≠tulo del documento es \"RFQ\" o \"Request for quotation\", clasifica autom√°ticamente como \"Technical Evaluation\" Y \"Economical Evaluation\"**, ya que por definici√≥n una licitaci√≥n completa implica evaluar ambos alcances.\n\n### TIPOS POSIBLES\n\n1. **Technical Evaluation**\n\n   **Evidencia requerida:**\n   - Secciones de **Scope of Work**, **Scope of Facilities**, **Technical Requirements**\n   - Requisitos t√©cnicos generales (metodolog√≠a, normativas, est√°ndares)\n   - Descripci√≥n de alcance por fases (PRE-FEED, FEED, EPC, Conceptual, Basic Engineering, Detailed Engineering)\n   - Especificaciones de ingenier√≠a, criterios de dise√±o\n\n2. **Economical Evaluation**\n\n   **Evidencia requerida:**\n   - Tablas de **precios** o **tarifas**\n   - **Hours per discipline**, **EUR/hora**, **USD/hour**, tarifas horarias\n   - Formato de **cotizaci√≥n econ√≥mica**, **pricing schedule**\n   - **Desglose de costos por fase** o por disciplina\n   - Secciones **Commercial**, **Pricing**, **Budget**, **Cost Breakdown**\n\n3. **Pre-FEED Deliverables** (o equivalentes: Conceptual Design Deliverables, Feasibility Deliverables)\n\n   **Evidencia requerida:**\n   - Lista o tabla de documentos a entregar en fase preliminar/conceptual\n   - Organizada por **disciplinas** (Process, Mechanical, Electrical, Civil, I&C, etc.)\n   - Documentos conceptuales: **Basis of Design**, **PFDs**, **P&IDs preliminares**, **Block diagrams**\n   - Estudios: **HAZID**, **Risk Analysis**, **Site Assessment**\n   - **CAPEX Class 3‚Äì5 (AACEI)**, estimaciones preliminares (+/- 30%)\n\n4. **FEED Deliverables** (o equivalentes: Basic Engineering Deliverables)\n\n   **Evidencia requerida:**\n   - Lista o tabla de documentos a entregar en fase FEED/Basic Engineering\n   - Documentos m√°s detallados que en Pre-FEED\n   - **Especificaciones de compra**, **datasheets**, **equipment lists**\n   - **MTO** (Material Take-Off), **cable schedules**, **instrument lists**\n   - **CAPEX Class 2‚Äì3 (AACEI)**, estimaciones m√°s precisas (+/- 15%)\n   - **HAZOP**, **SIL studies**, **3D Model review**\n\n### NOMENCLATURA ALTERNATIVA\n\nEl documento puede usar nombres diferentes para las mismas fases. Aqu√≠ tienes equivalencias:\n\n| Nombre en RFQ | Clasificar como |\n|---------------|-----------------|\n| Pre-FEED, Conceptual Design, Feasibility Study, Phase 1 | Pre-FEED Deliverables |\n| FEED, Basic Engineering, Basic Design, Phase 2 | FEED Deliverables |\n| Technical Proposal, Technical Offer, Scope of Work | Technical Evaluation |\n| Commercial Proposal, Pricing, Cost Estimate, Quotation | Economical Evaluation |\n\n### C√ìMO DIFERENCIAR\n\n| Si ves... | Es probablemente... |\n| --- | --- |\n| **Scope of Work** general, **metodolog√≠a**, requisitos t√©cnicos | **Technical Evaluation** |\n| Tablas de precios, horas, **EUR/h**, tarifas | **Economical Evaluation** |\n| Lista de docs por disciplina + fase preliminar/conceptual | **Pre-FEED Deliverables** |\n| Lista de docs por disciplina + fase FEED/Basic Engineering | **FEED Deliverables** |\n\n### TAREA OBLIGATORIA: IDENTIFICAR NOMBRE DEL PROYECTO\n\nEsta tarea es **obligatoria** y **NO** puede omitirse.\n**Deber√°s devolver SIEMPRE** un valor para `nombre_proyecto`.\n\n### ORDEN DE PRIORIDAD (estricto)\n\n1. **Nombre expl√≠cito del proyecto**\n   - Busca en la **portada** o el **t√≠tulo principal**.\n   - Encabezados repetidos que contengan el nombre del proyecto.\n   - Frases como **Project**, **Project Name**, **Project Title**, **RFQ for...**\n\n2. **Nombre impl√≠cito pero oficial**\n   Si no encuentras un t√≠tulo literal, genera el nombre combinando los siguientes elementos:\n   - Tipo de instalaci√≥n energ√©tica (**Hydrogen Plant**, **PV Plant**, **Solar Plant**, **Wind Farm**, **Battery Storage**, **Power Plant**, **Electrolyzer**, **Substation**, etc.)\n   - Ubicaci√≥n (ciudad, regi√≥n o pa√≠s)\n   - Cliente o **site** si est√° claramente indicado\n   - Capacidad si se menciona (ej: 100 MW, 50 MWp, 20 MW electrolyzer)\n   - Ejemplo: **100 MW Solar PV Plant ‚Äì Andaluc√≠a, Spain**\n\n3. **Fallback obligatorio**\n   Si el documento no declara claramente un nombre:\n   - **NO dejes el campo vac√≠o**.\n   - **NO uses valores gen√©ricos**.\n   - Genera un nombre t√©cnico-descriptivo utilizando:\n     - **Formato obligatorio**: `<Tipo de Proyecto Energ√©tico> ‚Äì <Ubicaci√≥n o Cliente> (RFQ)`\n   - Ejemplo: **Green Hydrogen Production Facility ‚Äì Northern Spain (RFQ)**\n\n### REGLAS DURAS\n\n- **No usar**: Unknown, N/A, Not specified\n- **No inventar nombres comerciales**\n- El nombre debe ser v√°lido para un entorno EPC / PMO del sector energ√©tico\n- Prioriza claridad, trazabilidad y profesionalidad\n\n### FORMATO DE SALIDA (JSON PLANO ‚Äì ESTRICTO)\n\n**ATENCI√ìN: REGLAS DE ESTRUCTURA**\n1. Devuelve **√öNICAMENTE** un objeto JSON que empiece por `{` y termine por `}`.\n2. **PROHIBIDO** devolver el JSON dentro de una lista o array `[]`.\n3. **PROHIBIDO** usar claves contenedoras como `\"output\"`, `\"response\"` o `\"json\"`. El nivel ra√≠z debe tener directamente las claves `tipos_detectados` y `nombre_proyecto`.\n4. No incluyas bloques de c√≥digo markdown (\\`\\`\\`json). Solo el texto plano del JSON.\n\n**FORMATO DE SALIDA CORRECTO:**\n{\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Pre-FEED Deliverables\"],\n  \"nombre_proyecto\": \"Hydrogen Production Plant ‚Äì La Zaida, Spain\",\n  \"razonamiento\": \"El documento incluye un Scope of Work t√©cnico y una lista de documentos para la fase Pre-FEED...\"\n}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        0,
        336
      ],
      "id": "ba3ccaac-bc51-42d3-bf3d-b1cc7d852a45",
      "name": "Clasificador de Tipos1"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        -48,
        560
      ],
      "id": "db5a3d4a-5f8c-4f2e-8393-9a2e186396b7",
      "name": "Ollama Clasificador1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\"Technical Evaluation\", \"Economical Evaluation\", \"Pre-FEED Deliverables\", \"FEED Deliverables\"]\n      }\n    },\n    \"nombre_proyecto\": {\n      \"type\": \"string\",\n      \"description\": \"Nombre del proyecto extra√≠do del documento RFQ\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"tipos_detectados\", \"nombre_proyecto\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        192,
        560
      ],
      "id": "67adb36c-691d-40ae-9e6e-2ba29d56e7e4",
      "name": "Output Parser1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Expandir por Tipo (CORREGIDO v3)\n// =============================================\n\n// 1. Recuperar metadatos de nodos anteriores\nlet projectId = \"unknown\";\nlet documentId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet fullText = \"\";\nlet metadataProjectName = \"\";\n\ntry {\n    const textNode = $('Preparar Texto1').first().json;\n    projectId = textNode.rfq_project_id || \"unknown\";\n    documentId = textNode.rfq_document_id || \"unknown\";\n    fileTitle = textNode.file_title || \"unknown\";\n    fullText = textNode.text || \"\";\n    metadataProjectName = textNode.project_name || \"\"; \n} catch(e) {\n    console.log(\"‚ö†Ô∏è No se pudieron leer metadatos de Preparar Texto1\");\n}\n\n// 2. OBTENER DATOS DEL CLASIFICADOR DIRECTAMENTE\nlet output = {\n    tipos_detectados: [],\n    nombre_proyecto: \"\"\n};\n\ntry {\n    const clasificadorData = $('Clasificador de Tipos1').first().json;\n    console.log(\"üìä Datos del clasificador:\", JSON.stringify(clasificadorData));\n    \n    // El Output Parser devuelve los datos en .output\n    if (clasificadorData.output && Array.isArray(clasificadorData.output.tipos_detectados)) {\n        output = clasificadorData.output;\n        console.log(\"‚úÖ CASO A: Datos en .output\");\n    } else if (Array.isArray(clasificadorData.tipos_detectados)) {\n        output = clasificadorData;\n        console.log(\"‚úÖ CASO B: Datos directos\");\n    } else {\n        let rawText = clasificadorData.output || clasificadorData.text || JSON.stringify(clasificadorData);\n        if (typeof rawText !== 'string') rawText = JSON.stringify(rawText);\n        \n        const clean = rawText.replace(/```json/gi, '').replace(/```/g, '').trim();\n        const start = clean.indexOf('{');\n        const end = clean.lastIndexOf('}');\n        \n        if (start !== -1 && end !== -1) {\n            output = JSON.parse(clean.substring(start, end + 1));\n            console.log(\"‚úÖ CASO C: Parseado manual\");\n        }\n    }\n} catch (e) {\n    console.log(\"‚ö†Ô∏è Error accediendo al Clasificador:\", e.message);\n}\n\n// 3. Normalizaci√≥n de Datos\nlet finalProjectName = output.nombre_proyecto || metadataProjectName;\n\nif (!finalProjectName || finalProjectName === \"Sin Nombre\") {\n    finalProjectName = fileTitle.replace(/\\.pdf$/i, '') + \" (Project)\";\n}\n\n// Lista de Tipos - RESPETAR LO QUE DETECT√ì EL CLASIFICADOR\nlet tipos = output.tipos_detectados || [];\nif (!Array.isArray(tipos)) tipos = [];\n\nconsole.log(\"üìã Tipos detectados por IA:\", JSON.stringify(tipos));\n\n// REGLA DE FALLBACK (solo si el clasificador NO detect√≥ nada)\nif (tipos.length === 0) {\n    const titleLower = (fileTitle || \"\").toLowerCase();\n    const isRFQ = titleLower.includes(\"rfq\") || titleLower.includes(\"request for quotation\");\n    \n    if (isRFQ) {\n        tipos.push(\"Technical Evaluation\", \"Economical Evaluation\");\n        console.log(\"‚ÑπÔ∏è Fallback: Archivo RFQ sin tipos detectados, a√±adiendo Technical y Economical.\");\n    } else {\n        tipos.push(\"Technical Evaluation\");\n        console.log(\"‚ÑπÔ∏è Fallback: Sin tipos detectados, a√±adiendo Technical por defecto.\");\n    }\n}\n// Si el clasificador S√ç detect√≥ tipos, los respetamos tal cual\n\n// Eliminar duplicados\ntipos = [...new Set(tipos)];\n\nconsole.log(\"üìã Tipos finales a procesar:\", JSON.stringify(tipos));\n\n// 4. Generar Salida (Expandir items)\nreturn tipos.map((tipo, idx) => ({\n    json: {\n        tipo_evaluacion: tipo,\n        rfq_project_id: projectId,\n        rfq_document_id: documentId,\n        nombre_proyecto: finalProjectName,\n        file_title: fileTitle,\n        texto_rfq: fullText,\n        indice: idx + 1,\n        total_tipos: tipos.length\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        336
      ],
      "id": "6975c3dd-78b7-4d95-bf68-f2aa8bb6c179",
      "name": "Expandir por Tipo1"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1168,
        336
      ],
      "id": "0d2a738e-8cbf-461e-b79d-c8345285eeb7",
      "name": "Loop por Tipo1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear Final (Con Nombre Proyecto)\n// =============================================\nconst inputJson = $input.first().json;\n// Asegurar que sea string\nlet llmOutput = \"\";\nif (typeof inputJson === 'string') llmOutput = inputJson;\nelse if (inputJson.text && typeof inputJson.text === 'string') llmOutput = inputJson.text;\nelse if (inputJson.output && typeof inputJson.output === 'string') llmOutput = inputJson.output;\nelse if (inputJson.content && typeof inputJson.content === 'string') llmOutput = inputJson.content;\nelse llmOutput = JSON.stringify(inputJson.text || inputJson.output || inputJson.content || inputJson);\n\nllmOutput = String(llmOutput || \"[]\");\n\n// 1. Recuperar Contexto del Loop\nlet projectId = \"unknown\";\nlet documentId = \"unknown\";\nlet tipoEvaluacion = \"Unknown\";\nlet nombreProyecto = \"Sin Nombre\";\n\ntry {\n    const loopData = $('Loop por Tipo1').first().json;\n    projectId = loopData.rfq_project_id;\n    documentId = loopData.rfq_document_id;\n    tipoEvaluacion = loopData.tipo_evaluacion;\n    nombreProyecto = loopData.nombre_proyecto || \"Sin Nombre\";\n} catch(e) {}\n\n// 2. L√≥gica de Parsing\nlet items = [];\n\ntry {\n    let clean = llmOutput.replace(/```json/gi, '').replace(/```/g, '').trim();\n    const start = clean.indexOf('[');\n    const end = clean.lastIndexOf(']');\n    if (start !== -1 && end !== -1) {\n        items = JSON.parse(clean.substring(start, end + 1));\n    }\n} catch(e) {}\n\nif (items.length === 0) {\n    const lines = llmOutput.split('\\n');\n    let currentPhase = \"General\";\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        if (/^\\d+\\./.test(line) && !line.includes('Estimate')) {\n            const text = line.replace(/^\\d+\\.\\s*/, '').trim();\n            if (i+1 < lines.length && (lines[i+1].trim().startsWith('-') || lines[i+1].trim().startsWith('‚Ä¢'))) {\n                currentPhase = text;\n            } else {\n                 items.push({ fase: \"General\", requisito_rfq: text });\n            }\n        }\n        else if (line.startsWith('-') || line.startsWith('‚Ä¢')) {\n            items.push({ fase: currentPhase, requisito_rfq: line.replace(/^[-‚Ä¢]\\s*/, '').trim() });\n        }\n    }\n}\n\nfunction generateId(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) - hash) + str.charCodeAt(i);\n        hash = hash & hash;\n    }\n    return 'item_' + Math.abs(hash).toString(16).padStart(12, '0');\n}\n\nreturn items.map(item => ({\n    json: {\n        rfq_project_id: projectId,\n        project_name: nombreProyecto,\n        rfq_document_id: documentId,\n        evaluation: tipoEvaluacion,\n        fase: item.fase || \"General\",\n        requisito_rfq: item.requisito_rfq || \"Sin Nombre\"\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2736,
        256
      ],
      "id": "18aa3c36-4ffe-4892-a660-a97ca36d7f0f",
      "name": "Parsear Items1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Agregar Resultados del Tipo Actual\n// =============================================\n\nconst items = $input.all();\n\n// Contar items insertados\nconst totalInserted = items.length;\n\n// Recuperar info del tipo actual\nlet tipoActual = \"unknown\";\ntry {\n    tipoActual = $('Loop por Tipo1').first().json.tipo_evaluacion;\n} catch(e) {}\n\nconsole.log(`‚úÖ Tipo ${tipoActual}: ${totalInserted} items insertados`);\n\nreturn {\n    json: {\n        tipo_procesado: tipoActual,\n        items_insertados: totalInserted,\n        continuar_loop: true\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3264,
        464
      ],
      "id": "b939967a-b722-4659-a362-250437edcde8",
      "name": "Agregar Resultados1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Resumen Final\n// =============================================\n\n// Recuperar datos del proyecto\nlet projectId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet tiposDetectados = [];\n\ntry {\n    const projectNode = $('Generate IDs1').first().json;\n    projectId = projectNode.rfq_project_id;\n    fileTitle = projectNode.file_title;\n} catch(e) {}\n\ntry {\n    const clasificador = $('Clasificador de Tipos1').first().json;\n    const output = clasificador.output || clasificador;\n    tiposDetectados = output.tipos_detectados || [];\n} catch(e) {}\n\nconsole.log(\"========================================\");\nconsole.log(\"‚úÖ PROCESAMIENTO RFQ COMPLETADO\");\nconsole.log(`   Proyecto: ${projectId}`);\nconsole.log(`   Archivo: ${fileTitle}`);\nconsole.log(`   Tipos procesados: ${tiposDetectados.length}`);\nconsole.log(\"========================================\");\n\nreturn {\n    json: {\n        success: true,\n        rfq_project_id: projectId,\n        file_title: fileTitle,\n        tipos_procesados: tiposDetectados,\n        mensaje: `RFQ procesada correctamente. ${tiposDetectados.length} tipo(s) de evaluaci√≥n detectados y poblados.`\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        -32
      ],
      "id": "fb7d8dc9-1d3f-4086-aebe-1a3270813f90",
      "name": "Resumen Final1"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        2752,
        -32
      ],
      "id": "5085cfe3-4512-45d9-9d3c-cb0289f0c9fb",
      "name": "Respond Success1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Base64 a Binary\n// =============================================\n\n// Recuperar metadatos del inicio del flujo (Generate IDs1)\nlet inputData = {};\ntry {\n    inputData = $('Generate IDs1').first().json;\n} catch (e) {\n    inputData = $json; // Fallback\n}\n\nconst base64Data = inputData.file_binary;\n\nif (!base64Data || base64Data === \"\") {\n    throw new Error(\"‚ùå CR√çTICO: 'file_binary' est√° vac√≠o\");\n}\n\nconst binaryData = Buffer.from(base64Data, 'base64');\n\nconsole.log(`‚úÖ PDF convertido: ${binaryData.length} bytes`);\n\nreturn {\n    json: {\n        rfq_project_id: inputData.rfq_project_id || \"unknown\",\n        rfq_document_id: inputData.rfq_document_id || \"unknown\",\n        project_name: inputData.project_name || \"Sin Nombre\",\n        file_title: inputData.file_title || \"document.pdf\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'rfq.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -144,
        112
      ],
      "id": "2a735241-4087-4d54-89ce-23a7e44e0a62",
      "name": "Base64 a Binary3"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        80,
        112
      ],
      "id": "10e170af-3664-40f9-a7b0-0672a89a2dce",
      "name": "Extract from File3"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Generate Stable ID + Detectar Modo (CORREGIDO)\n// =============================================\n\nfunction simpleHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(16, '0').substring(0, 16);\n}\n\n// Aseguramos capturar el body correctamente desde el nodo anterior\nconst body = $json.body || $json;\n\n// CAMPOS B√ÅSICOS\nconst originalFileId = body.file_id || \"unknown\";\nconst fileTitle = body.file_title || \"unknown.pdf\";\nconst fileBinary = body.file_binary || \"\";\nconst fileUrl = body.file_url || \"unknown\";\n\n// ‚úÖ EXTRAER METADATA DEL USUARIO\n// Usamos el operador ?. para evitar errores si metadata no existe\nconst metadata = body.metadata || {};\nconst rfqProjectName = metadata.proyect_name || body.project_name || null;\nconst userProveedor = metadata.proveedor || null;\nconst userTipoEval = metadata.evaluation || null; \n\n// ‚úÖ DETERMINAR MODO DE OPERACI√ìN\nlet modoOperacion = \"CLASIFICADOR\"; \nlet datosCompletos = false;\n\nif (userProveedor && userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0) {\n    modoOperacion = \"VALIDADOR\";\n    datosCompletos = true;\n} else if (userProveedor || (userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0)) {\n    modoOperacion = \"HIBRIDO\";\n}\n\n// Generar ID estable basado en el t√≠tulo (como pediste)\nconst normalizedTitle = fileTitle.toLowerCase().trim();\nconst stableId = simpleHash(normalizedTitle);\n\n// ID de Documento (√∫nico por contenido para evitar duplicados en Supabase)\nconst documentId = 'doc_' + stableId;\n\nreturn {\n  json: {\n    file_id: stableId, // Este es tu ID estable\n    rfq_document_id: documentId,\n    file_id_original: originalFileId,\n    file_title: fileTitle,\n    file_binary: fileBinary,\n    file_url: fileUrl,\n    \n    // Si no hay nombre de proyecto, usamos el nombre del archivo como fallback\n    project_name: rfqProjectName || fileTitle.replace(/\\.[^/.]+$/, \"\"),\n    rfq_project_id: rfqProjectName ? 'proj_' + simpleHash(rfqProjectName.toLowerCase().trim()) : 'proj_generic',\n    \n    user_proveedor: userProveedor,\n    user_tipo_evaluacion: userTipoEval,\n    modo_operacion: modoOperacion,\n    datos_usuario_completos: datosCompletos,\n    \n    // Guardamos una copia limpia para los nodos siguientes\n    metadata_limpia: {\n        proyect_name: rfqProjectName,\n        proveedor: userProveedor,\n        evaluation: userTipoEval\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -592,
        112
      ],
      "id": "45ae3659-7a78-45b2-80ac-f45bd4f26fe9",
      "name": "Generate IDs1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.tipo_evaluacion }}",
                    "rightValue": "Evaluation",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "c3ac36b0-dcd7-4e84-a72a-7e88b6f2fc2a"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "529ee554-7a05-413a-9782-710d0deb6365",
                    "leftValue": "={{ $json.tipo_evaluacion }}",
                    "rightValue": "Deliverables",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        2064,
        464
      ],
      "id": "c6b57797-e37d-429f-beaa-6f8fb4135c5c",
      "name": "Switch1"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1,
          "numCtx": 32768
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2320,
        912
      ],
      "id": "77763a98-cd71-47d5-b5e4-868fa0bd24f0",
      "name": "Ollama Extractor2",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Evaluation: {{ $('Loop por Tipo1').item.json.tipo_evaluacion }}\n\n### TEXT:\n{{ $json.texto_chunk }}\n\n### DISCIPLINES: Management, Preliminary surveys, Technical and economical studies, Process Engineering, HSE, Mechanical Engineering, Piping, Civil and Structural Engineering, Electrical Engineering, Instrumentation and control Engineering, Planning, Cost, Procurement\n\n### EXAMPLES:\n{\"fase\": \"Management\", \"requisito_rfq\": \"Project Execution plan\"}\n{\"fase\": \"Process Engineering\", \"requisito_rfq\": \"Process flow diagrams\"}\n{\"fase\": \"HSE\", \"requisito_rfq\": \"HAZID\"}\n{\"fase\": \"Electrical Engineering\", \"requisito_rfq\": \"Electrical consumer list and load balance\"}\n{\"fase\": \"Cost\", \"requisito_rfq\": \"CAPEX estimate Class 3 AACEI (-20% +30%)\"}\n\n**JSON RESPONSE:**",
        "messages": {
          "messageValues": [
            {
              "message": "=Extract ALL deliverables from RFQ. Use disciplines as 'fase': Management, Process Engineering, HSE, Mechanical Engineering, Piping, Civil and Structural Engineering, Electrical Engineering, Instrumentation and control Engineering, Planning, Cost, Procurement. JSON array only."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2384,
        688
      ],
      "id": "1fc66468-da54-4caa-8bcb-2fd17a3488d1",
      "name": "LLM Extractor - Deliverables"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear Deliverables (ROBUST FALLBACK)\n// =============================================\n\nconst inputJson = $input.first().json;\n\n// 1. RECOGIDA DE DATOS RAW\nlet rawOutput = \"\";\nif (inputJson.output && typeof inputJson.output === 'string') rawOutput = inputJson.output;\nelse if (inputJson.text && typeof inputJson.text === 'string') rawOutput = inputJson.text;\nelse if (inputJson.content && typeof inputJson.content === 'string') rawOutput = inputJson.content;\nelse if (typeof inputJson === 'string') rawOutput = inputJson;\n\n// 2. INTENTO A: EXTRAER JSON\nlet items = [];\ntry {\n    const clean = rawOutput.replace(/```json/gi, '').replace(/```/g, '').trim();\n    const start = clean.indexOf('[');\n    const end = clean.lastIndexOf(']');\n    if (start !== -1 && end !== -1) {\n        items = JSON.parse(clean.substring(start, end + 1));\n    }\n} catch(e) {}\n\n// 3. INTENTO B: FALLBACK DE LISTA\nif (items.length === 0 && rawOutput) {\n    const lines = rawOutput.split('\\n');\n    let currentPhase = \"General\";\n    lines.forEach(line => {\n        const trimmed = line.trim();\n        if (!trimmed) return;\n        const numberMatch = trimmed.match(/^\\d+\\.\\s*(.*)/);\n        const bulletMatch = trimmed.match(/^[-‚Ä¢*]\\s*(.*)/);\n        if (numberMatch) {\n            items.push({ fase: currentPhase, requisito_rfq: numberMatch[1] });\n        } else if (bulletMatch) {\n             items.push({ fase: currentPhase, requisito_rfq: bulletMatch[1] });\n        }\n    });\n}\n\n// 4. HELPER: GENERAR ID ESTABLE\nfunction generateId(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) - hash) + str.charCodeAt(i);\n        hash = hash & hash;\n    }\n    return 'item_' + Math.abs(hash).toString(16).padStart(12, '0');\n}\n\n// 5. NORMALIZAR Y RETORNAR\nlet loopCtx = {};\ntry {\n   const outerLoop = $('Loop por Tipo1').first().json;\n   loopCtx = {\n       rfq_project_id: outerLoop.rfq_project_id,\n       rfq_document_id: outerLoop.rfq_document_id,\n       project_name: outerLoop.nombre_proyecto,\n       tipo_evaluacion: outerLoop.tipo_evaluacion\n   };\n} catch(e){}\n\nreturn items.map(item => {\n    const phase = item.fase || \"General\";\n    const req = item.requisito_rfq || \"Sin Nombre\";\n    return {\n        json: {\n            rfq_project_id: loopCtx.rfq_project_id || \"unknown\",\n            rfq_document_id: loopCtx.rfq_document_id || \"unknown\",\n            project_name: loopCtx.project_name || \"Unknown\",\n            evaluation: loopCtx.tipo_evaluacion || \"Deliverables\",\n            fase: phase,\n            requisito_rfq: req\n        }\n    };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2736,
        688
      ],
      "id": "a642671d-5239-4913-a5cd-078c1da2f169",
      "name": "Parsear deliverables"
    },
    {
      "parameters": {
        "model": "qwen3:8b",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2320,
        464
      ],
      "id": "f420575d-9c35-4963-a148-5758db82c8be",
      "name": "Ollama Extractor1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"fase\": {\n        \"type\": \"string\",\n        \"description\": \"Nombre de la disciplina o √°rea (ej: Process Engineering, Mechanical Engineering, Civil and Structural, Electrical Engineering, etc.)\"\n      },\n      \"requisito_rfq\": {\n        \"type\": \"string\",\n        \"description\": \"Nombre del documento o entregable espec√≠fico\"\n      }\n    },\n    \"required\": [\"fase\", \"requisito_rfq\"]\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2624,
        896
      ],
      "id": "ddf73316-3b00-4ec1-b08b-2d0b9c7aeca9",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"fase\": {\n        \"type\": \"string\",\n        \"description\": \"Fase del proyecto o disciplina (ej: PRE-FEED, FEED, EPC, Process Engineering, etc.)\"\n      },\n      \"requisito_rfq\": {\n        \"type\": \"string\",\n        \"description\": \"Requisito t√©cnico o econ√≥mico espec√≠fico\"\n      }\n    },\n    \"required\": [\"fase\", \"requisito_rfq\"]\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2560,
        464
      ],
      "id": "35b2644b-1905-412c-a3fc-fdc51d018da5",
      "name": "Structured Output Parser2"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Dividir en Trozos (Chunking)\n// =============================================\n\nconst input = $input.first().json;\nconst fullText = input.texto_rfq || \"\";\n\n// Tama√±o: ~12,000 caracteres (aprox 3k-4k tokens)\nconst chunkSize = 15000;\nconst overlap = 1500;\nconst chunks = [];\n\nif (fullText.length <= chunkSize) {\n    chunks.push({\n        ...input,\n        texto_chunk: fullText,\n        chunk_index: 1,\n        total_chunks: 1\n    });\n} else {\n    let start = 0;\n    while (start < fullText.length) {\n        let end = start + chunkSize;\n        let chunk = fullText.substring(start, end);\n        \n        chunks.push({\n            ...input,\n            texto_chunk: chunk,\n            chunk_index: chunks.length + 1\n        });\n\n        start += (chunkSize - overlap);\n        if (start >= fullText.length) break;\n    }\n    chunks.forEach(c => c.total_chunks = chunks.length);\n}\n\nreturn chunks;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        448
      ],
      "id": "27c2869d-49ff-431e-8835-464f5ca4c9d8",
      "name": "Dividir en Trozos1",
      "disabled": true
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.reiniciar_bucle ? true : false }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1808,
        448
      ],
      "id": "bea26928-05a1-48d9-b1e9-8708085abae0",
      "name": "Loop por Trozo1"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => ({\n    json: {\n        ...item.json, // Mantiene todos los datos originales (incluido tipo_evaluacion)\n        \n        // Aqu√≠ est√° la correcci√≥n: Usamos dos puntos, no el igual.\n        reiniciar_bucle: true \n    }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1632,
        448
      ],
      "id": "a92786e5-ce32-4b15-82ef-be95825f7091",
      "name": "Reset Items1"
    },
    {
      "parameters": {
        "model": "qwen3-embedding:8b"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        528,
        560
      ],
      "id": "5f09cdcd-7036-4cac-a245-9bfe46297077",
      "name": "Embeddings Ollama1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "rfq",
          "mode": "list",
          "cachedResultName": "rfq"
        },
        "options": {
          "queryName": "match_rfq"
        }
      },
      "id": "72e94c63-781d-4425-8c32-b63d1ee79927",
      "name": "Insert into Supabase Vectorstore1",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1,
      "position": [
        608,
        336
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "chunkSize": 800,
        "chunkOverlap": 150,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        784,
        768
      ],
      "id": "2863de98-e918-4642-820f-9236fca19d83",
      "name": "Recursive Character Text Splitter1"
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $('Preparar Texto1').item.json.text_for_classification }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $json.id }}"
              },
              {
                "name": "file_title",
                "value": "={{ $('Generate IDs1').first().json.file_title }}"
              },
              {
                "name": "tipo_evaluacion",
                "value": "={{ $('Clasificador de Tipos1').item.json.output.tipos_detectados }}"
              },
              {
                "name": "tipo-doc",
                "value": "RFQ"
              }
            ]
          }
        }
      },
      "id": "a4c32a02-fc1b-42a7-bed5-2cea49c1eac3",
      "name": "Default Data Loader1",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        704,
        560
      ]
    },
    {
      "parameters": {
        "tableId": "rfq_items_master",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "project_name",
              "fieldValue": "=PROJECT H2 PLANT IN LA ZAIDA, ZARAGOZA (SPAIN)"
            },
            {
              "fieldId": "evaluation_type",
              "fieldValue": "={{ $json.evaluation }}"
            },
            {
              "fieldId": "phase",
              "fieldValue": "={{ $json.fase }}"
            },
            {
              "fieldId": "requirement_text",
              "fieldValue": "={{ $json.requisito_rfq }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        3056,
        464
      ],
      "id": "f89e7493-65fd-49c8-bd9d-d90e319b06b6",
      "name": "Create a row",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "rfq",
        "filterType": "string",
        "filterString": "=metadata->>file_id=like.*{{ $json.file_id }}*"
      },
      "id": "45714e4c-85f2-48a1-bb76-b377ca841cbd",
      "name": "Delete Old Doc Rows1",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -368,
        112
      ],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_metadata",
          "mode": "list",
          "cachedResultName": "document_metadata"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $('Generate IDs1').first().json.file_id }}",
            "title": "={{ $('Generate IDs1').first().json.file_title }}",
            "project_name": "=PROJECT H2 PLANT IN LA ZAIDA, ZARAGOZA (SPAIN)",
            "document_type": "=RFQ",
            "evaluation_types": "={{ $json.output.tipos_detectados }}",
            "provider": "IGNIS"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": true,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "title",
              "displayName": "title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "project_name",
              "displayName": "project_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "document_type",
              "displayName": "document_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "provider",
              "displayName": "provider",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "evaluation_types",
              "displayName": "evaluation_types",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        384,
        336
      ],
      "id": "0bcec562-6c50-489c-809d-89f51df1d0fd",
      "name": "Insert Document Metadata2",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "V0REAPph5JBLqze3",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "model": "mistral-large-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        2432,
        528
      ],
      "id": "faa8f75b-97a1-4127-a436-c78fdd55805c",
      "name": "Mistral Cloud Chat Model4",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.embeddingsCohere",
      "typeVersion": 1,
      "position": [
        896,
        784
      ],
      "id": "1e9afb1a-46d4-42fe-a0d3-3ce7efe30067",
      "name": "Embeddings Cohere1",
      "credentials": {
        "cohereApi": {
          "id": "KGv4zlUJIjLdxpnr",
          "name": "CohereApi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Evaluation: {{ $json.tipo_evaluacion }}\n\n### TEXT:\n{{ $('Preparar Texto1').first().json.text }}\n\n### PHASES: PRE-FEED, FEED, EPC TENDER, EPC Budgetary Price, General Comments\n\n### EXAMPLES:\n{\"fase\": \"PRE-FEED\", \"requisito_rfq\": \"Scope of facilities\"}\n{\"fase\": \"PRE-FEED\", \"requisito_rfq\": \"CAPEX estimate\"}\n{\"fase\": \"PRE-FEED\", \"requisito_rfq\": \"Hours per discipline\"}\n{\"fase\": \"PRE-FEED\", \"requisito_rfq\": \"Process\"}\n{\"fase\": \"FEED\", \"requisito_rfq\": \"AACEI Class\"}\n{\"fase\": \"EPC TENDER\", \"requisito_rfq\": \"Technical specifications\"}\n{\"fase\": \"General Comments\", \"requisito_rfq\": \"Validity of the proposal\"}\n\n**JSON RESPONSE:**",
        "messages": {
          "messageValues": [
            {
              "message": "=Extract ALL requirements from RFQ for Technical/Economical Evaluation. Use phases: PRE-FEED, FEED, EPC TENDER, EPC Budgetary Price, General Comments. List each discipline separately (Process, Mechanical, Piping, etc.). JSON array only, no explanations."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2400,
        256
      ],
      "id": "ccb2ea8e-d0b2-4bd0-843c-7b9ef270f457",
      "name": "LLM Extractor Tech-Econ"
    }
  ],
  "connections": {
    "Webhook RFQ": {
      "main": [
        [
          {
            "node": "Generate IDs1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Texto1": {
      "main": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clasificador de Tipos1": {
      "main": [
        [
          {
            "node": "Insert Document Metadata2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Clasificador1": {
      "ai_languageModel": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Expandir por Tipo1": {
      "main": [
        [
          {
            "node": "Loop por Tipo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop por Tipo1": {
      "main": [
        [
          {
            "node": "Resumen Final1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Dividir en Trozos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear Items1": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agregar Resultados1": {
      "main": [
        [
          {
            "node": "Loop por Trozo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resumen Final1": {
      "main": [
        [
          {
            "node": "Respond Success1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary3": {
      "main": [
        [
          {
            "node": "Extract from File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File3": {
      "main": [
        [
          {
            "node": "Preparar Texto1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate IDs1": {
      "main": [
        [
          {
            "node": "Delete Old Doc Rows1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "LLM Extractor Tech-Econ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "LLM Extractor - Deliverables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Extractor2": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Extractor - Deliverables",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "LLM Extractor - Deliverables": {
      "main": [
        [
          {
            "node": "Parsear deliverables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear deliverables": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dividir en Trozos1": {
      "main": [
        [
          {
            "node": "Reset Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop por Trozo1": {
      "main": [
        [
          {
            "node": "Loop por Tipo1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Items1": {
      "main": [
        [
          {
            "node": "Loop por Trozo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert into Supabase Vectorstore1": {
      "main": [
        [
          {
            "node": "Expandir por Tipo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter1": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader1",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader1": {
      "ai_document": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Create a row": {
      "main": [
        [
          {
            "node": "Agregar Resultados1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Doc Rows1": {
      "main": [
        [
          {
            "node": "Base64 a Binary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Document Metadata2": {
      "main": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral Cloud Chat Model4": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Extractor Tech-Econ",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Cohere1": {
      "ai_embedding": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "LLM Extractor Tech-Econ": {
      "main": [
        [
          {
            "node": "Parsear Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "53140335eaf11280ef77ef2f5a378f48c2b28e822e3e0d96563cdd92175c0eff"
  }
}