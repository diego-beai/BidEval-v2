{
    "nodes": [
        {
            "parameters": {
                "content": "### Ingesta de RFQ, actualización de requisitos",
                "height": 1312,
                "width": 4374,
                "color": 4
            },
            "type": "n8n-nodes-base.stickyNote",
            "typeVersion": 1,
            "position": [
                -1072,
                -160
            ],
            "id": "bfdf8893-bb37-4608-84ce-47b87c14b568",
            "name": "Sticky Note"
        },
        {
            "parameters": {
                "httpMethod": "POST",
                "path": "ingesta-rfq",
                "responseMode": "responseNode",
                "options": {}
            },
            "type": "n8n-nodes-base.webhook",
            "typeVersion": 2.1,
            "position": [
                -976,
                304
            ],
            "id": "beaf82fd-6243-4fe5-b891-bc78d95e1eae",
            "name": "Webhook RFQ",
            "webhookId": "4efdd77c-0a9c-4c26-9da3-2bdb83fca209"
        },
        {
            "parameters": {
                "jsCode": "// =============================================\n// NODO: Preparar Texto (Agregador de Páginas)\n// =============================================\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n    return { json: { error: \"No input items received\" } };\n}\n\n// Recuperar metadatos del inicio del flujo (Generate IDs1)\nlet metadata = {};\ntry {\n    metadata = $('Generate IDs1').first().json;\n} catch (e) {\n    console.log(\"⚠️ No se pudo recuperar metadata de Generate IDs1\");\n}\n\n// 1. Agregado de Texto Completo (todas las páginas)\n// Intentamos md_content primero (mejor para LLMs), luego text\nlet fullText = items.map(item => item.json.md_content || item.json.text || \"\").join('\\n\\n').trim();\n\nif (!fullText) {\n    console.log(\"⚠️ Advertencia: No se extrajo texto del documento.\");\n}\n\n// 2. Limpieza básica\nfullText = fullText.replace(/\\x00/g, ''); // Eliminar caracteres nulos\n\n// 3. Preparar fragmento para clasificación (máx 40k chars para no saturar context)\nconst textForClassification = fullText.substring(0, 40000);\n\nconsole.log(`✅ Texto preparado: ${items.length} páginas aggregadas. Chars: ${fullText.length}`);\n\nreturn {\n    json: {\n        rfq_project_id: metadata.rfq_project_id || \"unknown\",\n        rfq_document_id: metadata.rfq_document_id || \"unknown\",\n        project_name: metadata.project_name || \"Sin Nombre\",\n        file_title: metadata.file_title || \"document.pdf\",\n        text: fullText, \n        text_for_classification: textForClassification || \"SIN TEXTO DETECTADO\",\n        pages_count: items.length\n    }\n};"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -80,
                304
            ],
            "id": "faf1d3bd-759a-4cb5-a654-2f12364fefe7",
            "name": "Preparar Texto1"
        },
        {
            "parameters": {
                "promptType": "define",
                "text": "=### DOCUMENTO RFQ\n\nNombre del Archivo: {{ $json.file_title }}\n\n### CONTENIDO (FRAGMENTO):\n{{ $json.pages ? $json.pages.slice(0, 1).map(p => p.text).join('\\n\\n') : ($json.text ? $json.text.substring(0, 2000) : 'SIN TEXTO') }}",
                "hasOutputParser": true,
                "messages": {
                    "messageValues": [
                        {
                            "message": "=## TAREA: CLASIFICAR TIPOS DE EVALUACIÓN EN DOCUMENTO RFQ Y NOMBRE DEL PROYECTO\n\nEres un auditor experto en documentación de ingeniería EPC del sector energético.\nAnaliza el documento RFQ y determina qué tipos de evaluación contiene y el nombre del proyecto.\n\n### IMPORTANTE\n\nUn documento puede contener 1, 2, 3 o 4 tipos de evaluación.\n**No asumas que están todos.**\nDetecta **SOLO** los que realmente están presentes.\n\n### REGLA DE TÍTULO (CRÍTICA)\n**Si el nombre del archivo o el título del documento es \"RFQ\" o \"Request for quotation\", clasifica automáticamente como \"Technical Evaluation\" Y \"Economical Evaluation\"**, ya que por definición una licitación completa implica evaluar ambos alcances.\n\n### TIPOS POSIBLES\n\n1. **Technical Evaluation**\n\n   **Evidencia requerida:**\n   - Secciones de **Scope of Work**, **Scope of Facilities**, **Technical Requirements**\n   - Requisitos técnicos generales (metodología, normativas, estándares)\n   - Descripción de alcance por fases (PRE-FEED, FEED, EPC, Conceptual, Basic Engineering, Detailed Engineering)\n   - Especificaciones de ingeniería, criterios de diseño\n\n2. **Economical Evaluation**\n\n   **Evidencia requerida:**\n   - Tablas de **precios** o **tarifas**\n   - **Hours per discipline**, **EUR/hora**, **USD/hour**, tarifas horarias\n   - Formato de **cotización económica**, **pricing schedule**\n   - **Desglose de costos por fase** o por disciplina\n   - Secciones **Commercial**, **Pricing**, **Budget**, **Cost Breakdown**\n\n3. **Pre-FEED Deliverables** (o equivalentes: Conceptual Design Deliverables, Feasibility Deliverables)\n\n   **Evidencia requerida:**\n   - Lista o tabla de documentos a entregar en fase preliminar/conceptual\n   - Organizada por **disciplinas** (Process, Mechanical, Electrical, Civil, I&C, etc.)\n   - Documentos conceptuales: **Basis of Design**, **PFDs**, **P&IDs preliminares**, **Block diagrams**\n   - Estudios: **HAZID**, **Risk Analysis**, **Site Assessment**\n   - **CAPEX Class 3–5 (AACEI)**, estimaciones preliminares (+/- 30%)\n\n4. **FEED Deliverables** (o equivalentes: Basic Engineering Deliverables)\n\n   **Evidencia requerida:**\n   - Lista o tabla de documentos a entregar en fase FEED/Basic Engineering\n   - Documentos más detallados que en Pre-FEED\n   - **Especificaciones de compra**, **datasheets**, **equipment lists**\n   - **MTO** (Material Take-Off), **cable schedules**, **instrument lists**\n   - **CAPEX Class 2–3 (AACEI)**, estimaciones más precisas (+/- 15%)\n   - **HAZOP**, **SIL studies**, **3D Model review**\n\n### NOMENCLATURA ALTERNATIVA\n\nEl documento puede usar nombres diferentes para las mismas fases. Aquí tienes equivalencias:\n\n| Nombre en RFQ | Clasificar como |\n|---------------|-----------------|\n| Pre-FEED, Conceptual Design, Feasibility Study, Phase 1 | Pre-FEED Deliverables |\n| FEED, Basic Engineering, Basic Design, Phase 2 | FEED Deliverables |\n| Technical Proposal, Technical Offer, Scope of Work | Technical Evaluation |\n| Commercial Proposal, Pricing, Cost Estimate, Quotation | Economical Evaluation |\n\n### CÓMO DIFERENCIAR\n\n| Si ves... | Es probablemente... |\n| --- | --- |\n| **Scope of Work** general, **metodología**, requisitos técnicos | **Technical Evaluation** |\n| Tablas de precios, horas, **EUR/h**, tarifas | **Economical Evaluation** |\n| Lista de docs por disciplina + fase preliminar/conceptual | **Pre-FEED Deliverables** |\n| Lista de docs por disciplina + fase FEED/Basic Engineering | **FEED Deliverables** |\n\n### TAREA OBLIGATORIA: IDENTIFICAR NOMBRE DEL PROYECTO\n\nEsta tarea es **obligatoria** y **NO** puede omitirse.\n**Deberás devolver SIEMPRE** un valor para `nombre_proyecto`.\n\n### ORDEN DE PRIORIDAD (estricto)\n\n1. **Nombre explícito del proyecto**\n   - Busca en la **portada** o el **título principal**.\n   - Encabezados repetidos que contengan el nombre del proyecto.\n   - Frases como **Project**, **Project Name**, **Project Title**, **RFQ for...**\n\n2. **Nombre implícito pero oficial**\n   Si no encuentras un título literal, genera el nombre combinando los siguientes elementos:\n   - Tipo de instalación energética (**Hydrogen Plant**, **PV Plant**, **Solar Plant**, **Wind Farm**, **Battery Storage**, **Power Plant**, **Electrolyzer**, **Substation**, etc.)\n   - Ubicación (ciudad, región o país)\n   - Cliente o **site** si está claramente indicado\n   - Capacidad si se menciona (ej: 100 MW, 50 MWp, 20 MW electrolyzer)\n   - Ejemplo: **100 MW Solar PV Plant – Andalucía, Spain**\n\n3. **Fallback obligatorio**\n   Si el documento no declara claramente un nombre:\n   - **NO dejes el campo vacío**.\n   - **NO uses valores genéricos**.\n   - Genera un nombre técnico-descriptivo utilizando:\n     - **Formato obligatorio**: `<Tipo de Proyecto Energético> – <Ubicación o Cliente> (RFQ)`\n   - Ejemplo: **Green Hydrogen Production Facility – Northern Spain (RFQ)**\n\n### REGLAS DURAS\n\n- **No usar**: Unknown, N/A, Not specified\n- **No inventar nombres comerciales**\n- El nombre debe ser válido para un entorno EPC / PMO del sector energético\n- Prioriza claridad, trazabilidad y profesionalidad\n\n### FORMATO DE SALIDA (JSON PLANO – ESTRICTO)\n\n**ATENCIÓN: REGLAS DE ESTRUCTURA**\n1. Devuelve **ÚNICAMENTE** un objeto JSON que empiece por `{` y termine por `}`.\n2. **PROHIBIDO** devolver el JSON dentro de una lista o array `[]`.\n3. **PROHIBIDO** usar claves contenedoras como `\"output\"`, `\"response\"` o `\"json\"`. El nivel raíz debe tener directamente las claves `tipos_detectados` y `nombre_proyecto`.\n4. No incluyas bloques de código markdown (\\`\\`\\`json). Solo el texto plano del JSON.\n\n**FORMATO DE SALIDA CORRECTO:**\n{\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Pre-FEED Deliverables\"],\n  \"nombre_proyecto\": \"Hydrogen Production Plant – La Zaida, Spain\",\n  \"razonamiento\": \"El documento incluye un Scope of Work técnico y una lista de documentos para la fase Pre-FEED...\"\n}"
                        }
                    ]
                },
                "batching": {}
            },
            "type": "@n8n/n8n-nodes-langchain.chainLlm",
            "typeVersion": 1.8,
            "position": [
                144,
                304
            ],
            "id": "b3ec5086-0bf8-400a-829e-f1dbf1059402",
            "name": "Clasificador de Tipos1"
        },
        {
            "parameters": {
                "model": "mistral:7b",
                "options": {
                    "temperature": 0.1
                }
            },
            "type": "@n8n/n8n-nodes-langchain.lmOllama",
            "typeVersion": 1,
            "position": [
                144,
                528
            ],
            "id": "60236992-4930-43df-9b11-02789b24569f",
            "name": "Ollama Clasificador1",
            "credentials": {
                "ollamaApi": {
                    "id": "oS2Qqti9oVfsm8XZ",
                    "name": "Ollama account"
                }
            }
        },
        {
            "parameters": {
                "schemaType": "manual",
                "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\"Technical Evaluation\", \"Economical Evaluation\", \"Pre-FEED Deliverables\", \"FEED Deliverables\"]\n      }\n    },\n    \"nombre_proyecto\": {\n      \"type\": \"string\",\n      \"description\": \"Nombre del proyecto extraído del documento RFQ\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"tipos_detectados\", \"nombre_proyecto\"]\n}"
            },
            "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
            "typeVersion": 1.3,
            "position": [
                272,
                528
            ],
            "id": "d2250586-13ed-450f-a963-c3529a8ce5b2",
            "name": "Output Parser1"
        },
        {
            "parameters": {
                "jsCode": "const input = $input.first().json;\nlet rawText = \"\";\n\n// Recuperar metadatos PRIORITARIAMENTE\nlet projectId = \"unknown\";\nlet documentId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet fullText = \"\";\n\ntry {\n    const textNode = $('Preparar Texto1').first().json;\n    projectId = textNode.rfq_project_id;\n    documentId = textNode.rfq_document_id || \"unknown\";\n    fileTitle = textNode.file_title;\n    fullText = textNode.text;\n} catch(e) {\n    console.log(\"⚠️ Error recuperando metadatos de Preparar Texto1\");\n}\n\n// Extraer texto de forma segura\nif (typeof input === 'string') rawText = input;\nelse if (input.text && typeof input.text === 'string') rawText = input.text;\nelse if (input.output && typeof input.output === 'string') rawText = input.output;\nelse if (input.content && typeof input.content === 'string') rawText = input.content;\nelse if (input.text || input.output || input.content) rawText = JSON.stringify(input.text || input.output || input.content);\nelse rawText = JSON.stringify(input);\n\n// Asegurar que sea string para evitar errores con toLowerCase/replace\nrawText = String(rawText || \"\");\n\nlet output = {};\ntry {\n    // 1. Limpiar bloques markdown\n    const clean = rawText.replace(/```json/gi, '').replace(/```/g, '').trim();\n    \n    // 2. Intentar parsear JSON\n    const start = clean.indexOf('{');\n    const end = clean.lastIndexOf('}');\n    \n    if (start !== -1 && end !== -1) {\n        output = JSON.parse(clean.substring(start, end + 1));\n    } else {\n        output = JSON.parse(clean);\n    }\n} catch (e) {\n    console.log(\"⚠️ Parsing fallback: \", e.message);\n    // Fallback: Inferir del texto si falló el JSON\n    output = { \n        tipos_detectados: [], \n        nombre_proyecto: \"H2 Plant in La Zaida, Zaragoza (Spain)\" \n    };\n    \n    const searchStr = rawText.toLowerCase();\n    const titleStr = (fileTitle || \"\").toLowerCase();\n\n    // Regla de Título (CRÍTICA)\n    if (titleStr.includes(\"rfq\") || titleStr.includes(\"request for quotation\")) {\n        output.tipos_detectados.push(\"Technical Evaluation\", \"Economical Evaluation\");\n    } else {\n        if (searchStr.includes(\"technical\")) output.tipos_detectados.push(\"Technical Evaluation\");\n        if (searchStr.includes(\"economical\")) output.tipos_detectados.push(\"Economical Evaluation\");\n        if (searchStr.includes(\"pre-feed\")) output.tipos_detectados.push(\"Pre-FEED Deliverables\");\n        if (searchStr.includes(\"feed\")) output.tipos_detectados.push(\"FEED Deliverables\");\n    }\n    \n    // Eliminar duplicados si los hubiera y asegurar al menos uno\n    output.tipos_detectados = [...new Set(output.tipos_detectados)];\n    if (output.tipos_detectados.length === 0) output.tipos_detectados = [\"Technical Evaluation\"];\n}\n\nlet tipos = output.tipos_detectados || [\"Technical Evaluation\"];\nconst realProjectName = output.nombre_proyecto || \"H2 Plant in La Zaida, Zaragoza (Spain)\";\n\nreturn tipos.map((tipo, idx) => ({\n    json: {\n        tipo_evaluacion: tipo,\n        rfq_project_id: projectId,\n        rfq_document_id: documentId,\n        nombre_proyecto: realProjectName,\n        file_title: fileTitle,\n        texto_rfq: fullText,\n        indice: idx + 1,\n        total_tipos: tipos.length\n    }\n}));"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                880,
                304
            ],
            "id": "8f53d39b-806c-4e33-a264-64fcd7dfb731",
            "name": "Expandir por Tipo1"
        },
        {
            "parameters": {
                "options": {}
            },
            "type": "n8n-nodes-base.splitInBatches",
            "typeVersion": 3,
            "position": [
                1088,
                320
            ],
            "id": "aa2bf564-1133-41cd-ac35-ea548b3d0666",
            "name": "Loop por Tipo1"
        },
        {
            "parameters": {
                "jsCode": "// =============================================\n// NODO: Parsear Final (Con Nombre Proyecto)\n// =============================================\nconst inputJson = $input.first().json;\n// Asegurar que sea string\nlet llmOutput = \"\";\nif (typeof inputJson === 'string') llmOutput = inputJson;\nelse if (inputJson.text && typeof inputJson.text === 'string') llmOutput = inputJson.text;\nelse if (inputJson.output && typeof inputJson.output === 'string') llmOutput = inputJson.output;\nelse if (inputJson.content && typeof inputJson.content === 'string') llmOutput = inputJson.content;\nelse llmOutput = JSON.stringify(inputJson.text || inputJson.output || inputJson.content || inputJson);\n\nllmOutput = String(llmOutput || \"[]\");\n\n// 1. Recuperar Contexto del Loop\nlet projectId = \"unknown\";\nlet documentId = \"unknown\";\nlet tipoEvaluacion = \"Unknown\";\nlet nombreProyecto = \"Sin Nombre\";\n\ntry {\n    const loopData = $('Loop por Tipo1').first().json;\n    projectId = loopData.rfq_project_id;\n    documentId = loopData.rfq_document_id;\n    tipoEvaluacion = loopData.tipo_evaluacion;\n    nombreProyecto = loopData.nombre_proyecto || \"Sin Nombre\";\n} catch(e) {}\n\n// 2. Lógica de Parsing\nlet items = [];\n\ntry {\n    let clean = llmOutput.replace(/```json/gi, '').replace(/```/g, '').trim();\n    const start = clean.indexOf('[');\n    const end = clean.lastIndexOf(']');\n    if (start !== -1 && end !== -1) {\n        items = JSON.parse(clean.substring(start, end + 1));\n    }\n} catch(e) {}\n\nif (items.length === 0) {\n    const lines = llmOutput.split('\\n');\n    let currentPhase = \"General\";\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        if (/^\\d+\\./.test(line) && !line.includes('Estimate')) {\n            const text = line.replace(/^\\d+\\.\\s*/, '').trim();\n            if (i+1 < lines.length && (lines[i+1].trim().startsWith('-') || lines[i+1].trim().startsWith('•'))) {\n                currentPhase = text;\n            } else {\n                 items.push({ fase: \"General\", requisito_rfq: text });\n            }\n        }\n        else if (line.startsWith('-') || line.startsWith('•')) {\n            items.push({ fase: currentPhase, requisito_rfq: line.replace(/^[-•]\\s*/, '').trim() });\n        }\n    }\n}\n\nfunction generateId(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) - hash) + str.charCodeAt(i);\n        hash = hash & hash;\n    }\n    return 'item_' + Math.abs(hash).toString(16).padStart(12, '0');\n}\n\nreturn items.map(item => ({\n    json: {\n        rfq_project_id: projectId,\n        project_name: nombreProyecto,\n        rfq_document_id: documentId,\n        evaluation: tipoEvaluacion,\n        fase: item.fase || \"General\",\n        requisito_rfq: item.requisito_rfq || \"Sin Nombre\"\n    }\n}));"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2608,
                224
            ],
            "id": "80289444-c6a9-4246-b849-aefafc2fc7fb",
            "name": "Parsear Items1"
        },
        {
            "parameters": {
                "jsCode": "// =============================================\n// NODO: Agregar Resultados del Tipo Actual\n// =============================================\n\nconst items = $input.all();\n\n// Contar items insertados\nconst totalInserted = items.length;\n\n// Recuperar info del tipo actual\nlet tipoActual = \"unknown\";\ntry {\n    tipoActual = $('Loop por Tipo1').first().json.tipo_evaluacion;\n} catch(e) {}\n\nconsole.log(`✅ Tipo ${tipoActual}: ${totalInserted} items insertados`);\n\nreturn {\n    json: {\n        tipo_procesado: tipoActual,\n        items_insertados: totalInserted,\n        continuar_loop: true\n    }\n};"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                3072,
                432
            ],
            "id": "1d9956ca-fe06-4820-96c4-fdc707f30bc9",
            "name": "Agregar Resultados1"
        },
        {
            "parameters": {
                "jsCode": "// =============================================\n// NODO: Resumen Final\n// =============================================\n\n// Recuperar datos del proyecto\nlet projectId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet tiposDetectados = [];\n\ntry {\n    const projectNode = $('Generate IDs1').first().json;\n    projectId = projectNode.rfq_project_id;\n    fileTitle = projectNode.file_title;\n} catch(e) {}\n\ntry {\n    const clasificador = $('Clasificador de Tipos1').first().json;\n    const output = clasificador.output || clasificador;\n    tiposDetectados = output.tipos_detectados || [];\n} catch(e) {}\n\nconsole.log(\"========================================\");\nconsole.log(\"✅ PROCESAMIENTO RFQ COMPLETADO\");\nconsole.log(`   Proyecto: ${projectId}`);\nconsole.log(`   Archivo: ${fileTitle}`);\nconsole.log(`   Tipos procesados: ${tiposDetectados.length}`);\nconsole.log(\"========================================\");\n\nreturn {\n    json: {\n        success: true,\n        rfq_project_id: projectId,\n        file_title: fileTitle,\n        tipos_procesados: tiposDetectados,\n        mensaje: `RFQ procesada correctamente. ${tiposDetectados.length} tipo(s) de evaluación detectados y poblados.`\n    }\n};"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2096,
                -64
            ],
            "id": "77e6833f-92de-4d61-a3bf-74311eb7630d",
            "name": "Resumen Final1"
        },
        {
            "parameters": {
                "respondWith": "json",
                "responseBody": "={{ JSON.stringify($json) }}",
                "options": {}
            },
            "type": "n8n-nodes-base.respondToWebhook",
            "typeVersion": 1.5,
            "position": [
                2384,
                -64
            ],
            "id": "fd1925e1-6249-4049-9e99-928031482ad6",
            "name": "Respond Success1"
        },
        {
            "parameters": {
                "jsCode": "// =============================================\n// NODO: Base64 a Binary\n// =============================================\n\nconst inputData = $json;\nconst base64Data = inputData.file_binary;\n\nif (!base64Data || base64Data === \"\") {\n    throw new Error(\"❌ CRÍTICO: 'file_binary' está vacío\");\n}\n\nconst binaryData = Buffer.from(base64Data, 'base64');\n\nconsole.log(`✅ PDF convertido: ${binaryData.length} bytes`);\n\nreturn {\n    json: {\n        rfq_project_id: inputData.rfq_project_id,\n        rfq_document_id: inputData.rfq_document_id,\n        project_name: inputData.project_name,\n        file_title: inputData.file_title\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'rfq.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -528,
                304
            ],
            "id": "ce600cb8-a764-4b4d-a683-5a24a5f67075",
            "name": "Base64 a Binary3"
        },
        {
            "parameters": {
                "operation": "pdf",
                "options": {}
            },
            "type": "n8n-nodes-base.extractFromFile",
            "typeVersion": 1.1,
            "position": [
                -304,
                304
            ],
            "id": "8da72b1e-b1d0-4e26-8448-38b416579bcd",
            "name": "Extract from File3"
        },
        {
            "parameters": {
                "jsCode": "// =============================================\n// NODO: Generate IDs (MEJORADO)\n// =============================================\n// Reemplaza el nodo \"Generate Project ID\"\n// Este nodo genera IDs estables y únicos\n\nfunction stableHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(12, '0').substring(0, 12);\n}\n\nconst body = $json.body || $json;\nconst fileTitle = body.file_title || \"unknown.pdf\";\nconst fileBinary = body.file_binary || \"\";\n\n// NUEVO: Extraer project_name del webhook o usar file_title\nconst projectName = body.project_name || fileTitle.replace(/\\.(pdf|docx)$/i, '');\n\n// 1. PROJECT_ID (basado solo en nombre del proyecto, sin timestamp)\n//    → Mismo proyecto = mismo ID, aunque sean diferentes documentos\nconst projectId = 'proj_' + stableHash(projectName.toLowerCase().trim());\n\n// 2. DOCUMENT_ID (único por archivo, estable entre subidas)\n//    → Mismo archivo = mismo ID, incluso si se sube múltiples veces\nconst documentId = 'doc_' + stableHash(fileTitle + fileBinary.substring(0, 1000));\n\nconsole.log(\"=== GENERACIÓN DE IDs ===\");\nconsole.log(`Project Name: ${projectName}`);\nconsole.log(`Project ID: ${projectId}`);\nconsole.log(`Document ID: ${documentId}`);\nconsole.log(`File Title: ${fileTitle}`);\n\nreturn {\n  json: {\n    rfq_project_id: projectId,      // Compartido entre docs del mismo proyecto\n    rfq_document_id: documentId,    // Único por documento\n    project_name: projectName,      // Nombre legible del proyecto\n    file_title: fileTitle,\n    file_binary: fileBinary\n  }\n};"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                -752,
                304
            ],
            "id": "2bc0c301-8d0c-4212-be52-88aedc759a0b",
            "name": "Generate IDs1"
        },
        {
            "parameters": {
                "rules": {
                    "values": [
                        {
                            "conditions": {
                                "options": {
                                    "caseSensitive": true,
                                    "leftValue": "",
                                    "typeValidation": "strict",
                                    "version": 3
                                },
                                "conditions": [
                                    {
                                        "leftValue": "={{ $json.tipo_evaluacion }}",
                                        "rightValue": "Evaluation",
                                        "operator": {
                                            "type": "string",
                                            "operation": "contains"
                                        },
                                        "id": "c3ac36b0-dcd7-4e84-a72a-7e88b6f2fc2a"
                                    }
                                ],
                                "combinator": "and"
                            }
                        },
                        {
                            "conditions": {
                                "options": {
                                    "caseSensitive": true,
                                    "leftValue": "",
                                    "typeValidation": "strict",
                                    "version": 3
                                },
                                "conditions": [
                                    {
                                        "id": "529ee554-7a05-413a-9782-710d0deb6365",
                                        "leftValue": "={{ $json.tipo_evaluacion }}",
                                        "rightValue": "Deliverables",
                                        "operator": {
                                            "type": "string",
                                            "operation": "contains"
                                        }
                                    }
                                ],
                                "combinator": "and"
                            }
                        }
                    ]
                },
                "options": {}
            },
            "type": "n8n-nodes-base.switch",
            "typeVersion": 3.4,
            "position": [
                1984,
                432
            ],
            "id": "6e6f9109-1b36-43b3-ae0f-b69d72b1f4a4",
            "name": "Switch1"
        },
        {
            "parameters": {
                "model": "mistral:7b",
                "options": {
                    "temperature": 0.1,
                    "numCtx": 32768
                }
            },
            "type": "@n8n/n8n-nodes-langchain.lmOllama",
            "typeVersion": 1,
            "position": [
                2208,
                864
            ],
            "id": "3267c94f-d45e-4b89-8bae-10bb8d0e1d27",
            "name": "Ollama Extractor2",
            "credentials": {
                "ollamaApi": {
                    "id": "oS2Qqti9oVfsm8XZ",
                    "name": "Ollama account"
                }
            }
        },
        {
            "parameters": {
                "promptType": "define",
                "text": "=### TAREA: EXTRACCIÓN MASIVA DE ENTREGABLES (DELIVERABLES)\n\n**OBJETIVO:** Extraer **TODOS** los documentos, planos y entregables listados. **EXHAUSTIVIDAD TOTAL**.\n\n### INSTRUCCIONES CRÍTICAS (NO RESUMIR):\n1. **TABLAS:** Si encuentras una tabla, extrae **CADA FILA**. Si hay 140 filas, devuelve 140 ítems.\n2. **NO AGRUPES:** Mantén la granularidad.\n3. **FASES:** Infiere la fase/disciplina. Si no, usa 'General'.\n\n### EXTRACCIÓN DE LISTA DE ENTREGABLES (TEXTO DESORDENADO)\n\n### EXTRACCIÓN DE LISTA DE ENTREGABLES (TEXTO DESORDENADO)\n\nProyecto: {{ $json.nombre_proyecto }}\nEvaluación: {{ $('Loop por Tipo1').item.json.tipo_evaluacion }}\nArchivo: {{ $('Generate IDs1').first().json.file_title }}\n\n### TEXTO DEL PDF:\n{{ $json.texto_chunk }}\n\n### FORMATO DE SALIDA:\n```json\n[\n  { \"fase\": \"Process\", \"requisito_rfq\": \"PFD\" },\n  { \"fase\": \"Civil\", \"requisito_rfq\": \"Foundation Layout\" }\n]\n```\n\n**RESPUESTA (JSON PURO):**",
                "messages": {
                    "messageValues": [
                        {
                            "message": "=Eres una API que devuelve JSON. \n- NO saludes.\n- NO expliques.\n- NO uses markdown fuera del JSON.\n- Tu salida DEBE empezar con `[` y terminar con `]`."
                        }
                    ]
                },
                "batching": {}
            },
            "type": "@n8n/n8n-nodes-langchain.chainLlm",
            "typeVersion": 1.7,
            "position": [
                2256,
                640
            ],
            "id": "2691936a-b6fe-4593-b875-2ff7abc6bd19",
            "name": "LLM Extractor - Deliverables"
        },
        {
            "parameters": {
                "promptType": "define",
                "text": "=### TAREA CRÍTICA: EXTRACCIÓN DE REQUISITOS DEL RFQ (SCOPE DE COMPARACIÓN)\n\n**CONTEXTO:** Estamos procesando la **PETICIÓN DE OFERTA (RFQ)** del cliente.\n**OBJETIVO:** Extraer UNA LISTA EXHAUSTIVA DE TODOS LOS ÍTEMS/REQUISITOS solicitados para poder comparar las ofertas de los proveedores más tarde.\n\n### EXTRACCIÓN DE LISTA DE ENTREGABLES (TEXTO DESORDENADO)\n\nProyecto: {{ $json.nombre_proyecto }}\nEvaluación: {{ $('Loop por Tipo1').item.json.tipo_evaluacion }}\nArchivo: {{ $('Generate IDs1').first().json.file_title }}\n\n### TEXTO DEL PDF:\n{{ $json.texto_chunk }}\n\n---\n### INSTRUCCIONES ESPECÍFICAS DE EXTRACCIÓN:\n\n#### A. SI ES \"TECHNICAL EVALUATION\" (Ingeniería/Alcance):\n- **QUÉ BUSCAMOS:** La lista completa de **Documentos, Entregables, Planos o Estudios** que el proveedor DEBE entregar.\n- **ACCIÓN:** Extrae cada documento solicitado como un ítem individual.\n- **Ejemplo:**\n  - Texto: \"Vendor shall submit PFDs, P&IDs and Layouts.\"\n  - Output: `[{\"fase\": \"Process\", \"requisito_rfq\": \"PFDs\"}, {\"fase\": \"Process\", \"requisito_rfq\": \"P&IDs\"}, ...]`\n\n#### B. SI ES \"ECONOMICAL EVALUATION\" (Tabla de Precios/BOQ):\n- **QUÉ BUSCAMOS:** La lista de **CONCEPTOS / PARTIDAS** que el proveedor debe cotizar.\n- **ACCIÓN:** Extrae el nombre de cada partida o línea de costo.\n- **IMPORTANTE:** Como es una RFQ, es posible que NO haya precios (valores numéricos). Si solo hay conceptos vacíos para rellenar, extrae el **NOMBRE DEL CONCEPTO**.\n- **Ejemplo:**\n  - Texto: \"Item 1: Project Management (Lump Sum), Item 2: Engineering Hours\"\n  - Output: `[{\"fase\": \"General\", \"requisito_rfq\": \"Project Management (Lump Sum)\"}, {\"fase\": \"Engineering\", \"requisito_rfq\": \"Engineering Hours\"}]`\n\n### REGLAS DE ORO:\n1. **EXHAUSTIVIDAD:** No te dejes NADA. Mejor que sobren ítems a que falten. Si es una lista larga, extráela TODA.\n2. **ATOMICIDAD:** Un objeto JSON por cada línea o ítem.\n3. **SOLO REQUISITOS:** No extraigas texto de relleno (\"Introducción\", \"Alcance general\"), solo los ítems tangibles a evaluar/comparar.\n\n### FORMATO DE SALIDA (JSON ARRAY ESTRICTO):\n```json\n[\n  { \"fase\": \"Fase/Disciplina\", \"requisito_rfq\": \"Nombre del Requisito o Ítem\" },\n  { \"fase\": \"...\", \"requisito_rfq\": \"...\" }\n]\n```\n\n**RESPUESTA:**",
                "messages": {
                    "messageValues": [
                        {
                            "message": "=Eres un Extractor de Requisitos de Ingeniería. Tu trabajo es poblar la base de datos maestra de requisitos del proyecto.\nNO inventes datos.\nNO resumas.\nUsa JSON estricto."
                        }
                    ]
                },
                "batching": {}
            },
            "type": "@n8n/n8n-nodes-langchain.chainLlm",
            "typeVersion": 1.7,
            "position": [
                2256,
                224
            ],
            "id": "5a1ef88d-8849-4a4e-932f-4224c28ac672",
            "name": "LLM Extractor Tech-Econ"
        },
        {
            "parameters": {
                "jsCode": "// =============================================\n// NODO: Parsear Deliverables (ROBUST FALLBACK)\n// =============================================\n\nconst inputJson = $input.first().json;\n\n// 1. RECOGIDA DE DATOS RAW\nlet rawOutput = \"\";\nif (inputJson.output && typeof inputJson.output === 'string') rawOutput = inputJson.output;\nelse if (inputJson.text && typeof inputJson.text === 'string') rawOutput = inputJson.text;\nelse if (inputJson.content && typeof inputJson.content === 'string') rawOutput = inputJson.content;\nelse if (typeof inputJson === 'string') rawOutput = inputJson;\n\n// 2. INTENTO A: EXTRAER JSON\nlet items = [];\ntry {\n    const clean = rawOutput.replace(/```json/gi, '').replace(/```/g, '').trim();\n    const start = clean.indexOf('[');\n    const end = clean.lastIndexOf(']');\n    if (start !== -1 && end !== -1) {\n        items = JSON.parse(clean.substring(start, end + 1));\n    }\n} catch(e) {}\n\n// 3. INTENTO B: FALLBACK DE LISTA\nif (items.length === 0 && rawOutput) {\n    const lines = rawOutput.split('\\n');\n    let currentPhase = \"General\";\n    lines.forEach(line => {\n        const trimmed = line.trim();\n        if (!trimmed) return;\n        const numberMatch = trimmed.match(/^\\d+\\.\\s*(.*)/);\n        const bulletMatch = trimmed.match(/^[-•*]\\s*(.*)/);\n        if (numberMatch) {\n            items.push({ fase: currentPhase, requisito_rfq: numberMatch[1] });\n        } else if (bulletMatch) {\n             items.push({ fase: currentPhase, requisito_rfq: bulletMatch[1] });\n        }\n    });\n}\n\n// 4. HELPER: GENERAR ID ESTABLE\nfunction generateId(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) - hash) + str.charCodeAt(i);\n        hash = hash & hash;\n    }\n    return 'item_' + Math.abs(hash).toString(16).padStart(12, '0');\n}\n\n// 5. NORMALIZAR Y RETORNAR\nlet loopCtx = {};\ntry {\n   const outerLoop = $('Loop por Tipo1').first().json;\n   loopCtx = {\n       rfq_project_id: outerLoop.rfq_project_id,\n       rfq_document_id: outerLoop.rfq_document_id,\n       project_name: outerLoop.nombre_proyecto,\n       tipo_evaluacion: outerLoop.tipo_evaluacion\n   };\n} catch(e){}\n\nreturn items.map(item => {\n    const phase = item.fase || \"General\";\n    const req = item.requisito_rfq || \"Sin Nombre\";\n    return {\n        json: {\n            rfq_project_id: loopCtx.rfq_project_id || \"unknown\",\n            rfq_document_id: loopCtx.rfq_document_id || \"unknown\",\n            project_name: loopCtx.project_name || \"Unknown\",\n            evaluation: loopCtx.tipo_evaluacion || \"Deliverables\",\n            fase: phase,\n            requisito_rfq: req\n        }\n    };\n});"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2608,
                640
            ],
            "id": "9940f74a-05bf-46aa-94ac-5d619bfee9ae",
            "name": "Parsear deliverables"
        },
        {
            "parameters": {
                "dataTableId": {
                    "__rl": true,
                    "value": "KPHuqZb3nUk74c3J",
                    "mode": "list",
                    "cachedResultName": "Prueba",
                    "cachedResultUrl": "/projects/YoqFb1alZvPQmuNs/datatables/KPHuqZb3nUk74c3J"
                },
                "columns": {
                    "mappingMode": "defineBelow",
                    "value": {
                        "fase": "={{ $json.fase }}",
                        "project_name": "={{ $json.project_name }}",
                        "evaluation": "={{ $json.evaluation }}",
                        "requisito_rfq": "={{ $json.requisito_rfq }}"
                    },
                    "matchingColumns": [],
                    "schema": [
                        {
                            "id": "project_name",
                            "displayName": "project_name",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": false
                        },
                        {
                            "id": "evaluation",
                            "displayName": "evaluation",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": false
                        },
                        {
                            "id": "fase",
                            "displayName": "fase",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": false
                        },
                        {
                            "id": "requisito_rfq",
                            "displayName": "requisito_rfq",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": false
                        },
                        {
                            "id": "IDOM",
                            "displayName": "IDOM",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": true
                        },
                        {
                            "id": "SACYR",
                            "displayName": "SACYR",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": true
                        },
                        {
                            "id": "EA",
                            "displayName": "EA",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": true
                        },
                        {
                            "id": "SENER",
                            "displayName": "SENER",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": true
                        },
                        {
                            "id": "TRESCA",
                            "displayName": "TRESCA",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": true
                        },
                        {
                            "id": "WORLEY",
                            "displayName": "WORLEY",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": true
                        },
                        {
                            "id": "TECNICASREUNIDAS",
                            "displayName": "TECNICASREUNIDAS",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "readOnly": false,
                            "removed": true
                        }
                    ],
                    "attemptToConvertTypes": false,
                    "convertFieldsToString": false
                },
                "options": {}
            },
            "type": "n8n-nodes-base.dataTable",
            "typeVersion": 1.1,
            "position": [
                2880,
                432
            ],
            "id": "007b8a97-4d8a-4db5-b804-a3a764030b2f",
            "name": "Insertar Items en Tabla1"
        },
        {
            "parameters": {
                "model": "qwen3:8b",
                "options": {
                    "temperature": 0.1
                }
            },
            "type": "@n8n/n8n-nodes-langchain.lmOllama",
            "typeVersion": 1,
            "position": [
                2224,
                448
            ],
            "id": "6e437559-8100-4078-afac-7e7b133f32c2",
            "name": "Ollama Extractor1",
            "credentials": {
                "ollamaApi": {
                    "id": "oS2Qqti9oVfsm8XZ",
                    "name": "Ollama account"
                }
            }
        },
        {
            "parameters": {
                "schemaType": "manual",
                "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"fase\": {\n        \"type\": \"string\",\n        \"description\": \"Nombre de la disciplina o área (ej: Process Engineering, Mechanical Engineering, Civil and Structural, Electrical Engineering, etc.)\"\n      },\n      \"requisito_rfq\": {\n        \"type\": \"string\",\n        \"description\": \"Nombre del documento o entregable específico\"\n      }\n    },\n    \"required\": [\"fase\", \"requisito_rfq\"]\n  }\n}"
            },
            "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
            "typeVersion": 1.3,
            "position": [
                2400,
                864
            ],
            "id": "0a41ee77-9167-4097-aa0e-f6a8c7f25f85",
            "name": "Structured Output Parser1"
        },
        {
            "parameters": {
                "schemaType": "manual",
                "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"fase\": {\n        \"type\": \"string\",\n        \"description\": \"Fase del proyecto o disciplina (ej: PRE-FEED, FEED, EPC, Process Engineering, etc.)\"\n      },\n      \"requisito_rfq\": {\n        \"type\": \"string\",\n        \"description\": \"Requisito técnico o económico específico\"\n      }\n    },\n    \"required\": [\"fase\", \"requisito_rfq\"]\n  }\n}"
            },
            "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
            "typeVersion": 1.3,
            "position": [
                2400,
                448
            ],
            "id": "e9931bf4-6162-40e4-93a3-f9f17451d101",
            "name": "Structured Output Parser2"
        },
        {
            "parameters": {
                "jsCode": "// =============================================\n// NODO: Dividir en Trozos (Chunking)\n// =============================================\n\nconst input = $input.first().json;\nconst fullText = input.texto_rfq || \"\";\n\n// Tamaño: ~12,000 caracteres (aprox 3k-4k tokens)\nconst chunkSize = 8000;\nconst overlap = 1500;\nconst chunks = [];\n\nif (fullText.length <= chunkSize) {\n    chunks.push({\n        ...input,\n        texto_chunk: fullText,\n        chunk_index: 1,\n        total_chunks: 1\n    });\n} else {\n    let start = 0;\n    while (start < fullText.length) {\n        let end = start + chunkSize;\n        let chunk = fullText.substring(start, end);\n        \n        chunks.push({\n            ...input,\n            texto_chunk: chunk,\n            chunk_index: chunks.length + 1\n        });\n\n        start += (chunkSize - overlap);\n        if (start >= fullText.length) break;\n    }\n    chunks.forEach(c => c.total_chunks = chunks.length);\n}\n\nreturn chunks;"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1376,
                464
            ],
            "id": "b26d834d-a6ac-4fcb-9568-4bff6b5d692d",
            "name": "Dividir en Trozos1"
        },
        {
            "parameters": {
                "options": {
                    "reset": "={{ $json.reiniciar_bucle ? true : false }}"
                }
            },
            "type": "n8n-nodes-base.splitInBatches",
            "typeVersion": 3,
            "position": [
                1728,
                464
            ],
            "id": "b5a73881-bc4c-429d-a94e-2a6ad2a0e0d2",
            "name": "Loop por Trozo1"
        },
        {
            "parameters": {
                "jsCode": "const items = $input.all();\n\nreturn items.map(item => ({\n    json: {\n        ...item.json, // Mantiene todos los datos originales (incluido tipo_evaluacion)\n        \n        // Aquí está la corrección: Usamos dos puntos, no el igual.\n        reiniciar_bucle: true \n    }\n}));\n"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1552,
                464
            ],
            "id": "1426e2c3-645c-45ef-9db3-fcdb32ab2c0c",
            "name": "Reset Items1"
        },
        {
            "parameters": {
                "model": "mistral-large-latest",
                "options": {}
            },
            "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
            "typeVersion": 1,
            "position": [
                2336,
                992
            ],
            "id": "ac6c1fd0-d861-41cc-91c1-cc5f828cebfc",
            "name": "Mistral Cloud Chat Model",
            "credentials": {
                "mistralCloudApi": {
                    "id": "tDjuOnF6lpADMmd5",
                    "name": "Mistral Cloud account"
                }
            }
        },
        {
            "parameters": {
                "model": "qwen3-embedding:8b"
            },
            "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
            "typeVersion": 1,
            "position": [
                496,
                528
            ],
            "id": "c916edad-0c0a-4003-9ed5-c163309167c8",
            "name": "Embeddings Ollama1",
            "credentials": {
                "ollamaApi": {
                    "id": "oS2Qqti9oVfsm8XZ",
                    "name": "Ollama account"
                }
            }
        },
        {
            "parameters": {
                "mode": "insert",
                "tableName": {
                    "__rl": true,
                    "value": "documents_768",
                    "mode": "list",
                    "cachedResultName": "documents_768"
                },
                "options": {
                    "queryName": "match_documents_768"
                }
            },
            "id": "33571160-f022-429e-8fdf-0525a3c027ef",
            "name": "Insert into Supabase Vectorstore1",
            "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
            "typeVersion": 1,
            "position": [
                528,
                304
            ]
        },
        {
            "parameters": {
                "chunkSize": 1500,
                "chunkOverlap": 200,
                "options": {}
            },
            "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
            "typeVersion": 1,
            "position": [
                704,
                736
            ],
            "id": "d57e6466-3b20-47aa-af7f-b5c0949dbf33",
            "name": "Recursive Character Text Splitter1"
        },
        {
            "parameters": {
                "jsonMode": "expressionData",
                "jsonData": "={{ $json.text }}",
                "options": {
                    "metadata": {
                        "metadataValues": [
                            {
                                "name": "file_id",
                                "value": "={{ $json.metadata.file_id }}"
                            },
                            {
                                "name": "file_title",
                                "value": "={{ $json.metadata.file_title }}"
                            },
                            {
                                "name": "tipo_evaluacion",
                                "value": "={{ $json.metadata.tipo_evaluacion }}"
                            },
                            {
                                "name": "proveedor",
                                "value": "={{ $json.metadata.proveedor }}"
                            }
                        ]
                    }
                }
            },
            "id": "49b293dd-7c8c-4a59-8a25-76ff496f48d4",
            "name": "Default Data Loader1",
            "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
            "typeVersion": 1,
            "position": [
                624,
                528
            ]
        }
    ],
    "connections": {
        "Webhook RFQ": {
            "main": [
                [
                    {
                        "node": "Generate IDs1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Preparar Texto1": {
            "main": [
                [
                    {
                        "node": "Clasificador de Tipos1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Clasificador de Tipos1": {
            "main": [
                [
                    {
                        "node": "Insert into Supabase Vectorstore1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Ollama Clasificador1": {
            "ai_languageModel": [
                [
                    {
                        "node": "Clasificador de Tipos1",
                        "type": "ai_languageModel",
                        "index": 0
                    }
                ]
            ]
        },
        "Output Parser1": {
            "ai_outputParser": [
                [
                    {
                        "node": "Clasificador de Tipos1",
                        "type": "ai_outputParser",
                        "index": 0
                    }
                ]
            ]
        },
        "Expandir por Tipo1": {
            "main": [
                [
                    {
                        "node": "Loop por Tipo1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Loop por Tipo1": {
            "main": [
                [
                    {
                        "node": "Resumen Final1",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Dividir en Trozos1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Parsear Items1": {
            "main": [
                [
                    {
                        "node": "Insertar Items en Tabla1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Agregar Resultados1": {
            "main": [
                [
                    {
                        "node": "Loop por Trozo1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Resumen Final1": {
            "main": [
                [
                    {
                        "node": "Respond Success1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Base64 a Binary3": {
            "main": [
                [
                    {
                        "node": "Extract from File3",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Extract from File3": {
            "main": [
                [
                    {
                        "node": "Preparar Texto1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Generate IDs1": {
            "main": [
                [
                    {
                        "node": "Base64 a Binary3",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Switch1": {
            "main": [
                [
                    {
                        "node": "LLM Extractor Tech-Econ",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "LLM Extractor - Deliverables",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Ollama Extractor2": {
            "ai_languageModel": [
                []
            ]
        },
        "LLM Extractor - Deliverables": {
            "main": [
                [
                    {
                        "node": "Parsear deliverables",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "LLM Extractor Tech-Econ": {
            "main": [
                [
                    {
                        "node": "Parsear Items1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Parsear deliverables": {
            "main": [
                [
                    {
                        "node": "Insertar Items en Tabla1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Insertar Items en Tabla1": {
            "main": [
                [
                    {
                        "node": "Agregar Resultados1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Ollama Extractor1": {
            "ai_languageModel": [
                [
                    {
                        "node": "LLM Extractor Tech-Econ",
                        "type": "ai_languageModel",
                        "index": 0
                    }
                ]
            ]
        },
        "Dividir en Trozos1": {
            "main": [
                [
                    {
                        "node": "Reset Items1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Loop por Trozo1": {
            "main": [
                [
                    {
                        "node": "Loop por Tipo1",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Switch1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Reset Items1": {
            "main": [
                [
                    {
                        "node": "Loop por Trozo1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Mistral Cloud Chat Model": {
            "ai_languageModel": [
                [
                    {
                        "node": "LLM Extractor - Deliverables",
                        "type": "ai_languageModel",
                        "index": 0
                    }
                ]
            ]
        },
        "Embeddings Ollama1": {
            "ai_embedding": [
                [
                    {
                        "node": "Insert into Supabase Vectorstore1",
                        "type": "ai_embedding",
                        "index": 0
                    }
                ]
            ]
        },
        "Insert into Supabase Vectorstore1": {
            "main": [
                [
                    {
                        "node": "Expandir por Tipo1",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Recursive Character Text Splitter1": {
            "ai_textSplitter": [
                [
                    {
                        "node": "Default Data Loader1",
                        "type": "ai_textSplitter",
                        "index": 0
                    }
                ]
            ]
        },
        "Default Data Loader1": {
            "ai_document": [
                [
                    {
                        "node": "Insert into Supabase Vectorstore1",
                        "type": "ai_document",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "pinData": {},
    "meta": {
        "templateCredsSetupCompleted": true,
        "instanceId": "53140335eaf11280ef77ef2f5a378f48c2b28e822e3e0d96563cdd92175c0eff"
    }
}