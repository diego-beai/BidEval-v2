{
  "nodes": [
    {
      "parameters": {
        "content": "### Ingesta de RFQ, actualizaci√≥n de requisitos",
        "height": 1280,
        "width": 4390,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -944,
        -96
      ],
      "id": "33ac86e5-7757-430c-ac6b-369d62d2b04f",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ingesta-rfq",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -832,
        112
      ],
      "id": "25ccf092-f3b9-4c62-8aed-a8720363de1c",
      "name": "Webhook RFQ",
      "webhookId": "ce591645-290f-46ab-a153-0dca369b1ebd"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Preparar Texto (Agregador de P√°ginas)\n// =============================================\n\nconst items = $input.all();\nif (!items || items.length === 0) {\n    return { json: { error: \"No input items received\" } };\n}\n\n// Recuperar metadatos del inicio del flujo (Generate IDs1)\nlet metadata = {};\ntry {\n    metadata = $('Generate IDs1').first().json;\n} catch (e) {\n    console.log(\"‚ö†Ô∏è No se pudo recuperar metadata de Generate IDs1\");\n}\n\n// 1. Agregado de Texto Completo (todas las p√°ginas)\n// Intentamos md_content primero (mejor para LLMs), luego text\nlet fullText = items.map(item => item.json.md_content || item.json.text || \"\").join('\\n\\n').trim();\n\nif (!fullText) {\n    console.log(\"‚ö†Ô∏è Advertencia: No se extrajo texto del documento.\");\n}\n\n// 2. Limpieza b√°sica\nfullText = fullText.replace(/\\x00/g, ''); // Eliminar caracteres nulos\n\n// 3. Preparar fragmento para clasificaci√≥n (m√°x 40k chars para no saturar context)\nconst textForClassification = fullText.substring(0, 40000);\n\nconsole.log(`‚úÖ Texto preparado: ${items.length} p√°ginas aggregadas. Chars: ${fullText.length}`);\n\nreturn {\n    json: {\n        rfq_project_id: metadata.rfq_project_id || \"unknown\",\n        rfq_document_id: metadata.rfq_document_id || \"unknown\",\n        project_name: metadata.project_name || \"Sin Nombre\",\n        file_title: metadata.file_title || \"document.pdf\",\n        text: fullText, \n        text_for_classification: textForClassification || \"SIN TEXTO DETECTADO\",\n        pages_count: items.length\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        112
      ],
      "id": "726ca271-a0e5-4ab9-8ef4-ce39d03869ce",
      "name": "Preparar Texto1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### DOCUMENTO RFQ\n\nNombre del Archivo: {{ $json.file_title }}\n\n### CONTENIDO (FRAGMENTO):\n{{ $json.pages ? $json.pages.slice(0, 1).map(p => p.text).join('\\n\\n') : ($json.text ? $json.text.substring(0, 2000) : 'SIN TEXTO') }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=## TAREA: CLASIFICAR TIPOS DE EVALUACI√ìN EN DOCUMENTO RFQ Y NOMBRE DEL PROYECTO\n\nEres un auditor experto en documentaci√≥n de ingenier√≠a EPC del sector energ√©tico.\nAnaliza el documento RFQ y determina qu√© tipos de evaluaci√≥n contiene y el nombre del proyecto.\n\n### IMPORTANTE\n\nUn documento puede contener 1, 2, 3 o 4 tipos de evaluaci√≥n.\n**No asumas que est√°n todos.**\nDetecta **SOLO** los que realmente est√°n presentes.\n\n### REGLA DE T√çTULO (CR√çTICA)\n**Si el nombre del archivo o el t√≠tulo del documento es \"RFQ\" o \"Request for quotation\", clasifica autom√°ticamente como \"Technical Evaluation\" Y \"Economical Evaluation\"**, ya que por definici√≥n una licitaci√≥n completa implica evaluar ambos alcances.\n\n### TIPOS POSIBLES\n\n1. **Technical Evaluation**\n\n   **Evidencia requerida:**\n   - Secciones de **Scope of Work**, **Scope of Facilities**, **Technical Requirements**\n   - Requisitos t√©cnicos generales (metodolog√≠a, normativas, est√°ndares)\n   - Descripci√≥n de alcance por fases (PRE-FEED, FEED, EPC, Conceptual, Basic Engineering, Detailed Engineering)\n   - Especificaciones de ingenier√≠a, criterios de dise√±o\n\n2. **Economical Evaluation**\n\n   **Evidencia requerida:**\n   - Tablas de **precios** o **tarifas**\n   - **Hours per discipline**, **EUR/hora**, **USD/hour**, tarifas horarias\n   - Formato de **cotizaci√≥n econ√≥mica**, **pricing schedule**\n   - **Desglose de costos por fase** o por disciplina\n   - Secciones **Commercial**, **Pricing**, **Budget**, **Cost Breakdown**\n\n3. **Pre-FEED Deliverables** (o equivalentes: Conceptual Design Deliverables, Feasibility Deliverables)\n\n   **Evidencia requerida:**\n   - Lista o tabla de documentos a entregar en fase preliminar/conceptual\n   - Organizada por **disciplinas** (Process, Mechanical, Electrical, Civil, I&C, etc.)\n   - Documentos conceptuales: **Basis of Design**, **PFDs**, **P&IDs preliminares**, **Block diagrams**\n   - Estudios: **HAZID**, **Risk Analysis**, **Site Assessment**\n   - **CAPEX Class 3‚Äì5 (AACEI)**, estimaciones preliminares (+/- 30%)\n\n4. **FEED Deliverables** (o equivalentes: Basic Engineering Deliverables)\n\n   **Evidencia requerida:**\n   - Lista o tabla de documentos a entregar en fase FEED/Basic Engineering\n   - Documentos m√°s detallados que en Pre-FEED\n   - **Especificaciones de compra**, **datasheets**, **equipment lists**\n   - **MTO** (Material Take-Off), **cable schedules**, **instrument lists**\n   - **CAPEX Class 2‚Äì3 (AACEI)**, estimaciones m√°s precisas (+/- 15%)\n   - **HAZOP**, **SIL studies**, **3D Model review**\n\n### NOMENCLATURA ALTERNATIVA\n\nEl documento puede usar nombres diferentes para las mismas fases. Aqu√≠ tienes equivalencias:\n\n| Nombre en RFQ | Clasificar como |\n|---------------|-----------------|\n| Pre-FEED, Conceptual Design, Feasibility Study, Phase 1 | Pre-FEED Deliverables |\n| FEED, Basic Engineering, Basic Design, Phase 2 | FEED Deliverables |\n| Technical Proposal, Technical Offer, Scope of Work | Technical Evaluation |\n| Commercial Proposal, Pricing, Cost Estimate, Quotation | Economical Evaluation |\n\n### C√ìMO DIFERENCIAR\n\n| Si ves... | Es probablemente... |\n| --- | --- |\n| **Scope of Work** general, **metodolog√≠a**, requisitos t√©cnicos | **Technical Evaluation** |\n| Tablas de precios, horas, **EUR/h**, tarifas | **Economical Evaluation** |\n| Lista de docs por disciplina + fase preliminar/conceptual | **Pre-FEED Deliverables** |\n| Lista de docs por disciplina + fase FEED/Basic Engineering | **FEED Deliverables** |\n\n### TAREA OBLIGATORIA: IDENTIFICAR NOMBRE DEL PROYECTO\n\nEsta tarea es **obligatoria** y **NO** puede omitirse.\n**Deber√°s devolver SIEMPRE** un valor para `nombre_proyecto`.\n\n### ORDEN DE PRIORIDAD (estricto)\n\n1. **Nombre expl√≠cito del proyecto**\n   - Busca en la **portada** o el **t√≠tulo principal**.\n   - Encabezados repetidos que contengan el nombre del proyecto.\n   - Frases como **Project**, **Project Name**, **Project Title**, **RFQ for...**\n\n2. **Nombre impl√≠cito pero oficial**\n   Si no encuentras un t√≠tulo literal, genera el nombre combinando los siguientes elementos:\n   - Tipo de instalaci√≥n energ√©tica (**Hydrogen Plant**, **PV Plant**, **Solar Plant**, **Wind Farm**, **Battery Storage**, **Power Plant**, **Electrolyzer**, **Substation**, etc.)\n   - Ubicaci√≥n (ciudad, regi√≥n o pa√≠s)\n   - Cliente o **site** si est√° claramente indicado\n   - Capacidad si se menciona (ej: 100 MW, 50 MWp, 20 MW electrolyzer)\n   - Ejemplo: **100 MW Solar PV Plant ‚Äì Andaluc√≠a, Spain**\n\n3. **Fallback obligatorio**\n   Si el documento no declara claramente un nombre:\n   - **NO dejes el campo vac√≠o**.\n   - **NO uses valores gen√©ricos**.\n   - Genera un nombre t√©cnico-descriptivo utilizando:\n     - **Formato obligatorio**: `<Tipo de Proyecto Energ√©tico> ‚Äì <Ubicaci√≥n o Cliente> (RFQ)`\n   - Ejemplo: **Green Hydrogen Production Facility ‚Äì Northern Spain (RFQ)**\n\n### REGLAS DURAS\n\n- **No usar**: Unknown, N/A, Not specified\n- **No inventar nombres comerciales**\n- El nombre debe ser v√°lido para un entorno EPC / PMO del sector energ√©tico\n- Prioriza claridad, trazabilidad y profesionalidad\n\n### FORMATO DE SALIDA (JSON PLANO ‚Äì ESTRICTO)\n\n**ATENCI√ìN: REGLAS DE ESTRUCTURA**\n1. Devuelve **√öNICAMENTE** un objeto JSON que empiece por `{` y termine por `}`.\n2. **PROHIBIDO** devolver el JSON dentro de una lista o array `[]`.\n3. **PROHIBIDO** usar claves contenedoras como `\"output\"`, `\"response\"` o `\"json\"`. El nivel ra√≠z debe tener directamente las claves `tipos_detectados` y `nombre_proyecto`.\n4. No incluyas bloques de c√≥digo markdown (\\`\\`\\`json). Solo el texto plano del JSON.\n\n**FORMATO DE SALIDA CORRECTO:**\n{\n  \"tipos_detectados\": [\"Technical Evaluation\", \"Pre-FEED Deliverables\"],\n  \"nombre_proyecto\": \"Hydrogen Production Plant ‚Äì La Zaida, Spain\",\n  \"razonamiento\": \"El documento incluye un Scope of Work t√©cnico y una lista de documentos para la fase Pre-FEED...\"\n}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        -16,
        336
      ],
      "id": "54dcda26-569b-4978-9e4d-31ca527301f8",
      "name": "Clasificador de Tipos1"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        -64,
        560
      ],
      "id": "44e8a88e-58e3-47fa-b36c-25a538c0d31a",
      "name": "Ollama Clasificador1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"tipos_detectados\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\"Technical Evaluation\", \"Economical Evaluation\", \"Pre-FEED Deliverables\", \"FEED Deliverables\"]\n      }\n    },\n    \"nombre_proyecto\": {\n      \"type\": \"string\",\n      \"description\": \"Nombre del proyecto extra√≠do del documento RFQ\"\n    },\n    \"razonamiento\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"tipos_detectados\", \"nombre_proyecto\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        176,
        560
      ],
      "id": "f5dac8a0-fb5a-4491-a7d4-ce297463fdd4",
      "name": "Output Parser1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Expandir por Tipo (CORREGIDO v3)\n// =============================================\n\n// 1. Recuperar metadatos de nodos anteriores\nlet projectId = \"unknown\";\nlet documentId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet fullText = \"\";\nlet metadataProjectName = \"\";\n\ntry {\n    const textNode = $('Preparar Texto1').first().json;\n    projectId = textNode.rfq_project_id || \"unknown\";\n    documentId = textNode.rfq_document_id || \"unknown\";\n    fileTitle = textNode.file_title || \"unknown\";\n    fullText = textNode.text || \"\";\n    metadataProjectName = textNode.project_name || \"\"; \n} catch(e) {\n    console.log(\"‚ö†Ô∏è No se pudieron leer metadatos de Preparar Texto1\");\n}\n\n// 2. OBTENER DATOS DEL CLASIFICADOR DIRECTAMENTE\nlet output = {\n    tipos_detectados: [],\n    nombre_proyecto: \"\"\n};\n\ntry {\n    const clasificadorData = $('Clasificador de Tipos1').first().json;\n    console.log(\"üìä Datos del clasificador:\", JSON.stringify(clasificadorData));\n    \n    // El Output Parser devuelve los datos en .output\n    if (clasificadorData.output && Array.isArray(clasificadorData.output.tipos_detectados)) {\n        output = clasificadorData.output;\n        console.log(\"‚úÖ CASO A: Datos en .output\");\n    } else if (Array.isArray(clasificadorData.tipos_detectados)) {\n        output = clasificadorData;\n        console.log(\"‚úÖ CASO B: Datos directos\");\n    } else {\n        let rawText = clasificadorData.output || clasificadorData.text || JSON.stringify(clasificadorData);\n        if (typeof rawText !== 'string') rawText = JSON.stringify(rawText);\n        \n        const clean = rawText.replace(/```json/gi, '').replace(/```/g, '').trim();\n        const start = clean.indexOf('{');\n        const end = clean.lastIndexOf('}');\n        \n        if (start !== -1 && end !== -1) {\n            output = JSON.parse(clean.substring(start, end + 1));\n            console.log(\"‚úÖ CASO C: Parseado manual\");\n        }\n    }\n} catch (e) {\n    console.log(\"‚ö†Ô∏è Error accediendo al Clasificador:\", e.message);\n}\n\n// 3. Normalizaci√≥n de Datos\nlet finalProjectName = output.nombre_proyecto || metadataProjectName;\n\nif (!finalProjectName || finalProjectName === \"Sin Nombre\") {\n    finalProjectName = fileTitle.replace(/\\.pdf$/i, '') + \" (Project)\";\n}\n\n// Lista de Tipos - RESPETAR LO QUE DETECT√ì EL CLASIFICADOR\nlet tipos = output.tipos_detectados || [];\nif (!Array.isArray(tipos)) tipos = [];\n\nconsole.log(\"üìã Tipos detectados por IA:\", JSON.stringify(tipos));\n\n// REGLA DE FALLBACK (solo si el clasificador NO detect√≥ nada)\nif (tipos.length === 0) {\n    const titleLower = (fileTitle || \"\").toLowerCase();\n    const isRFQ = titleLower.includes(\"rfq\") || titleLower.includes(\"request for quotation\");\n    \n    if (isRFQ) {\n        tipos.push(\"Technical Evaluation\", \"Economical Evaluation\");\n        console.log(\"‚ÑπÔ∏è Fallback: Archivo RFQ sin tipos detectados, a√±adiendo Technical y Economical.\");\n    } else {\n        tipos.push(\"Technical Evaluation\");\n        console.log(\"‚ÑπÔ∏è Fallback: Sin tipos detectados, a√±adiendo Technical por defecto.\");\n    }\n}\n// Si el clasificador S√ç detect√≥ tipos, los respetamos tal cual\n\n// Eliminar duplicados\ntipos = [...new Set(tipos)];\n\nconsole.log(\"üìã Tipos finales a procesar:\", JSON.stringify(tipos));\n\n// 4. Generar Salida (Expandir items)\nreturn tipos.map((tipo, idx) => ({\n    json: {\n        tipo_evaluacion: tipo,\n        rfq_project_id: projectId,\n        rfq_document_id: documentId,\n        nombre_proyecto: finalProjectName,\n        file_title: fileTitle,\n        texto_rfq: fullText,\n        indice: idx + 1,\n        total_tipos: tipos.length\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        944,
        336
      ],
      "id": "9ed69fba-e8c2-421d-81df-a272c966529a",
      "name": "Expandir por Tipo1"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1152,
        336
      ],
      "id": "d1797574-16ef-456b-b9db-a0ca560766e3",
      "name": "Loop por Tipo1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear Final (Con Nombre Proyecto)\n// =============================================\nconst inputJson = $input.first().json;\n// Asegurar que sea string\nlet llmOutput = \"\";\nif (typeof inputJson === 'string') llmOutput = inputJson;\nelse if (inputJson.text && typeof inputJson.text === 'string') llmOutput = inputJson.text;\nelse if (inputJson.output && typeof inputJson.output === 'string') llmOutput = inputJson.output;\nelse if (inputJson.content && typeof inputJson.content === 'string') llmOutput = inputJson.content;\nelse llmOutput = JSON.stringify(inputJson.text || inputJson.output || inputJson.content || inputJson);\n\nllmOutput = String(llmOutput || \"[]\");\n\n// 1. Recuperar Contexto del Loop\nlet projectId = \"unknown\";\nlet documentId = \"unknown\";\nlet tipoEvaluacion = \"Unknown\";\nlet nombreProyecto = \"Sin Nombre\";\n\ntry {\n    const loopData = $('Loop por Tipo1').first().json;\n    projectId = loopData.rfq_project_id;\n    documentId = loopData.rfq_document_id;\n    tipoEvaluacion = loopData.tipo_evaluacion;\n    nombreProyecto = loopData.nombre_proyecto || \"Sin Nombre\";\n} catch(e) {}\n\n// 2. L√≥gica de Parsing\nlet items = [];\n\ntry {\n    let clean = llmOutput.replace(/```json/gi, '').replace(/```/g, '').trim();\n    const start = clean.indexOf('[');\n    const end = clean.lastIndexOf(']');\n    if (start !== -1 && end !== -1) {\n        items = JSON.parse(clean.substring(start, end + 1));\n    }\n} catch(e) {}\n\nif (items.length === 0) {\n    const lines = llmOutput.split('\\n');\n    let currentPhase = \"General\";\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        if (/^\\d+\\./.test(line) && !line.includes('Estimate')) {\n            const text = line.replace(/^\\d+\\.\\s*/, '').trim();\n            if (i+1 < lines.length && (lines[i+1].trim().startsWith('-') || lines[i+1].trim().startsWith('‚Ä¢'))) {\n                currentPhase = text;\n            } else {\n                 items.push({ fase: \"General\", requisito_rfq: text });\n            }\n        }\n        else if (line.startsWith('-') || line.startsWith('‚Ä¢')) {\n            items.push({ fase: currentPhase, requisito_rfq: line.replace(/^[-‚Ä¢]\\s*/, '').trim() });\n        }\n    }\n}\n\nfunction generateId(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) - hash) + str.charCodeAt(i);\n        hash = hash & hash;\n    }\n    return 'item_' + Math.abs(hash).toString(16).padStart(12, '0');\n}\n\nreturn items.map(item => ({\n    json: {\n        rfq_project_id: projectId,\n        project_name: nombreProyecto,\n        rfq_document_id: documentId,\n        evaluation: tipoEvaluacion,\n        fase: item.fase || \"General\",\n        requisito_rfq: item.requisito_rfq || \"Sin Nombre\"\n    }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2720,
        256
      ],
      "id": "8e71a233-5d8f-4ace-b0d5-629766001ab9",
      "name": "Parsear Items1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Agregar Resultados del Tipo Actual\n// =============================================\n\nconst items = $input.all();\n\n// Contar items insertados\nconst totalInserted = items.length;\n\n// Recuperar info del tipo actual\nlet tipoActual = \"unknown\";\ntry {\n    tipoActual = $('Loop por Tipo1').first().json.tipo_evaluacion;\n} catch(e) {}\n\nconsole.log(`‚úÖ Tipo ${tipoActual}: ${totalInserted} items insertados`);\n\nreturn {\n    json: {\n        tipo_procesado: tipoActual,\n        items_insertados: totalInserted,\n        continuar_loop: true\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3248,
        464
      ],
      "id": "222fa567-8d5b-41b2-9dd4-dced4e05e8b7",
      "name": "Agregar Resultados1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Resumen Final\n// =============================================\n\n// Recuperar datos del proyecto\nlet projectId = \"unknown\";\nlet fileTitle = \"unknown\";\nlet tiposDetectados = [];\n\ntry {\n    const projectNode = $('Generate IDs1').first().json;\n    projectId = projectNode.rfq_project_id;\n    fileTitle = projectNode.file_title;\n} catch(e) {}\n\ntry {\n    const clasificador = $('Clasificador de Tipos1').first().json;\n    const output = clasificador.output || clasificador;\n    tiposDetectados = output.tipos_detectados || [];\n} catch(e) {}\n\nconsole.log(\"========================================\");\nconsole.log(\"‚úÖ PROCESAMIENTO RFQ COMPLETADO\");\nconsole.log(`   Proyecto: ${projectId}`);\nconsole.log(`   Archivo: ${fileTitle}`);\nconsole.log(`   Tipos procesados: ${tiposDetectados.length}`);\nconsole.log(\"========================================\");\n\nreturn {\n    json: {\n        success: true,\n        rfq_project_id: projectId,\n        file_title: fileTitle,\n        tipos_procesados: tiposDetectados,\n        mensaje: `RFQ procesada correctamente. ${tiposDetectados.length} tipo(s) de evaluaci√≥n detectados y poblados.`\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2448,
        -32
      ],
      "id": "1697282a-5c4a-4e39-b29f-ebe9c7a4bd90",
      "name": "Resumen Final1"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        2736,
        -32
      ],
      "id": "14e12fba-929a-407a-a9de-3347a8063565",
      "name": "Respond Success1"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Base64 a Binary\n// =============================================\n\n// Recuperar metadatos del inicio del flujo (Generate IDs1)\nlet inputData = {};\ntry {\n    inputData = $('Generate IDs1').first().json;\n} catch (e) {\n    inputData = $json; // Fallback\n}\n\nconst base64Data = inputData.file_binary;\n\nif (!base64Data || base64Data === \"\") {\n    throw new Error(\"‚ùå CR√çTICO: 'file_binary' est√° vac√≠o\");\n}\n\nconst binaryData = Buffer.from(base64Data, 'base64');\n\nconsole.log(`‚úÖ PDF convertido: ${binaryData.length} bytes`);\n\nreturn {\n    json: {\n        rfq_project_id: inputData.rfq_project_id || \"unknown\",\n        rfq_document_id: inputData.rfq_document_id || \"unknown\",\n        project_name: inputData.project_name || \"Sin Nombre\",\n        file_title: inputData.file_title || \"document.pdf\"\n    },\n    binary: {\n        data: {\n            data: binaryData.toString('base64'),\n            mimeType: 'application/pdf',\n            fileName: inputData.file_title || 'rfq.pdf',\n            fileSize: binaryData.length\n        }\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        112
      ],
      "id": "cc19a068-1d24-45e9-b5be-0a7521b3e5e6",
      "name": "Base64 a Binary3"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        64,
        112
      ],
      "id": "e9f0a463-0962-487a-a87e-aac88ba2e0c5",
      "name": "Extract from File3"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Generate Stable ID + Detectar Modo (CORREGIDO)\n// =============================================\n\nfunction simpleHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(16, '0').substring(0, 16);\n}\n\n// Aseguramos capturar el body correctamente desde el nodo anterior\nconst body = $json.body || $json;\n\n// CAMPOS B√ÅSICOS\nconst originalFileId = body.file_id || \"unknown\";\nconst fileTitle = body.file_title || \"unknown.pdf\";\nconst fileBinary = body.file_binary || \"\";\nconst fileUrl = body.file_url || \"unknown\";\n\n// ‚úÖ EXTRAER METADATA DEL USUARIO\n// Usamos el operador ?. para evitar errores si metadata no existe\nconst metadata = body.metadata || {};\nconst rfqProjectName = metadata.proyect_name || body.project_name || null;\nconst userProveedor = metadata.proveedor || null;\nconst userTipoEval = metadata.evaluation || null; \n\n// ‚úÖ DETERMINAR MODO DE OPERACI√ìN\nlet modoOperacion = \"CLASIFICADOR\"; \nlet datosCompletos = false;\n\nif (userProveedor && userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0) {\n    modoOperacion = \"VALIDADOR\";\n    datosCompletos = true;\n} else if (userProveedor || (userTipoEval && Array.isArray(userTipoEval) && userTipoEval.length > 0)) {\n    modoOperacion = \"HIBRIDO\";\n}\n\n// Generar ID estable basado en el t√≠tulo (como pediste)\nconst normalizedTitle = fileTitle.toLowerCase().trim();\nconst stableId = simpleHash(normalizedTitle);\n\n// ID de Documento (√∫nico por contenido para evitar duplicados en Supabase)\nconst documentId = 'doc_' + stableId;\n\nreturn {\n  json: {\n    file_id: stableId, // Este es tu ID estable\n    rfq_document_id: documentId,\n    file_id_original: originalFileId,\n    file_title: fileTitle,\n    file_binary: fileBinary,\n    file_url: fileUrl,\n    \n    // Si no hay nombre de proyecto, usamos el nombre del archivo como fallback\n    project_name: rfqProjectName || fileTitle.replace(/\\.[^/.]+$/, \"\"),\n    rfq_project_id: rfqProjectName ? 'proj_' + simpleHash(rfqProjectName.toLowerCase().trim()) : 'proj_generic',\n    \n    user_proveedor: userProveedor,\n    user_tipo_evaluacion: userTipoEval,\n    modo_operacion: modoOperacion,\n    datos_usuario_completos: datosCompletos,\n    \n    // Guardamos una copia limpia para los nodos siguientes\n    metadata_limpia: {\n        proyect_name: rfqProjectName,\n        proveedor: userProveedor,\n        evaluation: userTipoEval\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        112
      ],
      "id": "9f8df502-a9c9-477c-87cb-ebfa9bf9c38d",
      "name": "Generate IDs1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.tipo_evaluacion }}",
                    "rightValue": "Evaluation",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "c3ac36b0-dcd7-4e84-a72a-7e88b6f2fc2a"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "529ee554-7a05-413a-9782-710d0deb6365",
                    "leftValue": "={{ $json.tipo_evaluacion }}",
                    "rightValue": "Deliverables",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        2048,
        464
      ],
      "id": "24d53591-40cd-4e54-a0ba-b09f8dbb1022",
      "name": "Switch1"
    },
    {
      "parameters": {
        "model": "mistral:7b",
        "options": {
          "temperature": 0.1,
          "numCtx": 32768
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2304,
        912
      ],
      "id": "86d08ba6-4cec-49d1-8c92-0d835c6c9c0c",
      "name": "Ollama Extractor2",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### TAREA: EXTRACCI√ìN MASIVA DE ENTREGABLES (DELIVERABLES)\n\n**OBJETIVO:** Extraer **TODOS** los documentos, planos y entregables listados. **EXHAUSTIVIDAD TOTAL**.\n\n### INSTRUCCIONES CR√çTICAS (NO RESUMIR):\n1. **TABLAS:** Si encuentras una tabla, extrae **CADA FILA**. Si hay 140 filas, devuelve 140 √≠tems.\n2. **NO AGRUPES:** Mant√©n la granularidad.\n3. **FASES:** Infiere la fase/disciplina. Si no, usa 'General'.\n\n### EXTRACCI√ìN DE LISTA DE ENTREGABLES (TEXTO DESORDENADO)\n\n### EXTRACCI√ìN DE LISTA DE ENTREGABLES (TEXTO DESORDENADO)\n\nProyecto: {{ $json.nombre_proyecto }}\nEvaluaci√≥n: {{ $('Loop por Tipo1').item.json.tipo_evaluacion }}\nArchivo: {{ $('Generate IDs1').first().json.file_title }}\n\n### TEXTO DEL PDF:\n{{ $json.texto_chunk }}\n\n### FORMATO DE SALIDA:\n```json\n[\n  { \"fase\": \"Process\", \"requisito_rfq\": \"PFD\" },\n  { \"fase\": \"Civil\", \"requisito_rfq\": \"Foundation Layout\" }\n]\n```\n\n**RESPUESTA (JSON PURO):**",
        "messages": {
          "messageValues": [
            {
              "message": "=Eres una API que devuelve JSON. \n- NO saludes.\n- NO expliques.\n- NO uses markdown fuera del JSON.\n- Tu salida DEBE empezar con `[` y terminar con `]`."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2368,
        688
      ],
      "id": "7ffdb680-2de1-4697-95c0-c34b75202800",
      "name": "LLM Extractor - Deliverables"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Parsear Deliverables (ROBUST FALLBACK)\n// =============================================\n\nconst inputJson = $input.first().json;\n\n// 1. RECOGIDA DE DATOS RAW\nlet rawOutput = \"\";\nif (inputJson.output && typeof inputJson.output === 'string') rawOutput = inputJson.output;\nelse if (inputJson.text && typeof inputJson.text === 'string') rawOutput = inputJson.text;\nelse if (inputJson.content && typeof inputJson.content === 'string') rawOutput = inputJson.content;\nelse if (typeof inputJson === 'string') rawOutput = inputJson;\n\n// 2. INTENTO A: EXTRAER JSON\nlet items = [];\ntry {\n    const clean = rawOutput.replace(/```json/gi, '').replace(/```/g, '').trim();\n    const start = clean.indexOf('[');\n    const end = clean.lastIndexOf(']');\n    if (start !== -1 && end !== -1) {\n        items = JSON.parse(clean.substring(start, end + 1));\n    }\n} catch(e) {}\n\n// 3. INTENTO B: FALLBACK DE LISTA\nif (items.length === 0 && rawOutput) {\n    const lines = rawOutput.split('\\n');\n    let currentPhase = \"General\";\n    lines.forEach(line => {\n        const trimmed = line.trim();\n        if (!trimmed) return;\n        const numberMatch = trimmed.match(/^\\d+\\.\\s*(.*)/);\n        const bulletMatch = trimmed.match(/^[-‚Ä¢*]\\s*(.*)/);\n        if (numberMatch) {\n            items.push({ fase: currentPhase, requisito_rfq: numberMatch[1] });\n        } else if (bulletMatch) {\n             items.push({ fase: currentPhase, requisito_rfq: bulletMatch[1] });\n        }\n    });\n}\n\n// 4. HELPER: GENERAR ID ESTABLE\nfunction generateId(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        hash = ((hash << 5) - hash) + str.charCodeAt(i);\n        hash = hash & hash;\n    }\n    return 'item_' + Math.abs(hash).toString(16).padStart(12, '0');\n}\n\n// 5. NORMALIZAR Y RETORNAR\nlet loopCtx = {};\ntry {\n   const outerLoop = $('Loop por Tipo1').first().json;\n   loopCtx = {\n       rfq_project_id: outerLoop.rfq_project_id,\n       rfq_document_id: outerLoop.rfq_document_id,\n       project_name: outerLoop.nombre_proyecto,\n       tipo_evaluacion: outerLoop.tipo_evaluacion\n   };\n} catch(e){}\n\nreturn items.map(item => {\n    const phase = item.fase || \"General\";\n    const req = item.requisito_rfq || \"Sin Nombre\";\n    return {\n        json: {\n            rfq_project_id: loopCtx.rfq_project_id || \"unknown\",\n            rfq_document_id: loopCtx.rfq_document_id || \"unknown\",\n            project_name: loopCtx.project_name || \"Unknown\",\n            evaluation: loopCtx.tipo_evaluacion || \"Deliverables\",\n            fase: phase,\n            requisito_rfq: req\n        }\n    };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2720,
        688
      ],
      "id": "6062a706-3d2c-42f2-af26-efa2208d414f",
      "name": "Parsear deliverables"
    },
    {
      "parameters": {
        "model": "qwen3:8b",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2304,
        464
      ],
      "id": "71a56d5a-5407-40e1-aa7b-019995cf2e79",
      "name": "Ollama Extractor1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"fase\": {\n        \"type\": \"string\",\n        \"description\": \"Nombre de la disciplina o √°rea (ej: Process Engineering, Mechanical Engineering, Civil and Structural, Electrical Engineering, etc.)\"\n      },\n      \"requisito_rfq\": {\n        \"type\": \"string\",\n        \"description\": \"Nombre del documento o entregable espec√≠fico\"\n      }\n    },\n    \"required\": [\"fase\", \"requisito_rfq\"]\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2608,
        896
      ],
      "id": "01c23aa6-216c-4305-ae73-76b9089ef07e",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"fase\": {\n        \"type\": \"string\",\n        \"description\": \"Fase del proyecto o disciplina (ej: PRE-FEED, FEED, EPC, Process Engineering, etc.)\"\n      },\n      \"requisito_rfq\": {\n        \"type\": \"string\",\n        \"description\": \"Requisito t√©cnico o econ√≥mico espec√≠fico\"\n      }\n    },\n    \"required\": [\"fase\", \"requisito_rfq\"]\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2544,
        464
      ],
      "id": "c97006f9-f2df-4637-95bb-ea29b8c44f52",
      "name": "Structured Output Parser2"
    },
    {
      "parameters": {
        "jsCode": "// =============================================\n// NODO: Dividir en Trozos (Chunking)\n// =============================================\n\nconst input = $input.first().json;\nconst fullText = input.texto_rfq || \"\";\n\n// Tama√±o: ~12,000 caracteres (aprox 3k-4k tokens)\nconst chunkSize = 15000;\nconst overlap = 1500;\nconst chunks = [];\n\nif (fullText.length <= chunkSize) {\n    chunks.push({\n        ...input,\n        texto_chunk: fullText,\n        chunk_index: 1,\n        total_chunks: 1\n    });\n} else {\n    let start = 0;\n    while (start < fullText.length) {\n        let end = start + chunkSize;\n        let chunk = fullText.substring(start, end);\n        \n        chunks.push({\n            ...input,\n            texto_chunk: chunk,\n            chunk_index: chunks.length + 1\n        });\n\n        start += (chunkSize - overlap);\n        if (start >= fullText.length) break;\n    }\n    chunks.forEach(c => c.total_chunks = chunks.length);\n}\n\nreturn chunks;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        448
      ],
      "id": "abd68381-e264-48ef-93d7-0f4b340568a3",
      "name": "Dividir en Trozos1",
      "disabled": true
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.reiniciar_bucle ? true : false }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1792,
        448
      ],
      "id": "9a877197-f03c-46b3-a0de-fd069cd456f8",
      "name": "Loop por Trozo1"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => ({\n    json: {\n        ...item.json, // Mantiene todos los datos originales (incluido tipo_evaluacion)\n        \n        // Aqu√≠ est√° la correcci√≥n: Usamos dos puntos, no el igual.\n        reiniciar_bucle: true \n    }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        448
      ],
      "id": "844aa1e1-4ea9-46ae-90c2-81f41ce03547",
      "name": "Reset Items1"
    },
    {
      "parameters": {
        "model": "qwen3-embedding:8b"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        512,
        560
      ],
      "id": "efdcce2c-2eae-4053-b211-64c7b5038153",
      "name": "Embeddings Ollama1",
      "credentials": {
        "ollamaApi": {
          "id": "oS2Qqti9oVfsm8XZ",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "rfq",
          "mode": "list",
          "cachedResultName": "rfq"
        },
        "options": {
          "queryName": "match_rfq"
        }
      },
      "id": "dc6f47ec-b26b-4491-a15e-eeef9d0aff34",
      "name": "Insert into Supabase Vectorstore1",
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1,
      "position": [
        592,
        336
      ],
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "chunkSize": 800,
        "chunkOverlap": 150,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        768,
        768
      ],
      "id": "940045c4-abce-447a-b539-4151af7e3920",
      "name": "Recursive Character Text Splitter1"
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $('Preparar Texto1').item.json.text_for_classification }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $json.id }}"
              },
              {
                "name": "file_title",
                "value": "={{ $('Generate IDs1').first().json.file_title }}"
              },
              {
                "name": "tipo_evaluacion",
                "value": "={{ $('Clasificador de Tipos1').item.json.output.tipos_detectados }}"
              },
              {
                "name": "tipo-doc",
                "value": "RFQ"
              }
            ]
          }
        }
      },
      "id": "9397e861-e986-4430-bc6a-5f12fdf5fc24",
      "name": "Default Data Loader1",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        688,
        560
      ]
    },
    {
      "parameters": {
        "tableId": "rfq_items_master",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "project_name",
              "fieldValue": "=PROJECT H2 PLANT IN LA ZAIDA, ZARAGOZA (SPAIN)"
            },
            {
              "fieldId": "evaluation_type",
              "fieldValue": "={{ $json.evaluation }}"
            },
            {
              "fieldId": "phase",
              "fieldValue": "={{ $json.fase }}"
            },
            {
              "fieldId": "requirement_text",
              "fieldValue": "={{ $json.requisito_rfq }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        3040,
        464
      ],
      "id": "29dd3eaf-f42c-49b1-841b-13b87808bc22",
      "name": "Create a row",
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "rfq",
        "filterType": "string",
        "filterString": "=metadata->>file_id=like.*{{ $json.file_id }}*"
      },
      "id": "aceb96cf-bd88-4f4e-9abf-f27d26e4f4c4",
      "name": "Delete Old Doc Rows1",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -384,
        112
      ],
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "document_metadata",
          "mode": "list",
          "cachedResultName": "document_metadata"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $('Generate IDs1').first().json.file_id }}",
            "title": "={{ $('Generate IDs1').first().json.file_title }}",
            "project_name": "=PROJECT H2 PLANT IN LA ZAIDA, ZARAGOZA (SPAIN)",
            "document_type": "=RFQ",
            "evaluation_types": "={{ $json.output.tipos_detectados }}",
            "provider": "IGNIS"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": true,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "title",
              "displayName": "title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "project_name",
              "displayName": "project_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "document_type",
              "displayName": "document_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "provider",
              "displayName": "provider",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "evaluation_types",
              "displayName": "evaluation_types",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        368,
        336
      ],
      "id": "5e319136-f822-4d56-96e2-6a3b298df564",
      "name": "Insert Document Metadata2",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "V0REAPph5JBLqze3",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "model": "mistral-large-latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        2416,
        528
      ],
      "id": "7eab12a9-c286-4a1a-8442-1c3313503a38",
      "name": "Mistral Cloud Chat Model4",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.embeddingsCohere",
      "typeVersion": 1,
      "position": [
        880,
        784
      ],
      "id": "ed1e6a43-63d2-4161-b9c3-cd410cf7a332",
      "name": "Embeddings Cohere1",
      "credentials": {
        "cohereApi": {
          "id": "KGv4zlUJIjLdxpnr",
          "name": "CohereApi account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### RFQ REQUIREMENTS EXTRACTION - EXHAUSTIVE\n\nProject: {{ $json.nombre_proyecto }}\nType: {{ $json.tipo_evaluacion }}\nChunk: {{ $json.chunk_index }}/{{ $json.total_chunks }}\n\n### TEXT TO ANALYZE:\n{{ $json.texto_chunk }}\n\n---\n### VALID PHASES:\n- Process Engineering\n- Mechanical Engineering  \n- Electrical Engineering\n- Civil & Structural\n- Instrumentation & Control\n- Piping\n- HSE / Safety\n- Project Management\n- Quality Assurance\n- General Requirements\n\n### WHAT TO EXTRACT (be exhaustive):\n\n‚úÖ **EXTRACT ALL OF THESE:**\n- Numerical specifications (pressures, temperatures, flows, capacities, dimensions)\n- Quality standards and codes (ISO, API, ASME, NFPA, IEC)\n- Material requirements (steel grades, coatings, certifications)\n- Equipment specifications (pumps, compressors, tanks, transformers)\n- Utility requirements (power, water, air, nitrogen)\n- Environmental limits (noise, emissions, effluents)\n- Safety requirements (ATEX zones, fire protection, detection systems)\n- Design conditions (ambient temp, seismic, wind loads)\n- Operational parameters (hours/year, availability, redundancy)\n- Deliverables and documents required\n- Compliance requirements (local regulations, permits)\n- Interface/battery limit conditions\n- Each row from tables as separate item\n\n### FORMAT RULES:\n\n1. **NO REDUNDANCY** - Don't repeat project context words\n2. **SHORT** (max 60 chars) - Value + unit, no long descriptions\n3. **SEARCHABLE** - Use standard prefixes: \"Pressure:\", \"Temp:\", \"Flow:\", \"Code:\", \"Material:\"\n4. **SPLIT** compound data into separate items\n\n### EXAMPLES:\n\nFrom: \"The plant operates at 7 bar with temperature range 20-40¬∞C\"\n‚Üí {\"fase\": \"Process Engineering\", \"requisito_rfq\": \"Operating pressure: 7 barg\"}\n‚Üí {\"fase\": \"Process Engineering\", \"requisito_rfq\": \"Operating temp: 20-40¬∞C\"}\n\nFrom: \"Compressed air per ISO 8573-1 class 1.2.0\"\n‚Üí {\"fase\": \"Mechanical Engineering\", \"requisito_rfq\": \"Instrument air: ISO 8573-1 class 1.2.0\"}\n\nFrom: \"ATEX Zone 2 classification for outdoor areas\"\n‚Üí {\"fase\": \"HSE / Safety\", \"requisito_rfq\": \"ATEX Zone 2: outdoor areas\"}\n\nFrom: \"30 kV power supply from grid\"\n‚Üí {\"fase\": \"Electrical Engineering\", \"requisito_rfq\": \"Grid supply: 30 kV\"}\n\nFrom table row: \"Buffer tank | 40 barg | SS316L\"\n‚Üí {\"fase\": \"Mechanical Engineering\", \"requisito_rfq\": \"Buffer tank: 40 barg, SS316L\"}\n\n### JSON FORMAT:\n```json\n[\n  {\"fase\": \"Phase\", \"requisito_rfq\": \"Short requirement with value\"}\n]\n```\n\n**RESPONSE (JSON only, be EXHAUSTIVE):**",
        "messages": {
          "messageValues": [
            {
              "message": "You are an exhaustive Requirements Extractor for EPC tenders.\n\nMISSION: Extract ALL technical requirements, specifications, and parameters.\n\nRULES:\n- Be EXHAUSTIVE - extract every specification, parameter, code reference\n- NO redundancy - don't repeat project name terms\n- SHORT - max 60 chars, focus on value + unit\n- SEARCHABLE - use standard prefixes (Pressure:, Temp:, Code:, Material:)\n- SPLIT compound requirements into separate items\n- Extract EACH table row as separate item\n- If text has no requirements: return []\n- JSON only"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2384,
        256
      ],
      "id": "07d7e073-8026-4c83-8279-c636ebbb8335",
      "name": "LLM Extractor Tech-Econ"
    }
  ],
  "connections": {
    "Webhook RFQ": {
      "main": [
        [
          {
            "node": "Generate IDs1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Texto1": {
      "main": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clasificador de Tipos1": {
      "main": [
        [
          {
            "node": "Insert Document Metadata2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Clasificador1": {
      "ai_languageModel": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Clasificador de Tipos1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Expandir por Tipo1": {
      "main": [
        [
          {
            "node": "Loop por Tipo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop por Tipo1": {
      "main": [
        [
          {
            "node": "Resumen Final1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Dividir en Trozos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear Items1": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agregar Resultados1": {
      "main": [
        [
          {
            "node": "Loop por Trozo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resumen Final1": {
      "main": [
        [
          {
            "node": "Respond Success1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Base64 a Binary3": {
      "main": [
        [
          {
            "node": "Extract from File3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File3": {
      "main": [
        [
          {
            "node": "Preparar Texto1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate IDs1": {
      "main": [
        [
          {
            "node": "Delete Old Doc Rows1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "LLM Extractor Tech-Econ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "LLM Extractor - Deliverables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Extractor2": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Extractor - Deliverables",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "LLM Extractor - Deliverables": {
      "main": [
        [
          {
            "node": "Parsear deliverables",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parsear deliverables": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dividir en Trozos1": {
      "main": [
        [
          {
            "node": "Reset Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop por Trozo1": {
      "main": [
        [
          {
            "node": "Loop por Tipo1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset Items1": {
      "main": [
        [
          {
            "node": "Loop por Trozo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert into Supabase Vectorstore1": {
      "main": [
        [
          {
            "node": "Expandir por Tipo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter1": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader1",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader1": {
      "ai_document": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Create a row": {
      "main": [
        [
          {
            "node": "Agregar Resultados1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Doc Rows1": {
      "main": [
        [
          {
            "node": "Base64 a Binary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Document Metadata2": {
      "main": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral Cloud Chat Model4": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Extractor Tech-Econ",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Cohere1": {
      "ai_embedding": [
        [
          {
            "node": "Insert into Supabase Vectorstore1",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "LLM Extractor Tech-Econ": {
      "main": [
        [
          {
            "node": "Parsear Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "53140335eaf11280ef77ef2f5a378f48c2b28e822e3e0d96563cdd92175c0eff"
  }
}