{
  "nodes": [
    {
      "parameters": {
        "content": "## /qa-process-email-response - AI Email Response Mapper\n\nProcesses supplier email responses and maps them to original Q&A questions using AI.\n\n**Method**: POST\n**Body**: { project_id, provider_name, email_content }\n\n**Flow**: Webhook ‚Üí Set Fields ‚Üí Fetch Q&A Questions ‚Üí Build AI Context ‚Üí LLM Chain ‚Üí Parse Output ‚Üí Respond\n\n**Returns**: { success, processed_count, mappings: [{ question_id, question_text, response_text, confidence, matched }] }",
        "height": 400,
        "width": 2400,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -400,
        8048
      ],
      "id": "7c039932-584f-497c-be93-13db1ef2f936",
      "name": "Sticky Note QA Email"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "qa-process-email-response",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -320,
        8304
      ],
      "id": "d7a195c3-6e7b-4254-9342-ceebecf0c6d6",
      "name": "Webhook QA Email Response",
      "webhookId": "qa-email-response-webhook-001"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "qa-email-project-id",
              "name": "project_id",
              "value": "={{ $json.body.project_id }}",
              "type": "string"
            },
            {
              "id": "qa-email-provider",
              "name": "provider_name",
              "value": "={{ $json.body.provider_name }}",
              "type": "string"
            },
            {
              "id": "qa-email-content",
              "name": "email_content",
              "value": "={{ $json.body.email_content }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -112,
        8304
      ],
      "id": "cd9e982d-43ea-49de-a011-069cd6a2305e",
      "name": "Set QA Email Params"
    },
    {
      "parameters": {
        "useCustomSchema": true,
        "schema": "public",
        "operation": "getAll",
        "tableId": "qa_audit",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "project_id",
              "condition": "eq",
              "keyValue": "={{ $json.project_id }}"
            },
            {
              "keyName": "provider_name",
              "condition": "eq",
              "keyValue": "={{ $json.provider_name }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        80,
        8304
      ],
      "id": "d0d1ae67-6ca0-433e-9e8a-9c19773ac611",
      "name": "Fetch QA Questions",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "pI4CpdYLTiEEBmnz",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build context for LLM: combine Q&A questions with email content\nconst questions = $('Fetch QA Questions').all();\nconst params = $('Set QA Email Params').first().json;\n\nconst questionList = questions.map(q => ({\n  id: q.json.id,\n  question: q.json.question,\n  discipline: q.json.discipline,\n  importance: q.json.importance,\n  status: q.json.status\n}));\n\nconsole.log(`üìß Processing email response:`);\nconsole.log(`   ‚îú‚îÄ Provider: ${params.provider_name}`);\nconsole.log(`   ‚îú‚îÄ Questions found: ${questionList.length}`);\nconsole.log(`   ‚îî‚îÄ Email length: ${(params.email_content || '').length} chars`);\n\nreturn [{\n  json: {\n    project_id: params.project_id,\n    provider_name: params.provider_name,\n    email_content: params.email_content,\n    questions: questionList,\n    total_questions: questionList.length\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        8304
      ],
      "id": "14fccf74-6309-4f87-9e6f-d64ab4018df4",
      "name": "Build AI Context"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=### INPUT\n\n## PROVIDER: {{ $json.provider_name }}\n\n## ORIGINAL QUESTIONS ({{ $json.total_questions }} items):\n{{ JSON.stringify($json.questions, null, 2) }}\n\n## SUPPLIER EMAIL RESPONSE:\n{{ $json.email_content }}\n\n### INSTRUCTIONS\nAnalyze the supplier's email response and map each answer to its most likely original question.\nFor each mapping, provide a confidence score (0.0 to 1.0) indicating how certain you are of the match.\nIf a question has no corresponding answer in the email, set matched=false and response_text to empty string.\n\nReturn ONLY the JSON object. Do NOT include any text before or after the JSON.\n\n### OUTPUT SCHEMA\n{\n  \"success\": true,\n  \"processed_count\": <number of matched responses>,\n  \"mappings\": [\n    {\n      \"question_id\": \"<uuid from original question>\",\n      \"question_text\": \"<original question text>\",\n      \"response_text\": \"<extracted response from email>\",\n      \"confidence\": <0.0 to 1.0>,\n      \"matched\": <true/false>\n    }\n  ]\n}",
        "messages": {
          "messageValues": [
            {
              "message": "You are an expert AI assistant specialized in analyzing supplier email responses for procurement Q&A processes.\n\n### ROLE\nYou analyze email responses from suppliers and map each answer to its original technical question from a Q&A audit.\n\n### GUIDELINES\n1. Read the email carefully and identify distinct answers or response sections.\n2. Match each answer to the most relevant original question based on content, keywords, and context.\n3. Extract the exact response text from the email for each matched question.\n4. Assign confidence scores: 0.9+ for clear matches, 0.6-0.8 for likely matches, below 0.5 for uncertain.\n5. If a question has no answer in the email, mark it as not matched.\n6. Preserve the original question_id UUID exactly as provided.\n\n### CRITICAL: OUTPUT RESTRICTIONS\n- Return **ONLY** a valid JSON object.\n- **DO NOT** include any conversational text, explanations, or reasoning.\n- **DO NOT** use Markdown code blocks.\n- The output must start with `{` and end with `}`."
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        480,
        8304
      ],
      "id": "d86c1b4b-48af-4afc-b454-4e25ba738ab7",
      "name": "QA Email Mapping Chain"
    },
    {
      "parameters": {
        "model": "mistral-large-latest",
        "options": {
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatMistralCloud",
      "typeVersion": 1,
      "position": [
        480,
        8512
      ],
      "id": "d9f2e45d-a004-4bb4-ab84-4477da88125a",
      "name": "Mistral QA Email Model",
      "credentials": {
        "mistralCloudApi": {
          "id": "tDjuOnF6lpADMmd5",
          "name": "Mistral Cloud account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM output and ensure correct response format\nconst llmOutput = $input.first().json;\nlet result;\n\ntry {\n  // The LLM chain returns output in .text or .output\n  const rawText = llmOutput.text || llmOutput.output || JSON.stringify(llmOutput);\n  \n  // Try to parse as JSON\n  let parsed;\n  if (typeof rawText === 'string') {\n    // Clean potential markdown code blocks\n    const cleaned = rawText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n    parsed = JSON.parse(cleaned);\n  } else {\n    parsed = rawText;\n  }\n  \n  // Validate and normalize\n  const mappings = (parsed.mappings || []).map(m => ({\n    question_id: m.question_id || '',\n    question_text: m.question_text || '',\n    response_text: m.response_text || '',\n    confidence: typeof m.confidence === 'number' ? m.confidence : 0,\n    matched: m.matched === true\n  }));\n  \n  const matchedCount = mappings.filter(m => m.matched).length;\n  \n  result = {\n    success: true,\n    processed_count: matchedCount,\n    mappings: mappings,\n    message: `Processed ${matchedCount} of ${mappings.length} questions from email`\n  };\n  \n  console.log(`‚úÖ QA Email Response processed:`);\n  console.log(`   ‚îú‚îÄ Total mappings: ${mappings.length}`);\n  console.log(`   ‚îî‚îÄ Matched: ${matchedCount}`);\n} catch (err) {\n  console.error('‚ùå Error parsing LLM output:', err.message);\n  result = {\n    success: false,\n    processed_count: 0,\n    mappings: [],\n    message: 'Error parsing AI response: ' + err.message\n  };\n}\n\nreturn [{ json: result }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        688,
        8304
      ],
      "id": "4ccea6b1-5d36-4a66-80b4-067a278bfa1e",
      "name": "Parse QA Email Output"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        880,
        8304
      ],
      "id": "dbb102f6-6d98-4346-8b41-b1bb50797e7b",
      "name": "Respond QA Email Response"
    }
  ],
  "connections": {
    "Webhook QA Email Response": {
      "main": [
        [
          {
            "node": "Set QA Email Params",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set QA Email Params": {
      "main": [
        [
          {
            "node": "Fetch QA Questions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch QA Questions": {
      "main": [
        [
          {
            "node": "Build AI Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build AI Context": {
      "main": [
        [
          {
            "node": "QA Email Mapping Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "QA Email Mapping Chain": {
      "main": [
        [
          {
            "node": "Parse QA Email Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral QA Email Model": {
      "ai_languageModel": [
        [
          {
            "node": "QA Email Mapping Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Parse QA Email Output": {
      "main": [
        [
          {
            "node": "Respond QA Email Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "53140335eaf11280ef77ef2f5a378f48c2b28e822e3e0d96563cdd92175c0eff"
  }
}